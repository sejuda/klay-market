{"ast":null,"code":"'use strict';\n\nconst ndjson = require('iterable-ndjson');\n\nconst {\n  objectToQuery\n} = require('../lib/querystring');\n\nconst configure = require('../lib/configure');\n\nconst {\n  ok,\n  toIterable\n} = require('../lib/fetch');\n\nconst {\n  toFormData\n} = require('./form-data');\n\nconst toCamel = require('../lib/to-camel');\n\nmodule.exports = configure(({\n  fetch,\n  apiUrl,\n  apiPath,\n  headers\n}) => {\n  return (input, options) => async function* () {\n    options = options || {};\n    const qs = objectToQuery({\n      'stream-channels': true,\n      chunker: options.chunker,\n      'cid-version': options.cidVersion,\n      'cid-base': options.cidBase,\n      'enable-sharding-experiment': options.enableShardingExperiment,\n      hash: options.hashAlg,\n      'only-hash': options.onlyHash,\n      pin: options.pin,\n      progress: options.progress ? true : null,\n      quiet: options.quiet,\n      quieter: options.quieter,\n      'raw-leaves': options.rawLeaves,\n      'shard-split-threshold': options.shardSplitThreshold,\n      silent: options.silent,\n      trickle: options.trickle,\n      'wrap-with-directory': options.wrapWithDirectory,\n      ...(options.qs || {})\n    });\n    const url = `${apiUrl}${apiPath}/add${qs}`;\n    const res = await ok(fetch(url, {\n      method: 'POST',\n      signal: options.signal,\n      headers: options.headers || headers,\n      body: await toFormData(input)\n    }));\n\n    for await (let file of ndjson(toIterable(res.body))) {\n      file = toCamel(file); // console.log(file)\n\n      if (options.progress && file.bytes) {\n        options.progress(file.bytes);\n      } else {\n        yield toCamel(file);\n      }\n    }\n  }();\n});","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/ipfs-http-client-lite/src/add/index.js"],"names":["ndjson","require","objectToQuery","configure","ok","toIterable","toFormData","toCamel","module","exports","fetch","apiUrl","apiPath","headers","input","options","qs","chunker","cidVersion","cidBase","enableShardingExperiment","hash","hashAlg","onlyHash","pin","progress","quiet","quieter","rawLeaves","shardSplitThreshold","silent","trickle","wrapWithDirectory","url","res","method","signal","body","file","bytes"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,iBAAD,CAAtB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAoBD,OAAO,CAAC,oBAAD,CAAjC;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAM;AAAEG,EAAAA,EAAF;AAAMC,EAAAA;AAAN,IAAqBJ,OAAO,CAAC,cAAD,CAAlC;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAiBL,OAAO,CAAC,aAAD,CAA9B;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,iBAAD,CAAvB;;AAEAO,MAAM,CAACC,OAAP,GAAiBN,SAAS,CAAC,CAAC;AAAEO,EAAAA,KAAF;AAASC,EAAAA,MAAT;AAAiBC,EAAAA,OAAjB;AAA0BC,EAAAA;AAA1B,CAAD,KAAyC;AAClE,SAAO,CAACC,KAAD,EAAQC,OAAR,KAAqB,mBAAoB;AAC9CA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,UAAMC,EAAE,GAAGd,aAAa,CAAC;AACvB,yBAAmB,IADI;AAEvBe,MAAAA,OAAO,EAAEF,OAAO,CAACE,OAFM;AAGvB,qBAAeF,OAAO,CAACG,UAHA;AAIvB,kBAAYH,OAAO,CAACI,OAJG;AAKvB,oCAA8BJ,OAAO,CAACK,wBALf;AAMvBC,MAAAA,IAAI,EAAEN,OAAO,CAACO,OANS;AAOvB,mBAAaP,OAAO,CAACQ,QAPE;AAQvBC,MAAAA,GAAG,EAAET,OAAO,CAACS,GARU;AASvBC,MAAAA,QAAQ,EAAEV,OAAO,CAACU,QAAR,GAAmB,IAAnB,GAA0B,IATb;AAUvBC,MAAAA,KAAK,EAAEX,OAAO,CAACW,KAVQ;AAWvBC,MAAAA,OAAO,EAAEZ,OAAO,CAACY,OAXM;AAYvB,oBAAcZ,OAAO,CAACa,SAZC;AAavB,+BAAyBb,OAAO,CAACc,mBAbV;AAcvBC,MAAAA,MAAM,EAAEf,OAAO,CAACe,MAdO;AAevBC,MAAAA,OAAO,EAAEhB,OAAO,CAACgB,OAfM;AAgBvB,6BAAuBhB,OAAO,CAACiB,iBAhBR;AAiBvB,UAAIjB,OAAO,CAACC,EAAR,IAAc,EAAlB;AAjBuB,KAAD,CAAxB;AAoBA,UAAMiB,GAAG,GAAI,GAAEtB,MAAO,GAAEC,OAAQ,OAAMI,EAAG,EAAzC;AACA,UAAMkB,GAAG,GAAG,MAAM9B,EAAE,CAACM,KAAK,CAACuB,GAAD,EAAM;AAC9BE,MAAAA,MAAM,EAAE,MADsB;AAE9BC,MAAAA,MAAM,EAAErB,OAAO,CAACqB,MAFc;AAG9BvB,MAAAA,OAAO,EAAEE,OAAO,CAACF,OAAR,IAAmBA,OAHE;AAI9BwB,MAAAA,IAAI,EAAE,MAAM/B,UAAU,CAACQ,KAAD;AAJQ,KAAN,CAAN,CAApB;;AAOA,eAAW,IAAIwB,IAAf,IAAuBtC,MAAM,CAACK,UAAU,CAAC6B,GAAG,CAACG,IAAL,CAAX,CAA7B,EAAqD;AACnDC,MAAAA,IAAI,GAAG/B,OAAO,CAAC+B,IAAD,CAAd,CADmD,CAEnD;;AACA,UAAIvB,OAAO,CAACU,QAAR,IAAoBa,IAAI,CAACC,KAA7B,EAAoC;AAClCxB,QAAAA,OAAO,CAACU,QAAR,CAAiBa,IAAI,CAACC,KAAtB;AACD,OAFD,MAEO;AACL,cAAMhC,OAAO,CAAC+B,IAAD,CAAb;AACD;AACF;AACF,GAxC0B,EAA3B;AAyCD,CA1CyB,CAA1B","sourcesContent":["'use strict'\n\nconst ndjson = require('iterable-ndjson')\nconst { objectToQuery } = require('../lib/querystring')\nconst configure = require('../lib/configure')\nconst { ok, toIterable } = require('../lib/fetch')\nconst { toFormData } = require('./form-data')\nconst toCamel = require('../lib/to-camel')\n\nmodule.exports = configure(({ fetch, apiUrl, apiPath, headers }) => {\n  return (input, options) => (async function * () {\n    options = options || {}\n\n    const qs = objectToQuery({\n      'stream-channels': true,\n      chunker: options.chunker,\n      'cid-version': options.cidVersion,\n      'cid-base': options.cidBase,\n      'enable-sharding-experiment': options.enableShardingExperiment,\n      hash: options.hashAlg,\n      'only-hash': options.onlyHash,\n      pin: options.pin,\n      progress: options.progress ? true : null,\n      quiet: options.quiet,\n      quieter: options.quieter,\n      'raw-leaves': options.rawLeaves,\n      'shard-split-threshold': options.shardSplitThreshold,\n      silent: options.silent,\n      trickle: options.trickle,\n      'wrap-with-directory': options.wrapWithDirectory,\n      ...(options.qs || {})\n    })\n\n    const url = `${apiUrl}${apiPath}/add${qs}`\n    const res = await ok(fetch(url, {\n      method: 'POST',\n      signal: options.signal,\n      headers: options.headers || headers,\n      body: await toFormData(input)\n    }))\n\n    for await (let file of ndjson(toIterable(res.body))) {\n      file = toCamel(file)\n      // console.log(file)\n      if (options.progress && file.bytes) {\n        options.progress(file.bytes)\n      } else {\n        yield toCamel(file)\n      }\n    }\n  })()\n})\n"]},"metadata":{},"sourceType":"script"}