{"ast":null,"code":"'use strict';\n\nconst ndjson = require('iterable-ndjson');\n\nconst explain = require('explain-error');\n\nconst {\n  objectToQuery\n} = require('../lib/querystring');\n\nconst configure = require('../lib/configure');\n\nconst {\n  ok,\n  toIterable\n} = require('../lib/fetch');\n\nconst SubscriptionTracker = require('./subscription-tracker');\n\nmodule.exports = configure(({\n  fetch,\n  apiUrl,\n  apiPath,\n  headers\n}) => {\n  const subsTracker = SubscriptionTracker.singleton();\n  return async (topic, handler, options) => {\n    options = options || {};\n    options.signal = subsTracker.subscribe(topic, handler, options.signal);\n    const qs = objectToQuery({\n      arg: topic,\n      discover: options.discover,\n      ...(options.qs || {})\n    });\n    const url = `${apiUrl}${apiPath}/pubsub/sub${qs}`;\n    let res;\n\n    try {\n      res = await ok(fetch(url, {\n        method: 'POST',\n        signal: options.signal,\n        headers: options.headers || headers\n      }));\n    } catch (err) {\n      // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler);\n      throw err;\n    } // eslint-disable-next-line no-console\n\n\n    const onError = options.onError || (err => console.error(err));\n\n    (async () => {\n      try {\n        for await (const msg of ndjson(toIterable(res.body))) {\n          try {\n            handler({\n              from: Buffer.from(msg.from, 'base64'),\n              data: Buffer.from(msg.data, 'base64'),\n              seqno: Buffer.from(msg.seqno, 'base64'),\n              topicIDs: msg.topicIDs\n            });\n          } catch (err) {\n            onError(explain(err, 'Failed to parse pubsub message'), false); // Not fatal\n          }\n        }\n      } catch (err) {\n        // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n        // Temporarily use the name property instead.\n        if (err.type !== 'aborted' && err.name !== 'AbortError') {\n          onError(err, true); // Fatal\n        }\n      } finally {\n        subsTracker.unsubscribe(topic, handler);\n      }\n    })();\n  };\n});","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/ipfs-http-client-lite/src/pubsub/subscribe.js"],"names":["ndjson","require","explain","objectToQuery","configure","ok","toIterable","SubscriptionTracker","module","exports","fetch","apiUrl","apiPath","headers","subsTracker","singleton","topic","handler","options","signal","subscribe","qs","arg","discover","url","res","method","err","unsubscribe","onError","console","error","msg","body","from","Buffer","data","seqno","topicIDs","type","name"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ndjson = require('iterable-ndjson')\nconst explain = require('explain-error')\nconst { objectToQuery } = require('../lib/querystring')\nconst configure = require('../lib/configure')\nconst { ok, toIterable } = require('../lib/fetch')\nconst SubscriptionTracker = require('./subscription-tracker')\n\nmodule.exports = configure(({ fetch, apiUrl, apiPath, headers }) => {\n  const subsTracker = SubscriptionTracker.singleton()\n\n  return async (topic, handler, options) => {\n    options = options || {}\n    options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n    const qs = objectToQuery({\n      arg: topic,\n      discover: options.discover,\n      ...(options.qs || {})\n    })\n\n    const url = `${apiUrl}${apiPath}/pubsub/sub${qs}`\n    let res\n\n    try {\n      res = await ok(fetch(url, {\n        method: 'POST',\n        signal: options.signal,\n        headers: options.headers || headers\n      }))\n    } catch (err) { // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler)\n      throw err\n    }\n\n    // eslint-disable-next-line no-console\n    const onError = options.onError || (err => console.error(err))\n\n    ;(async () => {\n      try {\n        for await (const msg of ndjson(toIterable(res.body))) {\n          try {\n            handler({\n              from: Buffer.from(msg.from, 'base64'),\n              data: Buffer.from(msg.data, 'base64'),\n              seqno: Buffer.from(msg.seqno, 'base64'),\n              topicIDs: msg.topicIDs\n            })\n          } catch (err) {\n            onError(explain(err, 'Failed to parse pubsub message'), false) // Not fatal\n          }\n        }\n      } catch (err) {\n        // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n        // Temporarily use the name property instead.\n        if (err.type !== 'aborted' && err.name !== 'AbortError') {\n          onError(err, true) // Fatal\n        }\n      } finally {\n        subsTracker.unsubscribe(topic, handler)\n      }\n    })()\n  }\n})\n"]},"metadata":{},"sourceType":"script"}