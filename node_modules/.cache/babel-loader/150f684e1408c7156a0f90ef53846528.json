{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst lodash = require('lodash');\n\nconst fs = require('fs');\n\nconst IPFSAPI = require('ipfs-http-client-lite');\n\nconst multihash = require('multihashes');\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @class\n */\n\n\nclass IPFS {\n  /**\n   * Create an IPFS.\n   * @param {string} host The host url.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL.\n   */\n  constructor(host, port, ssl) {\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\n   * sets a IPFS Node\n   *\n   * @param {string} host The host url.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL.\n   * @return {void}\n   */\n\n\n  setIPFSNode(host, port, ssl) {\n    const protocol = ssl ? 'https' : 'http';\n    this.ipfs = IPFSAPI({\n      apiUrl: `${protocol}://${host}:${port}`\n    });\n  }\n  /**\n   * adds a file to IPFS.\n   * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\n   * If the `data` parameter is a string, use `fs` to read the file.\n   * Since `fs` is a module that can only be used on the server side, if it is client-side code,\n   * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\n   *\n   * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\n   * @example\n   * module.exports = {\n   *     ...\n   *     node: {\n   *         fs: 'empty',\n   *     },\n   *     ...\n   * }\n   * @returns {null}\n   *\n   * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\n   * @example\n   * module.exports = {\n   *     ...\n   *     webpack: (config, { isServer }) => {\n   *         // Fixes npm packages that depend on `fs` module\n   *         if (!isServer) {\n   *             config.node = {\n   *                 fs: 'empty'\n   *             }\n   *         }\n   *         return config\n   *     },\n   *     ...\n   * }\n   * @returns {null}\n   *\n   * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\n   * @return {string}\n   */\n\n\n  async add(data) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`); // Read file\n\n    if (lodash.isString(data)) {\n      if (typeof window !== 'undefined') throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`);\n      data = fs.readFileSync(data);\n    }\n\n    if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`);\n    const ret = await this.ipfs.add(Buffer.from(data));\n    return ret[0].hash;\n  }\n  /**\n   * gets a file from IPFS\n   *\n   * @param {string} hash The file hash string.\n   * @return {Buffer}\n   */\n\n\n  async get(hash) {\n    if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`);\n    const ret = await this.ipfs.cat(hash);\n    return ret;\n  }\n  /**\n   * converts a hash to hex format.\n   *\n   * @param {string} hash The file hash string.\n   * @return {string}\n   */\n\n\n  toHex(hash) {\n    const buf = multihash.fromB58String(hash);\n    return `0x${multihash.toHexString(buf)}`;\n  }\n  /**\n   * converts from a hex format.\n   *\n   * @param {string} hash The file hash string in hex format.\n   * @return {string}\n   */\n\n\n  fromHex(contentHash) {\n    const hex = contentHash.substring(2);\n    const buf = multihash.fromHexString(hex);\n    return multihash.toB58String(buf);\n  }\n\n}\n\nmodule.exports = IPFS;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-ipfs/src/index.js"],"names":["lodash","require","fs","IPFSAPI","multihash","IPFS","constructor","host","port","ssl","undefined","setIPFSNode","protocol","ipfs","apiUrl","add","data","Error","isString","window","readFileSync","isBuffer","isArrayBuffer","ret","Buffer","from","hash","get","cat","toHex","buf","fromB58String","toHexString","fromHex","contentHash","hex","substring","fromHexString","toB58String","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable class-methods-use-this */\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst lodash = require('lodash')\nconst fs = require('fs')\nconst IPFSAPI = require('ipfs-http-client-lite')\nconst multihash = require('multihashes')\n\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @class\n */\nclass IPFS {\n    /**\n     * Create an IPFS.\n     * @param {string} host The host url.\n     * @param {number} port The port number to use.\n     * @param {boolean} ssl With or without SSL.\n     */\n    constructor(host, port, ssl) {\n        if (host !== undefined && port !== undefined && ssl !== undefined) {\n            this.setIPFSNode(host, port, ssl)\n        }\n    }\n\n    /**\n     * sets a IPFS Node\n     *\n     * @param {string} host The host url.\n     * @param {number} port The port number to use.\n     * @param {boolean} ssl With or without SSL.\n     * @return {void}\n     */\n    setIPFSNode(host, port, ssl) {\n        const protocol = ssl ? 'https' : 'http'\n        this.ipfs = IPFSAPI({ apiUrl: `${protocol}://${host}:${port}` })\n    }\n\n    /**\n     * adds a file to IPFS.\n     * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\n     * If the `data` parameter is a string, use `fs` to read the file.\n     * Since `fs` is a module that can only be used on the server side, if it is client-side code,\n     * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\n     *\n     * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\n     * @example\n     * module.exports = {\n     *     ...\n     *     node: {\n     *         fs: 'empty',\n     *     },\n     *     ...\n     * }\n     * @returns {null}\n     *\n     * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\n     * @example\n     * module.exports = {\n     *     ...\n     *     webpack: (config, { isServer }) => {\n     *         // Fixes npm packages that depend on `fs` module\n     *         if (!isServer) {\n     *             config.node = {\n     *                 fs: 'empty'\n     *             }\n     *         }\n     *         return config\n     *     },\n     *     ...\n     * }\n     * @returns {null}\n     *\n     * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\n     * @return {string}\n     */\n    async add(data) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n\n        // Read file\n        if (lodash.isString(data)) {\n            if (typeof window !== 'undefined')\n                throw new Error(`Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.`)\n            data = fs.readFileSync(data)\n        }\n        if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(`Invalid data: ${data}`)\n\n        const ret = await this.ipfs.add(Buffer.from(data))\n        return ret[0].hash\n    }\n\n    /**\n     * gets a file from IPFS\n     *\n     * @param {string} hash The file hash string.\n     * @return {Buffer}\n     */\n    async get(hash) {\n        if (!this.ipfs) throw new Error(`Please set IPFS Node through 'caver.ipfs.setIPFSNode'.`)\n        const ret = await this.ipfs.cat(hash)\n        return ret\n    }\n\n    /**\n     * converts a hash to hex format.\n     *\n     * @param {string} hash The file hash string.\n     * @return {string}\n     */\n    toHex(hash) {\n        const buf = multihash.fromB58String(hash)\n        return `0x${multihash.toHexString(buf)}`\n    }\n\n    /**\n     * converts from a hex format.\n     *\n     * @param {string} hash The file hash string in hex format.\n     * @return {string}\n     */\n    fromHex(contentHash) {\n        const hex = contentHash.substring(2)\n        const buf = multihash.fromHexString(hex)\n        return multihash.toB58String(buf)\n    }\n}\n\nmodule.exports = IPFS\n"]},"metadata":{},"sourceType":"script"}