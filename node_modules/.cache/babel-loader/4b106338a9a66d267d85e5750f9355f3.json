{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-contract/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  let Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  let contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst core = require('../../caver-core');\n\nconst Method = require('../../caver-core-method');\n\nconst utils = require('../../caver-utils');\n\nconst Subscription = require('../../caver-core-subscriptions').subscription;\n\nconst SmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/smartContractDeploy');\n\nconst SmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/smartContractExecution');\n\nconst FeeDelegatedSmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/feeDelegatedSmartContractDeploy');\n\nconst FeeDelegatedSmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/feeDelegatedSmartContractExecution');\n\nconst FeeDelegatedSmartContractDeployWithRatio = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/feeDelegatedSmartContractDeployWithRatio');\n\nconst FeeDelegatedSmartContractExecutionWithRatio = require('../../caver-transaction/src/transactionTypes/smartContractExecution/feeDelegatedSmartContractExecutionWithRatio');\n\nconst KeyringContainer = require('../../caver-wallet');\n\nconst {\n  formatters\n} = require('../../caver-core-helpers');\n\nconst {\n  errors\n} = require('../../caver-core-helpers');\n\nconst abi = require('../../caver-abi');\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * let myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, when contract deploy)\n *   gas: 200000, (gas limit)\n * });\n */\n\n\nconst Contract = function Contract(jsonInterface, address, options) {\n  const _this = this;\n\n  const args = Array.prototype.slice.call(arguments);\n\n  if (!(this instanceof Contract)) {\n    throw new Error('Please use the \"new\" keyword to instantiate a caver.contract() or caver.klay.Contract() object!');\n  } // sets _requestmanager\n\n\n  core.packageInit(this, [this.constructor.currentProvider]);\n  this.clearSubscriptions = this._requestManager.clearSubscriptions;\n\n  if (!jsonInterface || !Array.isArray(jsonInterface)) {\n    throw new Error('You must provide the json interface of the contract when instantiating a contract object.');\n  } // create the options object\n\n\n  this.options = {};\n  const lastArg = args[args.length - 1];\n\n  if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n    options = lastArg;\n    this.options = _.extend(this.options, this._getOrSetDefaultOptions(options));\n\n    if (_.isObject(address)) {\n      address = null;\n    }\n  }\n\n  Object.defineProperty(this, 'defaultSendOptions', {\n    get() {\n      return _this.options;\n    }\n\n  }); // set address\n\n  Object.defineProperty(this.options, 'address', {\n    set(value) {\n      if (value) {\n        _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n\n    get() {\n      return _this._address;\n    },\n\n    enumerable: true\n  }); // add method and event signatures, when the jsonInterface gets set\n\n  Object.defineProperty(this.options, 'jsonInterface', {\n    set(value) {\n      _this.methods = {};\n      _this.events = {};\n      _this._jsonInterface = value.map(function (method) {\n        let func;\n        let funcName;\n\n        if (method.name) {\n          funcName = utils._jsonInterfaceMethodToString(method);\n        } // function\n\n\n        if (method.type === 'function') {\n          method.signature = abi.encodeFunctionSignature(funcName);\n          func = _this._createTxObject.bind({\n            method,\n            parent: _this\n          }); // add method only if not one already exists\n\n          if (!_this.methods[method.name]) {\n            _this.methods[method.name] = func;\n          } else {\n            const cascadeFunc = _this._createTxObject.bind({\n              method,\n              parent: _this,\n              nextMethod: _this.methods[method.name]\n            });\n\n            _this.methods[method.name] = cascadeFunc;\n          } // definitely add the method based on its signature\n\n\n          _this.methods[method.signature] = func; // add method by name\n\n          _this.methods[funcName] = func; // event\n        } else if (method.type === 'event') {\n          method.signature = abi.encodeEventSignature(funcName);\n\n          const event = _this._on.bind(_this, method.signature); // add method only if not already exists\n\n\n          if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') {\n            _this.events[method.name] = event;\n          } // definitely add the method based on its signature\n\n\n          _this.events[method.signature] = event; // add event by name\n\n          _this.events[funcName] = event;\n        } // Make transaction object for constructor and add to the `this.methods`\n\n\n        const constructor = _.find(_this._jsonInterface, function (mth) {\n          return mth.type === 'constructor';\n        }) || {\n          type: 'constructor'\n        };\n        constructor.signature = 'constructor';\n\n        const constructorFunc = _this._createTxObject.bind({\n          method: constructor,\n          parent: _this\n        });\n\n        _this.methods[constructor.signature] = constructorFunc;\n        return method;\n      }); // add allEvents\n\n      _this.events.allEvents = _this._on.bind(_this, 'allevents');\n      return _this._jsonInterface;\n    },\n\n    get() {\n      return _this._jsonInterface;\n    },\n\n    enumerable: true\n  }); // get default account from the Class\n\n  let {\n    defaultAccount\n  } = this.constructor;\n  let defaultBlock = this.constructor.defaultBlock || 'latest';\n  Object.defineProperty(this, 'defaultAccount', {\n    get() {\n      return defaultAccount;\n    },\n\n    set(val) {\n      if (val) {\n        defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val));\n      }\n\n      return val;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this, 'defaultBlock', {\n    get() {\n      return defaultBlock;\n    },\n\n    set(val) {\n      if (!utils.isValidBlockNumberCandidate(val)) {\n        throw new Error('Invalid default block number.');\n      }\n\n      defaultBlock = val;\n      return val;\n    },\n\n    enumerable: true\n  }); // Check for setting options property.\n\n  Object.defineProperty(this.options, 'from', {\n    set(value) {\n      if (value) {\n        _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n\n    get() {\n      return _this._from;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'feePayer', {\n    set(value) {\n      if (value) {\n        _this._feePayer = utils.toChecksumAddress(formatters.inputAddressFormatter(value));\n      }\n    },\n\n    get() {\n      return _this._feePayer;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'feeDelegation', {\n    set(value) {\n      if (value !== undefined) {\n        _this._feeDelegation = value;\n      }\n    },\n\n    get() {\n      return _this._feeDelegation;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'feeRatio', {\n    set(fr) {\n      if (fr !== undefined) {\n        if (!_.isNumber(fr) && !utils.isHex(fr)) throw new Error(`Invalid type fo feeRatio: feeRatio should be number type or hex number string.`);\n        if (utils.hexToNumber(fr) <= 0 || utils.hexToNumber(fr) >= 100) throw new Error(`Invalid feeRatio: feeRatio is out of range. [1, 99]`);\n        _this._feeRatio = utils.numberToHex(fr);\n      }\n    },\n\n    get() {\n      return _this._feeRatio;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gasPrice', {\n    set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) {\n          throw errors.invalidGasPrice();\n        }\n\n        _this._gasPrice = value;\n      }\n    },\n\n    get() {\n      return _this._gasPrice;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'gas', {\n    set(value) {\n      if (value) {\n        if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit();\n        _this._gas = value;\n      }\n    },\n\n    get() {\n      return _this._gas;\n    },\n\n    enumerable: true\n  });\n  Object.defineProperty(this.options, 'data', {\n    set(value) {\n      if (value) {\n        if (!utils.isHexStrict(value)) throw errors.invalidData();\n        _this._data = value;\n      }\n    },\n\n    get() {\n      return _this._data;\n    },\n\n    enumerable: true\n  }); // properties\n\n  this.methods = {};\n  this.events = {};\n  this._address = null;\n  this._jsonInterface = []; // set getter/setter properties\n\n  this.options.address = address;\n  this.options.jsonInterface = jsonInterface;\n};\n/**\n * Creates an instance of Contract.\n *\n * @method create\n * @constructor\n * @param {Array} jsonInterface The Contract Application Binary Interface (ABI).\n * @param {string} [address] The contract address to call.\n * @param {object} [options] The options of the contract.\n */\n\n\nContract.create = function (jsonInterface, address, options) {\n  return new Contract(jsonInterface, address, options);\n};\n\nContract.setProvider = function (provider, accounts) {\n  core.packageInit(this, [provider]);\n  this._klayAccounts = accounts;\n};\n/**\n * Set _keyrings in contract instance.\n *\n * @param {KeyringContainer} keyrings\n */\n\n\nContract.prototype.setKeyrings = function (keyrings) {\n  if (!(keyrings instanceof KeyringContainer)) throw new Error(`keyrings should be an instance of 'KeyringContainer'`);\n  this._keyrings = keyrings;\n};\n/**\n * Set _wallet in contract instance.\n * When _wallet exists, contract will use _wallet instead of _klayAccounts\n *\n * @param {IWallet} wallet\n */\n\n\nContract.prototype.setWallet = function (wallet) {\n  this._wallet = wallet;\n};\n\nContract.prototype.addAccounts = function (accounts) {\n  this._klayAccounts = accounts;\n};\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\n\n\nContract.prototype._getCallback = function getCallback(args) {\n  if (args && _.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n\n/**\n * this._checkListener('newListener', subOptions.event.name);\n * this._checkListener('removeListener', subOptions.event.name);\n */\n\n\nContract.prototype._checkListener = function (type, event) {\n  if (event === type) {\n    throw new Error(`The event \"${type}\" is a reserved event name, you can't use it.`);\n  }\n};\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\n\n\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n  const gasPrice = options.gasPrice ? String(options.gasPrice) : null;\n  const from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null;\n  options.data = options.data || this.options.data;\n  options.from = from || this.options.from;\n  options.gasPrice = gasPrice || this.options.gasPrice;\n  const feePayer = options.feePayer ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.feePayer)) : null;\n  const feeRatio = options.feeRatio ? options.feeRatio : null;\n  const feeDelegation = options.feeDelegation !== undefined ? options.feeDelegation : null;\n  options.feePayer = feePayer || this.options.feePayer;\n  options.feeRatio = feeRatio || this.options.feeRatio;\n  options.feeDelegation = feeDelegation || this.options.feeDelegation; // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n\n  if (typeof options.gas === 'undefined') {\n    options.gas = options.gasLimit || this.options.gas;\n  } // TODO replace with only gasLimit?\n\n\n  delete options.gasLimit;\n  return options;\n};\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signatureâ€™s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\n\n\nContract.prototype._encodeEventABI = function (event, options) {\n  options = options || {};\n  const filter = options.filter || {};\n  const result = {};\n  ['fromBlock', 'toBlock'].filter(function (f) {\n    return options[f] !== undefined;\n  }).forEach(function (f) {\n    result[f] = formatters.inputBlockNumberFormatter(options[f]);\n  }); // use given topics\n\n  if (_.isArray(options.topics)) {\n    result.topics = options.topics; // create topics based on filter\n  } else {\n    result.topics = []; // add event signature\n\n    if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n      result.topics.push(event.signature);\n    } // add event topics (indexed arguments)\n\n\n    if (event.name !== 'ALLEVENTS') {\n      const indexedTopics = event.inputs.filter(i => i.indexed === true).map(i => {\n        const value = filter[i.name];\n        if (!value) return null; // TODO: https://github.com/ethereum/web3.js/issues/344\n\n        if (_.isArray(value)) {\n          return value.map(v => abi.encodeParameter(i.type, v));\n        }\n\n        return abi.encodeParameter(i.type, value);\n      });\n      result.topics = result.topics.concat(indexedTopics);\n    }\n\n    if (!result.topics.length) delete result.topics;\n  }\n\n  if (this.options.address) {\n    result.address = this.options.address.toLowerCase();\n  }\n\n  return result;\n};\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\n\nContract.prototype._decodeEventABI = function (data) {\n  let event = this;\n  data.data = data.data || '';\n  data.topics = data.topics || [];\n  const result = formatters.outputLogFormatter(data); // if allEvents get the right event\n\n  if (event.name === 'ALLEVENTS') {\n    event = event.jsonInterface.find(function (intf) {\n      return intf.signature === data.topics[0];\n    }) || {\n      anonymous: true\n    };\n  } // create empty inputs if none are present (e.g. anonymous events on allEvents)\n\n\n  event.inputs = event.inputs || [];\n  const argTopics = event.anonymous ? data.topics : data.topics.slice(1);\n  result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics);\n  delete result.returnValues.__length__; // add name\n\n  result.event = event.name; // add signature\n\n  result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]; // move the data and topics to \"raw\"\n\n  result.raw = {\n    data: result.data,\n    topics: result.topics\n  };\n  delete result.data;\n  delete result.topics;\n  return result;\n};\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\n\n\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n  const methodSignature = this._method.signature;\n  const args = this.arguments || [];\n  let signature = false;\n  const paramsABI = this._parent.options.jsonInterface.filter(function (json) {\n    return methodSignature === 'constructor' && json.type === methodSignature || (json.signature === methodSignature || json.signature === methodSignature.replace('0x', '') || json.name === methodSignature) && json.type === 'function';\n  }).map(function (json) {\n    const inputLength = _.isArray(json.inputs) ? json.inputs.length : 0;\n\n    if (inputLength !== args.length) {\n      throw new Error(`The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`);\n    }\n\n    if (json.type === 'function') {\n      signature = json.signature;\n    }\n\n    return _.isArray(json.inputs) ? json.inputs : [];\n  }).map(function (inputs) {\n    return abi.encodeParameters(inputs, args).replace('0x', '');\n  })[0] || ''; // return constructor\n\n  if (methodSignature === 'constructor') {\n    if (!this._deployData) {\n      throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.');\n    }\n\n    return this._deployData + paramsABI; // return method\n  }\n\n  const returnValue = signature ? signature + paramsABI : paramsABI;\n\n  if (!returnValue) {\n    throw new Error(`Couldn't find a matching contract method named \"${this._method.name}\".`);\n  } else {\n    return returnValue;\n  }\n};\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\n\n\nContract.prototype._decodeMethodReturn = function (outputs, returnValues) {\n  if (!returnValues) {\n    return null;\n  }\n\n  returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;\n  const result = abi.decodeParameters(outputs, returnValues);\n\n  if (result.__length__ === 1) {\n    return result[0];\n  }\n\n  delete result.__length__;\n  return result;\n};\n/**\n * Deploys the contract to the Klaytn.\n * After a successful deployment, the promise will be resolved with a new contract instance.\n *\n * @method deploy\n * @param {Object} options An object in which data, which is the byte code of the smart contract to be deployed, and arguments, which are parameters to be passed to the constructor of the smart contract, are defined.\n * @param {Function} [callback] The callback function.\n * @return {object} An object in which arguments and functions for contract deployment are defined\n */\n\n/**\n * Deploys the contract to the Klaytn.\n * After a successful deployment, the promise will be resolved with a new contract instance.\n *\n * @method deploy\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} byteCode The byte code of the contract.\n * @param {...*} parameters The parameters to be passed to the constructor of the smart contract.\n * @return {object} Promise will be resolved with a new contract instance. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.deploy = function (options, callback) {\n  const args = Array.prototype.slice.call(arguments); // This if condition will handle original usage\n  // contract.deploy({ data, arguments })\n  // contract.deploy({ data, arguments }, callback)\n\n  if (args.length === 1 || args.length === 2 && _.isFunction(args[args.length - 1])) {\n    options = options || {};\n    options.arguments = options.arguments || [];\n    options = this._getOrSetDefaultOptions(options); // return error, if no \"data\" is specified\n\n    if (!options.data) {\n      const error = new Error('No \"data\" specified in neither the given options, nor the default options.');\n      if (callback) callback(error);\n      throw error;\n    }\n\n    return this.methods.constructor(options.data, ...options.arguments);\n  } // contract.deploy({from, gas, ...}, byteCode, parameters)\n\n\n  const sendOptions = args[0];\n  const byteCode = args[1];\n  const params = args.slice(2);\n  return this.methods.constructor(byteCode, ...params).send(sendOptions);\n};\n/**\n * Sends a SmartContractExecution transaction to execute the function of the contract deployed in the Klaytn.\n * After a successful deployment, the promise will be resolved with a transaction receipt.\n *\n * @method send\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute.\n * @param {...*} parameters The parameters to be passed to the smart contract function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.send = function () {\n  const args = Array.prototype.slice.call(arguments); // contract.send({from, gas, ...}, 'functionName', parameters)\n\n  const sendOptions = args[0];\n  const functionName = args[1];\n  const params = args.slice(2);\n  return this.methods[functionName](...params).send(sendOptions);\n};\n/**\n * Calls a \"constant\" method and execute its smart contract method in the Klaytn Virtual Machine without sending any transaction.\n *\n * @method call\n * @param {object} [callObject] The options used for calling.\n * @param {string} functionName The function name to execute.\n * @param {...*} parameters The parameters to be passed to the smart contract function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.call = function () {\n  let args = Array.prototype.slice.call(arguments); // contract.call('functionName', parameters)\n  // contract.call({from, gas, ...}, 'functionName', parameters)\n\n  let callObject = {};\n\n  if (_.isObject(args[0])) {\n    callObject = args[0];\n    args = args.slice(1);\n  }\n\n  const functionName = args[0];\n  const params = args.slice(1);\n  return this.methods[functionName](...params).call(callObject);\n};\n/**\n * Signs a transaction as a sender to deploy or execute the contract.\n * After signing, the promise will be resolved with the signed transaction.\n *\n * If you want to use fee delegation, `feeDelegation` should be defined as `true` in the `sendOptions` parameter.\n * Also if you want to use partial fee delegation, you can define `feeRatio` in the `sendOptions` parameter.\n *\n * @method sign\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute. If you want to sign for deployig, please send 'constructor' here.\n * @param {...*} parameters The parameters to be passed to the smart contract constructor or function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.sign = function () {\n  const args = Array.prototype.slice.call(arguments); // contract.sign({from, gas, ...}, 'constructor', arguments)\n  // contract.sign({from, gas, ...}, 'functionName', arguments)\n  // contract.sign({from, gas, feeDelegation: true ...}, 'constructor', arguments)\n  // contract.sign({from, gas, feeDelegation: true, feeRatio: 30, ...}, 'functionName', arguments)\n\n  const sendOptions = args[0];\n  const functionName = args[1];\n  const params = args.slice(2);\n  return this.methods[functionName](...params).sign(sendOptions);\n};\n/**\n * Signs a transaction as a fee payer to deploy or execute the contract.\n * After signing, the promise will be resolved with the signed transaction.\n *\n * To sign as a fee payer, `feeDelegation` and `feePayer` should be defined in the `sendOptions` parameter.\n * `feeDelegation` field should be true.\n * Also if you want to use partial fee delegation, you can define `feeRatio` in the `sendOptions` parameter.\n *\n * @method sign\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute. If you want to sign for deployig, please send 'constructor' here.\n * @param {...*} parameters The parameters to be passed to the smart contract constructor or function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\n\n\nContract.prototype.signAsFeePayer = function () {\n  const args = Array.prototype.slice.call(arguments); // contract.signAsFeePayer({from, gas, feeDelegation: true ...}, 'constructor', arguments)\n  // contract.signAsFeePayer({from, gas, feeDelegation: true, feeRatio: 30, ...}, 'functionName', arguments)\n\n  const sendOptions = args[0];\n  const functionName = args[1];\n  const params = args.slice(2);\n  return this.methods[functionName](...params).signAsFeePayer(sendOptions);\n};\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\n\n\nContract.prototype._generateEventOptions = function () {\n  const args = Array.prototype.slice.call(arguments); // get the callback\n\n  const callback = this._getCallback(args); // get the options\n\n\n  const options = _.isObject(args[args.length - 1]) ? args.pop() : {};\n  let event = _.isString(args[0]) ? args[0] : 'allevents';\n  event = event.toLowerCase() === 'allevents' ? {\n    name: 'ALLEVENTS',\n    jsonInterface: this.options.jsonInterface\n  } : this.options.jsonInterface.find(function (json) {\n    return json.type === 'event' && (json.name === event || json.signature === `0x${event.replace('0x', '')}`);\n  });\n\n  if (!event) {\n    throw new Error(`Event \"${event.name}\" doesn't exist in this contract.`);\n  }\n\n  if (!utils.isAddress(this.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  return {\n    params: this._encodeEventABI(event, options),\n    event,\n    callback\n  };\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\n\n\nContract.prototype.clone = function (contractAddress = this.options.address) {\n  const cloned = new this.constructor(this.options.jsonInterface, contractAddress, this.options);\n  cloned.setWallet(this._wallet);\n  return cloned;\n};\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\n\n\nContract.prototype.once = function (event, options, callback) {\n  const args = Array.prototype.slice.call(arguments); // get the callback\n\n  callback = this._getCallback(args);\n\n  if (!callback) {\n    throw new Error('Once requires a callback as the second parameter.');\n  } // don't allow fromBlock\n\n\n  if (options) {\n    delete options.fromBlock;\n  } // don't return as once shouldn't provide \"on\"\n\n\n  this._on(event, options, function (err, res, sub) {\n    sub.unsubscribe();\n\n    if (_.isFunction(callback)) {\n      callback(err, res, sub);\n    }\n  });\n\n  return undefined;\n};\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\n\n\nContract.prototype._on = function () {\n  const subOptions = this._generateEventOptions.apply(this, arguments); // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n\n\n  this._checkListener('newListener', subOptions.event.name);\n\n  this._checkListener('removeListener', subOptions.event.name); // TODO check if listener already exists? and reuse subscription if options are the same.\n\n\n  const subscription = new Subscription({\n    subscription: {\n      params: 1,\n      inputFormatter: [formatters.inputLogFormatter],\n      outputFormatter: this._decodeEventABI.bind(subOptions.event),\n\n      // DUBLICATE, also in caver-klay\n      subscriptionHandler(output) {\n        this.emit('data', output);\n\n        if (_.isFunction(this.callback)) {\n          this.callback(null, output, this);\n        }\n      }\n\n    },\n    type: 'klay',\n    requestManager: this._requestManager\n  });\n  subscription.subscribe('logs', subOptions.params, subOptions.callback || function () {});\n  return subscription;\n};\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\n\n\nContract.prototype.getPastEvents = function () {\n  const subOptions = this._generateEventOptions.apply(this, arguments);\n\n  let getPastLogs = new Method({\n    name: 'getPastLogs',\n    call: 'klay_getLogs',\n    params: 1,\n    inputFormatter: [formatters.inputLogFormatter],\n    outputFormatter: this._decodeEventABI.bind(subOptions.event)\n  });\n  getPastLogs.setRequestManager(this._requestManager);\n  const call = getPastLogs.buildCall();\n  getPastLogs = null;\n  return call(subOptions.params, subOptions.callback);\n};\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\n\nContract.prototype._createTxObject = function _createTxObject() {\n  let args = Array.prototype.slice.call(arguments);\n  const txObject = {};\n\n  if (this.method.type === 'function') {\n    txObject.call = this.parent._executeMethod.bind(txObject, 'call');\n    txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true); // to make batch requests\n  }\n\n  txObject.sign = this.parent._executeMethod.bind(txObject, 'sign');\n  txObject.signAsFeePayer = this.parent._executeMethod.bind(txObject, 'signAsFeePayer');\n  txObject.send = this.parent._executeMethod.bind(txObject, 'send');\n  txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true); // to make batch requests\n\n  txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject);\n  txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate'); // When deploying a smart contract, if a parameter is passed by directly accessing the tx object,\n  // the byte code is transferred as the first parameter.\n  // (i.e. `contract.methods['constructor'](byteCode, arguments...).send({from, ...})`)\n  // To handle such a case, when `method.type` is a \"constructor\" and `this.deployData` is empty,\n  // the byte code received as a parameter is allocated to `this.deployData`,\n  // and the args after that are used as parameter arguments.\n\n  if (this.method.type === 'constructor' && !this.deployData) {\n    this.deployData = args[0];\n    args = args.slice(1);\n  }\n\n  txObject.arguments = args || [];\n  txObject._method = this.method;\n  txObject._parent = this.parent;\n\n  if (args && this.method.inputs) {\n    if (args.length !== this.method.inputs.length) {\n      if (this.nextMethod) {\n        return this.nextMethod.apply(null, args);\n      }\n\n      throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name);\n    } else if (this.nextMethod) {\n      // If the number of parameters of the function is the same, but the types of parameters are different,\n      // determine whether the function is an appropriate function through encoding operation with the input parameter.\n      // If an encoding error occurs, check by using to the next method.\n      try {\n        txObject.encodeABI(args);\n      } catch (e) {\n        return this.nextMethod.apply(null, args);\n      }\n    }\n  }\n\n  txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts;\n  txObject._wallet = this.parent._wallet || this._wallet;\n\n  if (this.deployData) {\n    txObject._deployData = this.deployData;\n  }\n\n  return txObject;\n};\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\n\n\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n  const processedArgs = {};\n  processedArgs.type = args.shift(); // get the callback\n\n  processedArgs.callback = this._parent._getCallback(args); // get block number to use for call\n\n  if (processedArgs.type === 'call' && args[args.length - 1] !== true && (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))) {\n    processedArgs.defaultBlock = args.pop();\n  } // get the options\n\n\n  processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}; // get the generateRequest argument for batch requests\n\n  processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false;\n  processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options);\n  processedArgs.options.data = this.encodeABI(); // add contract address\n\n  if (!this._deployData && !utils.isAddress(this._parent.options.address)) {\n    throw new Error(\"This contract object doesn't have address set yet, please set an address first.\");\n  }\n\n  if (!this._deployData) {\n    processedArgs.options.to = this._parent.options.address;\n  } // return error, if no \"data\" is specified\n\n\n  if (!processedArgs.options.data) {\n    return utils._fireError(new Error(\"Couldn't find a matching contract method, or the number of parameters is wrong.\"), defer.eventEmitter, defer.reject, processedArgs.callback);\n  }\n\n  return processedArgs;\n};\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\n\nContract.prototype._executeMethod = async function _executeMethod() {\n  const _this = this;\n\n  const args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer);\n\n  var defer = utils.promiEvent(args.type !== 'send');\n  /* eslint-disable-line no-var */\n\n  const klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts;\n  const wallet = _this._parent._wallet || _this._wallet; // Not allow to specify options.gas to 0.\n\n  if (args.options && args.options.gas === 0) {\n    throw errors.notAllowedZeroGas();\n  } // simple return request for batch requests\n\n\n  if (args.generateRequest) {\n    const payload = {\n      params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n      callback: args.callback\n    };\n\n    if (args.type === 'call') {\n      payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock));\n      payload.method = 'klay_call';\n      payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs);\n    } else {\n      payload.method = 'klay_sendTransaction';\n    }\n\n    return payload;\n  }\n\n  switch (args.type) {\n    case 'estimate':\n      const estimateGas = new Method({\n        name: 'estimateGas',\n        call: 'klay_estimateGas',\n        params: 1,\n        inputFormatter: [formatters.inputCallFormatter],\n        outputFormatter: utils.hexToNumber,\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return estimateGas(args.options, args.callback);\n\n    case 'call':\n      // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n      const call = new Method({\n        name: 'call',\n        call: 'klay_call',\n        params: 2,\n        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n\n        // add output formatter for decoding\n        outputFormatter(result) {\n          return _this._parent._decodeMethodReturn(_this._method.outputs, result);\n        },\n\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock\n      }).createFunction();\n      return call(args.options, args.defaultBlock, args.callback);\n\n    case 'sign':\n    case 'signAsFeePayer':\n      const tx = await createTransactionFromArgs(args, this._method, this._deployData, defer);\n\n      if (!wallet) {\n        return utils._fireError(new Error(`Contract sign/signAsFeePayer works with 'caver.wallet'. Set to use'caver.wallet' by calling'contract.setWallet'.`), defer.eventEmitter, defer.reject, args.callback);\n      }\n\n      const signer = args.type === 'signAsFeePayer' ? args.options.feePayer : args.options.from;\n      const signFunction = args.type === 'signAsFeePayer' ? wallet.signAsFeePayer.bind(wallet) : wallet.sign.bind(wallet);\n      const isExisted = await wallet.isExisted(signer);\n\n      if (!isExisted) {\n        throw new Error(`Failed to find ${signer}. Please check that the corresponding account or keyring exists.`);\n      }\n\n      return signFunction(signer, tx).then(signedTx => {\n        return signedTx;\n      });\n\n    case 'send':\n      const transaction = await createTransactionFromArgs(args, this._method, this._deployData, defer); // make sure receipt logs are decoded\n\n      const extraFormatters = {\n        receiptFormatter(receipt) {\n          if (_.isArray(receipt.logs)) {\n            // decode logs\n            const events = _.map(receipt.logs, function (log) {\n              return _this._parent._decodeEventABI.call({\n                name: 'ALLEVENTS',\n                jsonInterface: _this._parent.options.jsonInterface\n              }, log);\n            }); // make log names keys\n\n\n            receipt.events = {};\n            let count = 0;\n            events.forEach(function (ev) {\n              if (ev.event) {\n                // if > 1 of the same event, don't overwrite any existing events\n                if (receipt.events[ev.event]) {\n                  if (Array.isArray(receipt.events[ev.event])) {\n                    receipt.events[ev.event].push(ev);\n                  } else {\n                    receipt.events[ev.event] = [receipt.events[ev.event], ev];\n                  }\n                } else {\n                  receipt.events[ev.event] = ev;\n                }\n              } else {\n                receipt.events[count] = ev;\n                count++;\n              }\n            });\n            delete receipt.logs;\n          }\n\n          return receipt;\n        },\n\n        contractDeployFormatter(receipt) {\n          const newContract = _this._parent.clone(receipt.contractAddress);\n\n          return newContract;\n        }\n\n      }; // This is the logic for testing to check the transaction type used when deploying the smart contract.\n      // You can define and use a custom formatter in this way: `contract.deploy({ ... }).send({ ..., contractDeployFormatter })`\n\n      extraFormatters.contractDeployFormatter = args.options.contractDeployFormatter ? args.options.contractDeployFormatter : extraFormatters.contractDeployFormatter;\n      const sendTransaction = new Method({\n        name: 'sendTransaction',\n        call: 'klay_sendTransaction',\n        params: 1,\n        inputFormatter: [formatters.inputTransactionFormatter],\n        requestManager: _this._parent._requestManager,\n        accounts: klayAccounts,\n        // is klay.accounts (necessary for wallet signing)\n        defaultAccount: _this._parent.defaultAccount,\n        defaultBlock: _this._parent.defaultBlock,\n        extraFormatters\n      }).createFunction();\n\n      if (wallet) {\n        const isExistedInWallet = await wallet.isExisted(args.options.from);\n\n        if (!isExistedInWallet) {\n          if (wallet instanceof KeyringContainer) {\n            return sendTransaction(args.options, args.callback);\n          }\n\n          throw new Error(`Failed to find ${args.options.from}. Please check that the corresponding account or keyring exists.`);\n        }\n\n        const sendRawTransaction = new Method({\n          name: 'sendRawTransaction',\n          call: 'klay_sendRawTransaction',\n          params: 1,\n          requestManager: _this._parent._requestManager,\n          defaultAccount: _this._parent.defaultAccount,\n          defaultBlock: _this._parent.defaultBlock,\n          extraFormatters\n        }).createFunction();\n        return wallet.sign(transaction.from, transaction).then(signedTx => {\n          if (signedTx.feePayer) {\n            return wallet.signAsFeePayer(transaction.feePayer, transaction).then(feePayerSignedTx => {\n              return sendRawTransaction(feePayerSignedTx);\n            });\n          }\n\n          return sendRawTransaction(signedTx);\n        });\n      }\n\n      if (args.options.type === undefined) {\n        if (this._deployData !== undefined) {\n          args.options.type = 'SMART_CONTRACT_DEPLOY';\n        } else {\n          args.options.type = 'SMART_CONTRACT_EXECUTION';\n        }\n      }\n\n      if (args.options.type !== 'SMART_CONTRACT_EXECUTION' && args.options.type !== 'SMART_CONTRACT_DEPLOY') {\n        throw new Error('Unsupported transaction type. Please use SMART_CONTRACT_EXECUTION or SMART_CONTRACT_DEPLOY.');\n      }\n\n      const fromInWallet = sendTransaction.method.accounts.wallet[args.options.from.toLowerCase()];\n\n      if (!fromInWallet || !fromInWallet.privateKey) {\n        args.options.type = 'LEGACY';\n      }\n\n      return sendTransaction(args.options, args.callback);\n  }\n};\n\nfunction createTransactionFromArgs(args, method, deployData, defer) {\n  // Not to affect original data, copy args.options\n  const options = Object.assign({}, args.options);\n  options.value = options.value || 0;\n\n  if (!utils.isAddress(options.from)) {\n    return utils._fireError(new Error('No \"from\" address specified in neither the given options, nor the default options.'), defer.eventEmitter, defer.reject, args.callback);\n  }\n\n  if (_.isBoolean(method.payable) && !method.payable && options.value && options.value > 0) {\n    return utils._fireError(new Error('Can not send value to non-payable contract method or constructor'), defer.eventEmitter, defer.reject, args.callback);\n  } // If the transaction is fee delegated tx,\n  // feeDelegation field must be unconditionally defined with true.\n\n\n  if (options.feeDelegation) {\n    if (args.type === 'signAsFeePayer' || args.type === 'send' && options.feePayer) {\n      if (!utils.isAddress(options.feePayer)) {\n        return utils._fireError(new Error(`Invalid fee payer: ${options.feePayer}`), defer.eventEmitter, defer.reject, args.callback);\n      }\n    }\n  } else if (args.type === 'signAsFeePayer') {\n    return utils._fireError(new Error(`feeDelegation field should be defined as 'true' to sign as a fee payer`), defer.eventEmitter, defer.reject, args.callback);\n  } else if (options.feeRatio !== undefined) {\n    return utils._fireError(new Error(`feeDelegation field should be defined as 'true' to use feeRatio`), defer.eventEmitter, defer.reject, args.callback);\n  } else if (options.feePayer) {\n    return utils._fireError(new Error(`feeDelegation field should be defined as 'true' to use feePayer`), defer.eventEmitter, defer.reject, args.callback);\n  }\n\n  let transaction;\n\n  if (deployData !== undefined) {\n    if (options.feeDelegation) {\n      transaction = options.feeRatio !== undefined ? new FeeDelegatedSmartContractDeployWithRatio(options) : new FeeDelegatedSmartContractDeploy(options);\n    } else {\n      transaction = new SmartContractDeploy(options);\n    }\n  } else if (options.feeDelegation) {\n    transaction = options.feeRatio !== undefined ? new FeeDelegatedSmartContractExecutionWithRatio(options) : new FeeDelegatedSmartContractExecution(options);\n  } else {\n    transaction = new SmartContractExecution(options);\n  }\n\n  return transaction;\n}\n\nmodule.exports = Contract;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-contract/src/index.js"],"names":["_","require","core","Method","utils","Subscription","subscription","SmartContractDeploy","SmartContractExecution","FeeDelegatedSmartContractDeploy","FeeDelegatedSmartContractExecution","FeeDelegatedSmartContractDeployWithRatio","FeeDelegatedSmartContractExecutionWithRatio","KeyringContainer","formatters","errors","abi","Contract","jsonInterface","address","options","_this","args","Array","prototype","slice","call","arguments","Error","packageInit","constructor","currentProvider","clearSubscriptions","_requestManager","isArray","lastArg","length","isObject","extend","_getOrSetDefaultOptions","Object","defineProperty","get","set","value","_address","toChecksumAddress","inputAddressFormatter","enumerable","methods","events","_jsonInterface","map","method","func","funcName","name","_jsonInterfaceMethodToString","type","signature","encodeFunctionSignature","_createTxObject","bind","parent","cascadeFunc","nextMethod","encodeEventSignature","event","_on","find","mth","constructorFunc","allEvents","defaultAccount","defaultBlock","val","isValidBlockNumberCandidate","_from","_feePayer","undefined","_feeDelegation","fr","isNumber","isHex","hexToNumber","_feeRatio","numberToHex","isValidNSHSN","invalidGasPrice","_gasPrice","invalidGasLimit","_gas","isHexStrict","invalidData","_data","create","setProvider","provider","accounts","_klayAccounts","setKeyrings","keyrings","_keyrings","setWallet","wallet","_wallet","addAccounts","_getCallback","getCallback","isFunction","pop","_checkListener","getOrSetDefaultOptions","gasPrice","String","from","data","feePayer","feeRatio","feeDelegation","gas","gasLimit","_encodeEventABI","filter","result","f","forEach","inputBlockNumberFormatter","topics","anonymous","push","indexedTopics","inputs","i","indexed","v","encodeParameter","concat","toLowerCase","_decodeEventABI","outputLogFormatter","intf","argTopics","returnValues","decodeLog","__length__","raw","_encodeMethodABI","methodSignature","_method","paramsABI","_parent","json","replace","inputLength","encodeParameters","_deployData","returnValue","_decodeMethodReturn","outputs","decodeParameters","deploy","callback","error","sendOptions","byteCode","params","send","functionName","callObject","sign","signAsFeePayer","_generateEventOptions","isString","isAddress","clone","contractAddress","cloned","once","fromBlock","err","res","sub","unsubscribe","subOptions","apply","inputFormatter","inputLogFormatter","outputFormatter","subscriptionHandler","output","emit","requestManager","subscribe","getPastEvents","getPastLogs","setRequestManager","buildCall","txObject","_executeMethod","request","encodeABI","estimateGas","deployData","InvalidNumberOfParams","e","_processExecuteArguments","defer","processedArgs","shift","isFinite","generateRequest","to","_fireError","eventEmitter","reject","promiEvent","klayAccounts","notAllowedZeroGas","payload","inputCallFormatter","inputDefaultBlockNumberFormatter","format","createFunction","tx","createTransactionFromArgs","signer","signFunction","isExisted","then","signedTx","transaction","extraFormatters","receiptFormatter","receipt","logs","log","count","ev","contractDeployFormatter","newContract","sendTransaction","inputTransactionFormatter","isExistedInWallet","sendRawTransaction","feePayerSignedTx","fromInWallet","privateKey","assign","isBoolean","payable","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-contract/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file contract.js\n *\n * To initialize a contract use:\n *\n *  let Contract = require('web3-eth-contract');\n *  Contract.setProvider('ws://localhost:8546');\n *  let contract = new Contract(abi, address, ...);\n *\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst core = require('../../caver-core')\nconst Method = require('../../caver-core-method')\nconst utils = require('../../caver-utils')\nconst Subscription = require('../../caver-core-subscriptions').subscription\nconst SmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/smartContractDeploy')\nconst SmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/smartContractExecution')\nconst FeeDelegatedSmartContractDeploy = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/feeDelegatedSmartContractDeploy')\nconst FeeDelegatedSmartContractExecution = require('../../caver-transaction/src/transactionTypes/smartContractExecution/feeDelegatedSmartContractExecution')\nconst FeeDelegatedSmartContractDeployWithRatio = require('../../caver-transaction/src/transactionTypes/smartContractDeploy/feeDelegatedSmartContractDeployWithRatio')\nconst FeeDelegatedSmartContractExecutionWithRatio = require('../../caver-transaction/src/transactionTypes/smartContractExecution/feeDelegatedSmartContractExecutionWithRatio')\nconst KeyringContainer = require('../../caver-wallet')\nconst { formatters } = require('../../caver-core-helpers')\nconst { errors } = require('../../caver-core-helpers')\nconst abi = require('../../caver-abi')\n\n/**\n * Should be called to create new contract instance\n *\n * @method Contract\n * @constructor\n * @param {Array} jsonInterface\n * @param {String} address\n * @param {Object} options\n */\n\n/**\n * let myContract = new cav.klay.Contract([...], '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe', {\n *   from: '0x1234567890123456789012345678901234567891', // default from address\n *   gasPrice: '20000000000', // default gas price in wei, 20 gwei in this case\n *   data: '',(bytecode, when contract deploy)\n *   gas: 200000, (gas limit)\n * });\n */\nconst Contract = function Contract(jsonInterface, address, options) {\n    const _this = this\n    const args = Array.prototype.slice.call(arguments)\n\n    if (!(this instanceof Contract)) {\n        throw new Error('Please use the \"new\" keyword to instantiate a caver.contract() or caver.klay.Contract() object!')\n    }\n\n    // sets _requestmanager\n    core.packageInit(this, [this.constructor.currentProvider])\n\n    this.clearSubscriptions = this._requestManager.clearSubscriptions\n\n    if (!jsonInterface || !Array.isArray(jsonInterface)) {\n        throw new Error('You must provide the json interface of the contract when instantiating a contract object.')\n    }\n\n    // create the options object\n    this.options = {}\n\n    const lastArg = args[args.length - 1]\n    if (_.isObject(lastArg) && !_.isArray(lastArg)) {\n        options = lastArg\n        this.options = _.extend(this.options, this._getOrSetDefaultOptions(options))\n\n        if (_.isObject(address)) {\n            address = null\n        }\n    }\n\n    Object.defineProperty(this, 'defaultSendOptions', {\n        get() {\n            return _this.options\n        },\n    })\n\n    // set address\n    Object.defineProperty(this.options, 'address', {\n        set(value) {\n            if (value) {\n                _this._address = utils.toChecksumAddress(formatters.inputAddressFormatter(value))\n            }\n        },\n        get() {\n            return _this._address\n        },\n        enumerable: true,\n    })\n\n    // add method and event signatures, when the jsonInterface gets set\n    Object.defineProperty(this.options, 'jsonInterface', {\n        set(value) {\n            _this.methods = {}\n            _this.events = {}\n\n            _this._jsonInterface = value.map(function(method) {\n                let func\n                let funcName\n                if (method.name) {\n                    funcName = utils._jsonInterfaceMethodToString(method)\n                }\n\n                // function\n                if (method.type === 'function') {\n                    method.signature = abi.encodeFunctionSignature(funcName)\n                    func = _this._createTxObject.bind({\n                        method,\n                        parent: _this,\n                    })\n\n                    // add method only if not one already exists\n                    if (!_this.methods[method.name]) {\n                        _this.methods[method.name] = func\n                    } else {\n                        const cascadeFunc = _this._createTxObject.bind({\n                            method,\n                            parent: _this,\n                            nextMethod: _this.methods[method.name],\n                        })\n                        _this.methods[method.name] = cascadeFunc\n                    }\n\n                    // definitely add the method based on its signature\n                    _this.methods[method.signature] = func\n\n                    // add method by name\n                    _this.methods[funcName] = func\n\n                    // event\n                } else if (method.type === 'event') {\n                    method.signature = abi.encodeEventSignature(funcName)\n                    const event = _this._on.bind(_this, method.signature)\n\n                    // add method only if not already exists\n                    if (!_this.events[method.name] || _this.events[method.name].name === 'bound ') {\n                        _this.events[method.name] = event\n                    }\n\n                    // definitely add the method based on its signature\n                    _this.events[method.signature] = event\n\n                    // add event by name\n                    _this.events[funcName] = event\n                }\n\n                // Make transaction object for constructor and add to the `this.methods`\n                const constructor = _.find(_this._jsonInterface, function(mth) {\n                    return mth.type === 'constructor'\n                }) || { type: 'constructor' }\n                constructor.signature = 'constructor'\n                const constructorFunc = _this._createTxObject.bind({ method: constructor, parent: _this })\n                _this.methods[constructor.signature] = constructorFunc\n\n                return method\n            })\n\n            // add allEvents\n            _this.events.allEvents = _this._on.bind(_this, 'allevents')\n\n            return _this._jsonInterface\n        },\n        get() {\n            return _this._jsonInterface\n        },\n        enumerable: true,\n    })\n\n    // get default account from the Class\n    let { defaultAccount } = this.constructor\n    let defaultBlock = this.constructor.defaultBlock || 'latest'\n\n    Object.defineProperty(this, 'defaultAccount', {\n        get() {\n            return defaultAccount\n        },\n        set(val) {\n            if (val) {\n                defaultAccount = utils.toChecksumAddress(formatters.inputAddressFormatter(val))\n            }\n\n            return val\n        },\n        enumerable: true,\n    })\n    Object.defineProperty(this, 'defaultBlock', {\n        get() {\n            return defaultBlock\n        },\n        set(val) {\n            if (!utils.isValidBlockNumberCandidate(val)) {\n                throw new Error('Invalid default block number.')\n            }\n            defaultBlock = val\n\n            return val\n        },\n        enumerable: true,\n    })\n\n    // Check for setting options property.\n    Object.defineProperty(this.options, 'from', {\n        set(value) {\n            if (value) {\n                _this._from = utils.toChecksumAddress(formatters.inputAddressFormatter(value))\n            }\n        },\n        get() {\n            return _this._from\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'feePayer', {\n        set(value) {\n            if (value) {\n                _this._feePayer = utils.toChecksumAddress(formatters.inputAddressFormatter(value))\n            }\n        },\n        get() {\n            return _this._feePayer\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'feeDelegation', {\n        set(value) {\n            if (value !== undefined) {\n                _this._feeDelegation = value\n            }\n        },\n        get() {\n            return _this._feeDelegation\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'feeRatio', {\n        set(fr) {\n            if (fr !== undefined) {\n                if (!_.isNumber(fr) && !utils.isHex(fr))\n                    throw new Error(`Invalid type fo feeRatio: feeRatio should be number type or hex number string.`)\n                if (utils.hexToNumber(fr) <= 0 || utils.hexToNumber(fr) >= 100)\n                    throw new Error(`Invalid feeRatio: feeRatio is out of range. [1, 99]`)\n\n                _this._feeRatio = utils.numberToHex(fr)\n            }\n        },\n        get() {\n            return _this._feeRatio\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'gasPrice', {\n        set(value) {\n            if (value) {\n                if (!utils.isValidNSHSN(value)) {\n                    throw errors.invalidGasPrice()\n                }\n                _this._gasPrice = value\n            }\n        },\n        get() {\n            return _this._gasPrice\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'gas', {\n        set(value) {\n            if (value) {\n                if (!utils.isValidNSHSN(value)) throw errors.invalidGasLimit()\n                _this._gas = value\n            }\n        },\n        get() {\n            return _this._gas\n        },\n        enumerable: true,\n    })\n\n    Object.defineProperty(this.options, 'data', {\n        set(value) {\n            if (value) {\n                if (!utils.isHexStrict(value)) throw errors.invalidData()\n                _this._data = value\n            }\n        },\n        get() {\n            return _this._data\n        },\n        enumerable: true,\n    })\n\n    // properties\n    this.methods = {}\n    this.events = {}\n\n    this._address = null\n    this._jsonInterface = []\n\n    // set getter/setter properties\n    this.options.address = address\n    this.options.jsonInterface = jsonInterface\n}\n\n/**\n * Creates an instance of Contract.\n *\n * @method create\n * @constructor\n * @param {Array} jsonInterface The Contract Application Binary Interface (ABI).\n * @param {string} [address] The contract address to call.\n * @param {object} [options] The options of the contract.\n */\nContract.create = function(jsonInterface, address, options) {\n    return new Contract(jsonInterface, address, options)\n}\n\nContract.setProvider = function(provider, accounts) {\n    core.packageInit(this, [provider])\n\n    this._klayAccounts = accounts\n}\n\n/**\n * Set _keyrings in contract instance.\n *\n * @param {KeyringContainer} keyrings\n */\nContract.prototype.setKeyrings = function(keyrings) {\n    if (!(keyrings instanceof KeyringContainer)) throw new Error(`keyrings should be an instance of 'KeyringContainer'`)\n    this._keyrings = keyrings\n}\n\n/**\n * Set _wallet in contract instance.\n * When _wallet exists, contract will use _wallet instead of _klayAccounts\n *\n * @param {IWallet} wallet\n */\nContract.prototype.setWallet = function(wallet) {\n    this._wallet = wallet\n}\n\nContract.prototype.addAccounts = function(accounts) {\n    this._klayAccounts = accounts\n}\n\n/**\n * Get the callback and modiufy the array if necessary\n *\n * @method _getCallback\n * @param {Array} args\n * @return {Function} the callback\n */\nContract.prototype._getCallback = function getCallback(args) {\n    if (args && _.isFunction(args[args.length - 1])) {\n        return args.pop() // modify the args array!\n    }\n}\n\n/**\n * Checks that no listener with name \"newListener\" or \"removeListener\" is added.\n *\n * @method _checkListener\n * @param {String} type\n * @param {String} event\n * @return {Object} the contract instance\n */\n/**\n * this._checkListener('newListener', subOptions.event.name);\n * this._checkListener('removeListener', subOptions.event.name);\n */\nContract.prototype._checkListener = function(type, event) {\n    if (event === type) {\n        throw new Error(`The event \"${type}\" is a reserved event name, you can't use it.`)\n    }\n}\n\n/**\n * Use default values, if options are not available\n *\n * @method _getOrSetDefaultOptions\n * @param {Object} options the options gived by the user\n * @return {Object} the options with gaps filled by defaults\n */\nContract.prototype._getOrSetDefaultOptions = function getOrSetDefaultOptions(options) {\n    const gasPrice = options.gasPrice ? String(options.gasPrice) : null\n    const from = options.from ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.from)) : null\n\n    options.data = options.data || this.options.data\n\n    options.from = from || this.options.from\n    options.gasPrice = gasPrice || this.options.gasPrice\n\n    const feePayer = options.feePayer ? utils.toChecksumAddress(formatters.inputAddressFormatter(options.feePayer)) : null\n    const feeRatio = options.feeRatio ? options.feeRatio : null\n    const feeDelegation = options.feeDelegation !== undefined ? options.feeDelegation : null\n    options.feePayer = feePayer || this.options.feePayer\n    options.feeRatio = feeRatio || this.options.feeRatio\n    options.feeDelegation = feeDelegation || this.options.feeDelegation\n\n    // If options.gas isn't set manually, use options.gasLimit, this.options.gas instead.\n    if (typeof options.gas === 'undefined') {\n        options.gas = options.gasLimit || this.options.gas\n    }\n\n    // TODO replace with only gasLimit?\n    delete options.gasLimit\n\n    return options\n}\n\n/**\n * Should be used to encode indexed params and options to one final object\n *\n * @method _encodeEventABI\n * @param {Object} event\n * @param {Object} options\n * @return {Object} everything combined together and encoded\n */\n\n/**\n * _encodeEventABI\n * 1. options\n * options = {\n *   filter: {...},\n *   topics: [...],\n * }\n *   cf. topics\n *   - This allows you to manually set the topics for the event filter.\n *   - If given the filter property and event signature, (topic[0]) will not\n *   - be set automatically.\n *\n * 2. event\n * {\n *   anonymous: Bool,\n *   signature:\n *   name: String,\n *   inputs: [...],\n * }\n * cf) signature\n * - The signatureâ€™s hash of the event is one of the topics,\n * - unless you used the anonymous specifier to declare the event.\n * - This would mean filtering for anonymous, specific events by name is not possible.\n * - keccak256(\"burned(address,uint)\") = 0x0970ce1235167a71...\n */\nContract.prototype._encodeEventABI = function(event, options) {\n    options = options || {}\n    const filter = options.filter || {}\n    const result = {}\n\n    ;['fromBlock', 'toBlock']\n        .filter(function(f) {\n            return options[f] !== undefined\n        })\n        .forEach(function(f) {\n            result[f] = formatters.inputBlockNumberFormatter(options[f])\n        })\n\n    // use given topics\n    if (_.isArray(options.topics)) {\n        result.topics = options.topics\n        // create topics based on filter\n    } else {\n        result.topics = []\n\n        // add event signature\n        if (event && !event.anonymous && event.name !== 'ALLEVENTS') {\n            result.topics.push(event.signature)\n        }\n\n        // add event topics (indexed arguments)\n        if (event.name !== 'ALLEVENTS') {\n            const indexedTopics = event.inputs\n                .filter(i => i.indexed === true)\n                .map(i => {\n                    const value = filter[i.name]\n                    if (!value) return null\n\n                    // TODO: https://github.com/ethereum/web3.js/issues/344\n\n                    if (_.isArray(value)) {\n                        return value.map(v => abi.encodeParameter(i.type, v))\n                    }\n                    return abi.encodeParameter(i.type, value)\n                })\n\n            result.topics = result.topics.concat(indexedTopics)\n        }\n        if (!result.topics.length) delete result.topics\n    }\n    if (this.options.address) {\n        result.address = this.options.address.toLowerCase()\n    }\n\n    return result\n}\n\n/**\n * Should be used to decode indexed params and options\n *\n * @method _decodeEventABI\n * @param {Object} data\n * @return {Object} result object with decoded indexed && not indexed params\n */\n\nContract.prototype._decodeEventABI = function(data) {\n    let event = this\n\n    data.data = data.data || ''\n    data.topics = data.topics || []\n    const result = formatters.outputLogFormatter(data)\n\n    // if allEvents get the right event\n    if (event.name === 'ALLEVENTS') {\n        event = event.jsonInterface.find(function(intf) {\n            return intf.signature === data.topics[0]\n        }) || { anonymous: true }\n    }\n\n    // create empty inputs if none are present (e.g. anonymous events on allEvents)\n    event.inputs = event.inputs || []\n\n    const argTopics = event.anonymous ? data.topics : data.topics.slice(1)\n\n    result.returnValues = abi.decodeLog(event.inputs, data.data, argTopics)\n    delete result.returnValues.__length__\n\n    // add name\n    result.event = event.name\n\n    // add signature\n    result.signature = event.anonymous || !data.topics[0] ? null : data.topics[0]\n\n    // move the data and topics to \"raw\"\n    result.raw = {\n        data: result.data,\n        topics: result.topics,\n    }\n    delete result.data\n    delete result.topics\n\n    return result\n}\n\n/**\n * Encodes an ABI for a method, including signature or the method.\n * Or when constructor encodes only the constructor parameters.\n *\n * @method _encodeMethodABI\n * @param {Mixed} args the arguments to encode\n * @param {String} the encoded ABI\n */\nContract.prototype._encodeMethodABI = function _encodeMethodABI() {\n    const methodSignature = this._method.signature\n    const args = this.arguments || []\n\n    let signature = false\n    const paramsABI =\n        this._parent.options.jsonInterface\n            .filter(function(json) {\n                return (\n                    (methodSignature === 'constructor' && json.type === methodSignature) ||\n                    ((json.signature === methodSignature ||\n                        json.signature === methodSignature.replace('0x', '') ||\n                        json.name === methodSignature) &&\n                        json.type === 'function')\n                )\n            })\n            .map(function(json) {\n                const inputLength = _.isArray(json.inputs) ? json.inputs.length : 0\n\n                if (inputLength !== args.length) {\n                    throw new Error(\n                        `The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`\n                    )\n                }\n                if (json.type === 'function') {\n                    signature = json.signature\n                }\n                return _.isArray(json.inputs) ? json.inputs : []\n            })\n            .map(function(inputs) {\n                return abi.encodeParameters(inputs, args).replace('0x', '')\n            })[0] || ''\n\n    // return constructor\n    if (methodSignature === 'constructor') {\n        if (!this._deployData) {\n            throw new Error('The contract has no contract data option set. This is necessary to append the constructor parameters.')\n        }\n\n        return this._deployData + paramsABI\n\n        // return method\n    }\n    const returnValue = signature ? signature + paramsABI : paramsABI\n\n    if (!returnValue) {\n        throw new Error(`Couldn't find a matching contract method named \"${this._method.name}\".`)\n    } else {\n        return returnValue\n    }\n}\n\n/**\n * Decode method return values\n *\n * @method _decodeMethodReturn\n * @param {Array} outputs\n * @param {String} returnValues\n * @return {Object} decoded output return values\n */\nContract.prototype._decodeMethodReturn = function(outputs, returnValues) {\n    if (!returnValues) {\n        return null\n    }\n\n    returnValues = returnValues.length >= 2 ? returnValues.slice(2) : returnValues\n    const result = abi.decodeParameters(outputs, returnValues)\n\n    if (result.__length__ === 1) {\n        return result[0]\n    }\n    delete result.__length__\n    return result\n}\n\n/**\n * Deploys the contract to the Klaytn.\n * After a successful deployment, the promise will be resolved with a new contract instance.\n *\n * @method deploy\n * @param {Object} options An object in which data, which is the byte code of the smart contract to be deployed, and arguments, which are parameters to be passed to the constructor of the smart contract, are defined.\n * @param {Function} [callback] The callback function.\n * @return {object} An object in which arguments and functions for contract deployment are defined\n */\n/**\n * Deploys the contract to the Klaytn.\n * After a successful deployment, the promise will be resolved with a new contract instance.\n *\n * @method deploy\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} byteCode The byte code of the contract.\n * @param {...*} parameters The parameters to be passed to the constructor of the smart contract.\n * @return {object} Promise will be resolved with a new contract instance. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.deploy = function(options, callback) {\n    const args = Array.prototype.slice.call(arguments)\n\n    // This if condition will handle original usage\n    // contract.deploy({ data, arguments })\n    // contract.deploy({ data, arguments }, callback)\n    if (args.length === 1 || (args.length === 2 && _.isFunction(args[args.length - 1]))) {\n        options = options || {}\n\n        options.arguments = options.arguments || []\n        options = this._getOrSetDefaultOptions(options)\n\n        // return error, if no \"data\" is specified\n        if (!options.data) {\n            const error = new Error('No \"data\" specified in neither the given options, nor the default options.')\n            if (callback) callback(error)\n            throw error\n        }\n\n        return this.methods.constructor(options.data, ...options.arguments)\n    }\n\n    // contract.deploy({from, gas, ...}, byteCode, parameters)\n    const sendOptions = args[0]\n    const byteCode = args[1]\n    const params = args.slice(2)\n\n    return this.methods.constructor(byteCode, ...params).send(sendOptions)\n}\n\n/**\n * Sends a SmartContractExecution transaction to execute the function of the contract deployed in the Klaytn.\n * After a successful deployment, the promise will be resolved with a transaction receipt.\n *\n * @method send\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute.\n * @param {...*} parameters The parameters to be passed to the smart contract function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.send = function() {\n    const args = Array.prototype.slice.call(arguments)\n\n    // contract.send({from, gas, ...}, 'functionName', parameters)\n    const sendOptions = args[0]\n    const functionName = args[1]\n    const params = args.slice(2)\n\n    return this.methods[functionName](...params).send(sendOptions)\n}\n\n/**\n * Calls a \"constant\" method and execute its smart contract method in the Klaytn Virtual Machine without sending any transaction.\n *\n * @method call\n * @param {object} [callObject] The options used for calling.\n * @param {string} functionName The function name to execute.\n * @param {...*} parameters The parameters to be passed to the smart contract function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.call = function() {\n    let args = Array.prototype.slice.call(arguments)\n\n    // contract.call('functionName', parameters)\n    // contract.call({from, gas, ...}, 'functionName', parameters)\n    let callObject = {}\n    if (_.isObject(args[0])) {\n        callObject = args[0]\n        args = args.slice(1)\n    }\n    const functionName = args[0]\n    const params = args.slice(1)\n\n    return this.methods[functionName](...params).call(callObject)\n}\n\n/**\n * Signs a transaction as a sender to deploy or execute the contract.\n * After signing, the promise will be resolved with the signed transaction.\n *\n * If you want to use fee delegation, `feeDelegation` should be defined as `true` in the `sendOptions` parameter.\n * Also if you want to use partial fee delegation, you can define `feeRatio` in the `sendOptions` parameter.\n *\n * @method sign\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute. If you want to sign for deployig, please send 'constructor' here.\n * @param {...*} parameters The parameters to be passed to the smart contract constructor or function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.sign = function() {\n    const args = Array.prototype.slice.call(arguments)\n\n    // contract.sign({from, gas, ...}, 'constructor', arguments)\n    // contract.sign({from, gas, ...}, 'functionName', arguments)\n    // contract.sign({from, gas, feeDelegation: true ...}, 'constructor', arguments)\n    // contract.sign({from, gas, feeDelegation: true, feeRatio: 30, ...}, 'functionName', arguments)\n    const sendOptions = args[0]\n    const functionName = args[1]\n    const params = args.slice(2)\n\n    return this.methods[functionName](...params).sign(sendOptions)\n}\n\n/**\n * Signs a transaction as a fee payer to deploy or execute the contract.\n * After signing, the promise will be resolved with the signed transaction.\n *\n * To sign as a fee payer, `feeDelegation` and `feePayer` should be defined in the `sendOptions` parameter.\n * `feeDelegation` field should be true.\n * Also if you want to use partial fee delegation, you can define `feeRatio` in the `sendOptions` parameter.\n *\n * @method sign\n * @param {object} sendOptions An object holding parameters that are required for sending a transaction.\n * @param {string} functionName The function name to execute. If you want to sign for deployig, please send 'constructor' here.\n * @param {...*} parameters The parameters to be passed to the smart contract constructor or function.\n * @return {object} Promise will be resolved with a transaction receipt. EventEmitter possible events are \"error\", \"transactionHash\" and \"receipt\"\n */\nContract.prototype.signAsFeePayer = function() {\n    const args = Array.prototype.slice.call(arguments)\n\n    // contract.signAsFeePayer({from, gas, feeDelegation: true ...}, 'constructor', arguments)\n    // contract.signAsFeePayer({from, gas, feeDelegation: true, feeRatio: 30, ...}, 'functionName', arguments)\n    const sendOptions = args[0]\n    const functionName = args[1]\n    const params = args.slice(2)\n\n    return this.methods[functionName](...params).signAsFeePayer(sendOptions)\n}\n\n/**\n * Gets the event signature and outputformatters\n *\n * @method _generateEventOptions\n * @param {Object} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event options object\n */\nContract.prototype._generateEventOptions = function() {\n    const args = Array.prototype.slice.call(arguments)\n\n    // get the callback\n    const callback = this._getCallback(args)\n\n    // get the options\n    const options = _.isObject(args[args.length - 1]) ? args.pop() : {}\n\n    let event = _.isString(args[0]) ? args[0] : 'allevents'\n    event =\n        event.toLowerCase() === 'allevents'\n            ? {\n                  name: 'ALLEVENTS',\n                  jsonInterface: this.options.jsonInterface,\n              }\n            : this.options.jsonInterface.find(function(json) {\n                  return json.type === 'event' && (json.name === event || json.signature === `0x${event.replace('0x', '')}`)\n              })\n\n    if (!event) {\n        throw new Error(`Event \"${event.name}\" doesn't exist in this contract.`)\n    }\n\n    if (!utils.isAddress(this.options.address)) {\n        throw new Error(\"This contract object doesn't have address set yet, please set an address first.\")\n    }\n\n    return {\n        params: this._encodeEventABI(event, options),\n        event,\n        callback,\n    }\n}\n\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n *\n * @method clone\n * @return {Object} the event subscription\n */\nContract.prototype.clone = function(contractAddress = this.options.address) {\n    const cloned = new this.constructor(this.options.jsonInterface, contractAddress, this.options)\n    cloned.setWallet(this._wallet)\n    return cloned\n}\n\n/**\n * Adds event listeners and creates a subscription, and remove it once its fired.\n * (Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.)\n *\n *\n * @method once\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n *\n * myContract.once('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0\n  }, function(error, event){ console.log(event); });\n\n  // event output example\n  > {\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  }\n */\nContract.prototype.once = function(event, options, callback) {\n    const args = Array.prototype.slice.call(arguments)\n\n    // get the callback\n    callback = this._getCallback(args)\n\n    if (!callback) {\n        throw new Error('Once requires a callback as the second parameter.')\n    }\n\n    // don't allow fromBlock\n    if (options) {\n        delete options.fromBlock\n    }\n\n    // don't return as once shouldn't provide \"on\"\n    this._on(event, options, function(err, res, sub) {\n        sub.unsubscribe()\n        if (_.isFunction(callback)) {\n            callback(err, res, sub)\n        }\n    })\n\n    return undefined\n}\n\n/**\n * Adds event listeners and creates a subscription.\n *\n * @method _on\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the event subscription\n */\nContract.prototype._on = function() {\n    const subOptions = this._generateEventOptions.apply(this, arguments)\n\n    // prevent the event \"newListener\" and \"removeListener\" from being overwritten\n    this._checkListener('newListener', subOptions.event.name)\n    this._checkListener('removeListener', subOptions.event.name)\n\n    // TODO check if listener already exists? and reuse subscription if options are the same.\n\n    const subscription = new Subscription({\n        subscription: {\n            params: 1,\n            inputFormatter: [formatters.inputLogFormatter],\n            outputFormatter: this._decodeEventABI.bind(subOptions.event),\n            // DUBLICATE, also in caver-klay\n            subscriptionHandler(output) {\n                this.emit('data', output)\n\n                if (_.isFunction(this.callback)) {\n                    this.callback(null, output, this)\n                }\n            },\n        },\n        type: 'klay',\n        requestManager: this._requestManager,\n    })\n    subscription.subscribe('logs', subOptions.params, subOptions.callback || function() {})\n\n    return subscription\n}\n\n/**\n * Get past events from contracts\n *\n * @method getPastEvents\n * @param {String} event\n * @param {Object} options\n * @param {Function} callback\n * @return {Object} the promievent\n */\n\n/**\n * myContract.getPastEvents('MyEvent', {\n      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23\n      fromBlock: 0,\n      toBlock: 'latest'\n  }, function(error, events){ console.log(events); })\n  .then(function(events){\n      console.log(events) // same results as the optional callback above\n  });\n\n  > [{\n      returnValues: {\n          myIndexedParam: 20,\n          myOtherIndexedParam: '0x123456789...',\n          myNonIndexParam: 'My String'\n      },\n      raw: {\n          data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n          topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']\n      },\n      event: 'MyEvent',\n      signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      logIndex: 0,\n      transactionIndex: 0,\n      transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',\n      blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',\n      blockNumber: 1234,\n      address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'\n  },{\n      ...\n  }]\n */\nContract.prototype.getPastEvents = function() {\n    const subOptions = this._generateEventOptions.apply(this, arguments)\n\n    let getPastLogs = new Method({\n        name: 'getPastLogs',\n        call: 'klay_getLogs',\n        params: 1,\n        inputFormatter: [formatters.inputLogFormatter],\n        outputFormatter: this._decodeEventABI.bind(subOptions.event),\n    })\n    getPastLogs.setRequestManager(this._requestManager)\n    const call = getPastLogs.buildCall()\n\n    getPastLogs = null\n\n    return call(subOptions.params, subOptions.callback)\n}\n\n/**\n * returns the an object with call, send, estimate functions\n *\n * @method _createTxObject\n * @returns {Object} an object with functions to call the methods\n */\n\nContract.prototype._createTxObject = function _createTxObject() {\n    let args = Array.prototype.slice.call(arguments)\n    const txObject = {}\n\n    if (this.method.type === 'function') {\n        txObject.call = this.parent._executeMethod.bind(txObject, 'call')\n        txObject.call.request = this.parent._executeMethod.bind(txObject, 'call', true) // to make batch requests\n    }\n\n    txObject.sign = this.parent._executeMethod.bind(txObject, 'sign')\n    txObject.signAsFeePayer = this.parent._executeMethod.bind(txObject, 'signAsFeePayer')\n\n    txObject.send = this.parent._executeMethod.bind(txObject, 'send')\n    txObject.send.request = this.parent._executeMethod.bind(txObject, 'send', true) // to make batch requests\n\n    txObject.encodeABI = this.parent._encodeMethodABI.bind(txObject)\n    txObject.estimateGas = this.parent._executeMethod.bind(txObject, 'estimate')\n\n    // When deploying a smart contract, if a parameter is passed by directly accessing the tx object,\n    // the byte code is transferred as the first parameter.\n    // (i.e. `contract.methods['constructor'](byteCode, arguments...).send({from, ...})`)\n    // To handle such a case, when `method.type` is a \"constructor\" and `this.deployData` is empty,\n    // the byte code received as a parameter is allocated to `this.deployData`,\n    // and the args after that are used as parameter arguments.\n    if (this.method.type === 'constructor' && !this.deployData) {\n        this.deployData = args[0]\n        args = args.slice(1)\n    }\n\n    txObject.arguments = args || []\n    txObject._method = this.method\n    txObject._parent = this.parent\n\n    if (args && this.method.inputs) {\n        if (args.length !== this.method.inputs.length) {\n            if (this.nextMethod) {\n                return this.nextMethod.apply(null, args)\n            }\n            throw errors.InvalidNumberOfParams(args.length, this.method.inputs.length, this.method.name)\n        } else if (this.nextMethod) {\n            // If the number of parameters of the function is the same, but the types of parameters are different,\n            // determine whether the function is an appropriate function through encoding operation with the input parameter.\n            // If an encoding error occurs, check by using to the next method.\n            try {\n                txObject.encodeABI(args)\n            } catch (e) {\n                return this.nextMethod.apply(null, args)\n            }\n        }\n    }\n\n    txObject._klayAccounts = this.parent.constructor._klayAccounts || this._klayAccounts\n    txObject._wallet = this.parent._wallet || this._wallet\n\n    if (this.deployData) {\n        txObject._deployData = this.deployData\n    }\n\n    return txObject\n}\n\n/**\n * Generates the options for the execute call\n *\n * @method _processExecuteArguments\n * @param {Array} args\n * @param {Promise} defer\n */\nContract.prototype._processExecuteArguments = function _processExecuteArguments(args, defer) {\n    const processedArgs = {}\n\n    processedArgs.type = args.shift()\n\n    // get the callback\n    processedArgs.callback = this._parent._getCallback(args)\n\n    // get block number to use for call\n    if (\n        processedArgs.type === 'call' &&\n        args[args.length - 1] !== true &&\n        (_.isString(args[args.length - 1]) || isFinite(args[args.length - 1]))\n    ) {\n        processedArgs.defaultBlock = args.pop()\n    }\n\n    // get the options\n    processedArgs.options = _.isObject(args[args.length - 1]) ? args.pop() : {}\n\n    // get the generateRequest argument for batch requests\n    processedArgs.generateRequest = args[args.length - 1] === true ? args.pop() : false\n\n    processedArgs.options = this._parent._getOrSetDefaultOptions(processedArgs.options)\n    processedArgs.options.data = this.encodeABI()\n\n    // add contract address\n    if (!this._deployData && !utils.isAddress(this._parent.options.address)) {\n        throw new Error(\"This contract object doesn't have address set yet, please set an address first.\")\n    }\n\n    if (!this._deployData) {\n        processedArgs.options.to = this._parent.options.address\n    }\n\n    // return error, if no \"data\" is specified\n    if (!processedArgs.options.data) {\n        return utils._fireError(\n            new Error(\"Couldn't find a matching contract method, or the number of parameters is wrong.\"),\n            defer.eventEmitter,\n            defer.reject,\n            processedArgs.callback\n        )\n    }\n\n    return processedArgs\n}\n\n/**\n * Executes a call, transact or estimateGas on a contract function\n *\n * @method _executeMethod\n * @param {String} type the type this execute function should execute\n * @param {Boolean} makeRequest if true, it simply returns the request parameters, rather than executing it\n */\n\nContract.prototype._executeMethod = async function _executeMethod() {\n    const _this = this\n    const args = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), defer)\n    var defer = utils.promiEvent(args.type !== 'send') /* eslint-disable-line no-var */\n    const klayAccounts = _this.constructor._klayAccounts || _this._klayAccounts\n    const wallet = _this._parent._wallet || _this._wallet\n\n    // Not allow to specify options.gas to 0.\n    if (args.options && args.options.gas === 0) {\n        throw errors.notAllowedZeroGas()\n    }\n\n    // simple return request for batch requests\n    if (args.generateRequest) {\n        const payload = {\n            params: [formatters.inputCallFormatter.call(this._parent, args.options)],\n            callback: args.callback,\n        }\n\n        if (args.type === 'call') {\n            payload.params.push(formatters.inputDefaultBlockNumberFormatter.call(this._parent, args.defaultBlock))\n            payload.method = 'klay_call'\n            payload.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs)\n        } else {\n            payload.method = 'klay_sendTransaction'\n        }\n\n        return payload\n    }\n    switch (args.type) {\n        case 'estimate':\n            const estimateGas = new Method({\n                name: 'estimateGas',\n                call: 'klay_estimateGas',\n                params: 1,\n                inputFormatter: [formatters.inputCallFormatter],\n                outputFormatter: utils.hexToNumber,\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n            }).createFunction()\n\n            return estimateGas(args.options, args.callback)\n\n        case 'call':\n            // TODO check errors: missing \"from\" should give error on deploy and send, call ?\n\n            const call = new Method({\n                name: 'call',\n                call: 'klay_call',\n                params: 2,\n                inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter],\n                // add output formatter for decoding\n                outputFormatter(result) {\n                    return _this._parent._decodeMethodReturn(_this._method.outputs, result)\n                },\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n            }).createFunction()\n\n            return call(args.options, args.defaultBlock, args.callback)\n\n        case 'sign':\n        case 'signAsFeePayer':\n            const tx = await createTransactionFromArgs(args, this._method, this._deployData, defer)\n\n            if (!wallet) {\n                return utils._fireError(\n                    new Error(\n                        `Contract sign/signAsFeePayer works with 'caver.wallet'. Set to use'caver.wallet' by calling'contract.setWallet'.`\n                    ),\n                    defer.eventEmitter,\n                    defer.reject,\n                    args.callback\n                )\n            }\n\n            const signer = args.type === 'signAsFeePayer' ? args.options.feePayer : args.options.from\n            const signFunction = args.type === 'signAsFeePayer' ? wallet.signAsFeePayer.bind(wallet) : wallet.sign.bind(wallet)\n            const isExisted = await wallet.isExisted(signer)\n\n            if (!isExisted) {\n                throw new Error(`Failed to find ${signer}. Please check that the corresponding account or keyring exists.`)\n            }\n\n            return signFunction(signer, tx).then(signedTx => {\n                return signedTx\n            })\n\n        case 'send':\n            const transaction = await createTransactionFromArgs(args, this._method, this._deployData, defer)\n            // make sure receipt logs are decoded\n            const extraFormatters = {\n                receiptFormatter(receipt) {\n                    if (_.isArray(receipt.logs)) {\n                        // decode logs\n                        const events = _.map(receipt.logs, function(log) {\n                            return _this._parent._decodeEventABI.call(\n                                {\n                                    name: 'ALLEVENTS',\n                                    jsonInterface: _this._parent.options.jsonInterface,\n                                },\n                                log\n                            )\n                        })\n\n                        // make log names keys\n                        receipt.events = {}\n                        let count = 0\n                        events.forEach(function(ev) {\n                            if (ev.event) {\n                                // if > 1 of the same event, don't overwrite any existing events\n                                if (receipt.events[ev.event]) {\n                                    if (Array.isArray(receipt.events[ev.event])) {\n                                        receipt.events[ev.event].push(ev)\n                                    } else {\n                                        receipt.events[ev.event] = [receipt.events[ev.event], ev]\n                                    }\n                                } else {\n                                    receipt.events[ev.event] = ev\n                                }\n                            } else {\n                                receipt.events[count] = ev\n                                count++\n                            }\n                        })\n\n                        delete receipt.logs\n                    }\n                    return receipt\n                },\n                contractDeployFormatter(receipt) {\n                    const newContract = _this._parent.clone(receipt.contractAddress)\n                    return newContract\n                },\n            }\n\n            // This is the logic for testing to check the transaction type used when deploying the smart contract.\n            // You can define and use a custom formatter in this way: `contract.deploy({ ... }).send({ ..., contractDeployFormatter })`\n            extraFormatters.contractDeployFormatter = args.options.contractDeployFormatter\n                ? args.options.contractDeployFormatter\n                : extraFormatters.contractDeployFormatter\n\n            const sendTransaction = new Method({\n                name: 'sendTransaction',\n                call: 'klay_sendTransaction',\n                params: 1,\n                inputFormatter: [formatters.inputTransactionFormatter],\n                requestManager: _this._parent._requestManager,\n                accounts: klayAccounts, // is klay.accounts (necessary for wallet signing)\n                defaultAccount: _this._parent.defaultAccount,\n                defaultBlock: _this._parent.defaultBlock,\n                extraFormatters,\n            }).createFunction()\n\n            if (wallet) {\n                const isExistedInWallet = await wallet.isExisted(args.options.from)\n                if (!isExistedInWallet) {\n                    if (wallet instanceof KeyringContainer) {\n                        return sendTransaction(args.options, args.callback)\n                    }\n                    throw new Error(`Failed to find ${args.options.from}. Please check that the corresponding account or keyring exists.`)\n                }\n\n                const sendRawTransaction = new Method({\n                    name: 'sendRawTransaction',\n                    call: 'klay_sendRawTransaction',\n                    params: 1,\n                    requestManager: _this._parent._requestManager,\n                    defaultAccount: _this._parent.defaultAccount,\n                    defaultBlock: _this._parent.defaultBlock,\n                    extraFormatters,\n                }).createFunction()\n\n                return wallet.sign(transaction.from, transaction).then(signedTx => {\n                    if (signedTx.feePayer) {\n                        return wallet.signAsFeePayer(transaction.feePayer, transaction).then(feePayerSignedTx => {\n                            return sendRawTransaction(feePayerSignedTx)\n                        })\n                    }\n                    return sendRawTransaction(signedTx)\n                })\n            }\n\n            if (args.options.type === undefined) {\n                if (this._deployData !== undefined) {\n                    args.options.type = 'SMART_CONTRACT_DEPLOY'\n                } else {\n                    args.options.type = 'SMART_CONTRACT_EXECUTION'\n                }\n            }\n\n            if (args.options.type !== 'SMART_CONTRACT_EXECUTION' && args.options.type !== 'SMART_CONTRACT_DEPLOY') {\n                throw new Error('Unsupported transaction type. Please use SMART_CONTRACT_EXECUTION or SMART_CONTRACT_DEPLOY.')\n            }\n\n            const fromInWallet = sendTransaction.method.accounts.wallet[args.options.from.toLowerCase()]\n            if (!fromInWallet || !fromInWallet.privateKey) {\n                args.options.type = 'LEGACY'\n            }\n\n            return sendTransaction(args.options, args.callback)\n    }\n}\n\nfunction createTransactionFromArgs(args, method, deployData, defer) {\n    // Not to affect original data, copy args.options\n    const options = Object.assign({}, args.options)\n\n    options.value = options.value || 0\n\n    if (!utils.isAddress(options.from)) {\n        return utils._fireError(\n            new Error('No \"from\" address specified in neither the given options, nor the default options.'),\n            defer.eventEmitter,\n            defer.reject,\n            args.callback\n        )\n    }\n\n    if (_.isBoolean(method.payable) && !method.payable && options.value && options.value > 0) {\n        return utils._fireError(\n            new Error('Can not send value to non-payable contract method or constructor'),\n            defer.eventEmitter,\n            defer.reject,\n            args.callback\n        )\n    }\n\n    // If the transaction is fee delegated tx,\n    // feeDelegation field must be unconditionally defined with true.\n    if (options.feeDelegation) {\n        if (args.type === 'signAsFeePayer' || (args.type === 'send' && options.feePayer)) {\n            if (!utils.isAddress(options.feePayer)) {\n                return utils._fireError(\n                    new Error(`Invalid fee payer: ${options.feePayer}`),\n                    defer.eventEmitter,\n                    defer.reject,\n                    args.callback\n                )\n            }\n        }\n    } else if (args.type === 'signAsFeePayer') {\n        return utils._fireError(\n            new Error(`feeDelegation field should be defined as 'true' to sign as a fee payer`),\n            defer.eventEmitter,\n            defer.reject,\n            args.callback\n        )\n    } else if (options.feeRatio !== undefined) {\n        return utils._fireError(\n            new Error(`feeDelegation field should be defined as 'true' to use feeRatio`),\n            defer.eventEmitter,\n            defer.reject,\n            args.callback\n        )\n    } else if (options.feePayer) {\n        return utils._fireError(\n            new Error(`feeDelegation field should be defined as 'true' to use feePayer`),\n            defer.eventEmitter,\n            defer.reject,\n            args.callback\n        )\n    }\n\n    let transaction\n    if (deployData !== undefined) {\n        if (options.feeDelegation) {\n            transaction =\n                options.feeRatio !== undefined\n                    ? new FeeDelegatedSmartContractDeployWithRatio(options)\n                    : new FeeDelegatedSmartContractDeploy(options)\n        } else {\n            transaction = new SmartContractDeploy(options)\n        }\n    } else if (options.feeDelegation) {\n        transaction =\n            options.feeRatio !== undefined\n                ? new FeeDelegatedSmartContractExecutionWithRatio(options)\n                : new FeeDelegatedSmartContractExecution(options)\n    } else {\n        transaction = new SmartContractExecution(options)\n    }\n\n    return transaction\n}\n\nmodule.exports = Contract\n"]},"metadata":{},"sourceType":"script"}