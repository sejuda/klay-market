{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst EventEmitter = require('eventemitter3');\n\nconst errors = require('../../caver-core-helpers').errors;\n\nfunction Subscription(options) {\n  EventEmitter.call(this);\n  this.id = null;\n  this.callback = null;\n  this.arguments = null;\n  this._reconnectIntervalId = null;\n  this.options = {\n    subscription: options.subscription,\n    type: options.type,\n    requestManager: options.requestManager\n  };\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Subscription\n  }\n});\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\n\nSubscription.prototype._extractCallback = function (args) {\n  if (_.isFunction(args[args.length - 1])) {\n    return args.pop(); // modify the args array!\n  }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\n\n\nSubscription.prototype._validateArgs = function (args) {\n  let subscription = this.options.subscription;\n\n  if (!subscription) {\n    subscription = {};\n  }\n\n  if (!subscription.params) {\n    subscription.params = 0;\n  }\n\n  if (args.length !== subscription.params) {\n    throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0]);\n  }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\n\n\nSubscription.prototype._formatInput = function (args) {\n  const subscription = this.options.subscription;\n\n  if (!subscription) {\n    return args;\n  }\n\n  if (!subscription.inputFormatter) {\n    return args;\n  }\n\n  const formattedArgs = subscription.inputFormatter.map(function (formatter, index) {\n    return formatter ? formatter(args[index]) : args[index];\n  });\n  return formattedArgs;\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\n\n\nSubscription.prototype._formatOutput = function (result) {\n  const subscription = this.options.subscription;\n  return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result;\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n/**\n * _toPayload\n *\n */\n\n\nSubscription.prototype._toPayload = function (args) {\n  let params = [];\n  this.callback = this._extractCallback(args);\n\n  if (!this.subscriptionMethod) {\n    this.subscriptionMethod = args.shift();\n\n    if (this.options.subscription.subscriptionName) {\n      this.subscriptionMethod = this.options.subscription.subscriptionName;\n    }\n  }\n\n  if (!this.arguments) {\n    this.arguments = this._formatInput(args);\n\n    this._validateArgs(this.arguments);\n\n    args = []; // make empty after validation\n  } // re-add subscriptionName\n\n\n  params.push(this.subscriptionMethod);\n  params = params.concat(this.arguments);\n\n  if (args.length) {\n    throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.');\n  }\n\n  return {\n    method: `${this.options.type}_subscribe`,\n    params: params\n  };\n};\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\n\n\nSubscription.prototype.unsubscribe = function (callback) {\n  this.options.requestManager.removeSubscription(this.id, callback);\n  this.id = null;\n  this.removeAllListeners();\n  clearInterval(this._reconnectIntervalId);\n};\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\n\n\nSubscription.prototype.subscribe = function () {\n  const _this = this;\n\n  const args = Array.prototype.slice.call(arguments);\n\n  const payload = this._toPayload(args);\n\n  if (!payload) {\n    return this;\n  }\n\n  if (!this.options.requestManager.provider) {\n    const err1 = new Error('No provider set.');\n    this.callback(err1, null, this);\n    this.emit('error', err1);\n    return this;\n  }\n\n  if (!this.options.requestManager.provider.on) {\n    const err2 = new Error(`The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`);\n    this.callback(err2, null, this);\n    this.emit('error', err2);\n    return this;\n  }\n\n  if (this.id) {\n    this.unsubscribe();\n  }\n\n  this.options.params = payload.params[1]; // get past logs, if fromBlock is available\n\n  if (payload.params[0] === 'logs' && _.isObject(payload.params[1]) && Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') && isFinite(payload.params[1].fromBlock)) {\n    // send the subscription request\n    this.options.requestManager.send({\n      method: 'klay_getLogs',\n      params: [payload.params[1]]\n    }, function (err, logs) {\n      if (!err) {\n        logs.forEach(function (log) {\n          const output = _this._formatOutput(log);\n\n          _this.callback(null, output, _this);\n\n          _this.emit('data', output);\n        }); // TODO subscribe here? after the past logs?\n      } else {\n        _this.callback(err, null, _this);\n\n        _this.emit('error', err);\n      }\n    });\n  } // create subscription\n  // TODO move to separate function? so that past logs can go first?\n\n\n  if (typeof payload.params[1] === 'object') {\n    delete payload.params[1].fromBlock;\n  }\n\n  this.options.requestManager.send(payload, function (err, result) {\n    if (!err && result) {\n      _this.id = result;\n\n      _this.emit('connected', result); // call callback on notifications\n\n\n      _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function (error, ret) {\n        if (!error) {\n          if (!_.isArray(ret)) {\n            ret = [ret];\n          }\n\n          ret.forEach(function (resultItem) {\n            const output = _this._formatOutput(resultItem);\n\n            if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n              return _this.options.subscription.subscriptionHandler.call(_this, output);\n            }\n\n            _this.emit('data', output); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n            if (_.isFunction(_this.callback)) {\n              _this.callback(null, output, _this);\n            }\n          });\n        } else {\n          // unsubscribe, but keep listeners\n          _this.options.requestManager.removeSubscription(_this.id); // re-subscribe, if connection fails\n\n\n          if (_this.options.requestManager.provider.once) {\n            _this._reconnectIntervalId = setInterval(function () {\n              // TODO check if that makes sense!\n              if (_this.options.requestManager.provider.reconnect) {\n                _this.options.requestManager.provider.reconnect();\n              }\n            }, 500);\n\n            _this.options.requestManager.provider.once('connect', function () {\n              clearInterval(_this._reconnectIntervalId);\n\n              _this.subscribe(_this.callback);\n            });\n          }\n\n          _this.emit('error', error); // call the callback, last so that unsubscribe there won't affect the emit above\n\n\n          if (_.isFunction(_this.callback)) {\n            _this.callback(error, null, _this);\n          }\n        }\n      });\n    } else if (_.isFunction(_this.callback)) {\n      _this.callback(err, null, _this);\n\n      _this.emit('error', err);\n    } else {\n      // emit the event even if no callback was provided\n      _this.emit('error', err);\n    }\n  }); // return an object to cancel the subscription\n\n  return this;\n};\n\nmodule.exports = Subscription;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-core-subscriptions/src/subscription.js"],"names":["_","require","EventEmitter","errors","Subscription","options","call","id","callback","arguments","_reconnectIntervalId","subscription","type","requestManager","prototype","Object","create","constructor","value","_extractCallback","args","isFunction","length","pop","_validateArgs","params","InvalidNumberOfParams","_formatInput","inputFormatter","formattedArgs","map","formatter","index","_formatOutput","result","outputFormatter","_toPayload","subscriptionMethod","shift","subscriptionName","push","concat","Error","method","unsubscribe","removeSubscription","removeAllListeners","clearInterval","subscribe","_this","Array","slice","payload","provider","err1","emit","on","err2","name","isObject","hasOwnProperty","isFinite","fromBlock","send","err","logs","forEach","log","output","addSubscription","error","ret","isArray","resultItem","subscriptionHandler","once","setInterval","reconnect","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-subscriptions/src/subscription.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file subscription.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst EventEmitter = require('eventemitter3')\nconst errors = require('../../caver-core-helpers').errors\n\nfunction Subscription(options) {\n    EventEmitter.call(this)\n\n    this.id = null\n    this.callback = null\n    this.arguments = null\n    this._reconnectIntervalId = null\n\n    this.options = {\n        subscription: options.subscription,\n        type: options.type,\n        requestManager: options.requestManager,\n    }\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype, {\n    constructor: { value: Subscription },\n})\n\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nSubscription.prototype._extractCallback = function(args) {\n    if (_.isFunction(args[args.length - 1])) {\n        return args.pop() // modify the args array!\n    }\n}\n\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nSubscription.prototype._validateArgs = function(args) {\n    let subscription = this.options.subscription\n\n    if (!subscription) {\n        subscription = {}\n    }\n\n    if (!subscription.params) {\n        subscription.params = 0\n    }\n\n    if (args.length !== subscription.params) {\n        throw errors.InvalidNumberOfParams(args.length, subscription.params + 1, args[0])\n    }\n}\n\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nSubscription.prototype._formatInput = function(args) {\n    const subscription = this.options.subscription\n\n    if (!subscription) {\n        return args\n    }\n\n    if (!subscription.inputFormatter) {\n        return args\n    }\n\n    const formattedArgs = subscription.inputFormatter.map(function(formatter, index) {\n        return formatter ? formatter(args[index]) : args[index]\n    })\n\n    return formattedArgs\n}\n\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nSubscription.prototype._formatOutput = function(result) {\n    const subscription = this.options.subscription\n\n    return subscription && subscription.outputFormatter && result ? subscription.outputFormatter(result) : result\n}\n\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\n\n/**\n * _toPayload\n *\n */\nSubscription.prototype._toPayload = function(args) {\n    let params = []\n    this.callback = this._extractCallback(args)\n\n    if (!this.subscriptionMethod) {\n        this.subscriptionMethod = args.shift()\n\n        if (this.options.subscription.subscriptionName) {\n            this.subscriptionMethod = this.options.subscription.subscriptionName\n        }\n    }\n\n    if (!this.arguments) {\n        this.arguments = this._formatInput(args)\n        this._validateArgs(this.arguments)\n        args = [] // make empty after validation\n    }\n\n    // re-add subscriptionName\n    params.push(this.subscriptionMethod)\n    params = params.concat(this.arguments)\n\n    if (args.length) {\n        throw new Error('Only a callback is allowed as parameter on an already instantiated subscription.')\n    }\n\n    return {\n        method: `${this.options.type}_subscribe`,\n        params: params,\n    }\n}\n\n/**\n * Unsubscribes and clears callbacks\n *\n * @method unsubscribe\n * @return {Object}\n */\nSubscription.prototype.unsubscribe = function(callback) {\n    this.options.requestManager.removeSubscription(this.id, callback)\n    this.id = null\n    this.removeAllListeners()\n    clearInterval(this._reconnectIntervalId)\n}\n\n/**\n * Subscribes and watches for changes\n *\n * @method subscribe\n * @param {String} subscription the subscription\n * @param {Object} options the options object with address topics and fromBlock\n * @return {Object}\n */\nSubscription.prototype.subscribe = function() {\n    const _this = this\n    const args = Array.prototype.slice.call(arguments)\n    const payload = this._toPayload(args)\n\n    if (!payload) {\n        return this\n    }\n\n    if (!this.options.requestManager.provider) {\n        const err1 = new Error('No provider set.')\n        this.callback(err1, null, this)\n        this.emit('error', err1)\n        return this\n    }\n\n    if (!this.options.requestManager.provider.on) {\n        const err2 = new Error(\n            `The current provider doesn't support subscriptions: ${this.options.requestManager.provider.constructor.name}`\n        )\n        this.callback(err2, null, this)\n        this.emit('error', err2)\n        return this\n    }\n\n    if (this.id) {\n        this.unsubscribe()\n    }\n\n    this.options.params = payload.params[1]\n\n    // get past logs, if fromBlock is available\n    if (\n        payload.params[0] === 'logs' &&\n        _.isObject(payload.params[1]) &&\n        Object.prototype.hasOwnProperty.call(payload.params[1], 'fromBlock') &&\n        isFinite(payload.params[1].fromBlock)\n    ) {\n        // send the subscription request\n        this.options.requestManager.send(\n            {\n                method: 'klay_getLogs',\n                params: [payload.params[1]],\n            },\n            function(err, logs) {\n                if (!err) {\n                    logs.forEach(function(log) {\n                        const output = _this._formatOutput(log)\n                        _this.callback(null, output, _this)\n                        _this.emit('data', output)\n                    })\n\n                    // TODO subscribe here? after the past logs?\n                } else {\n                    _this.callback(err, null, _this)\n                    _this.emit('error', err)\n                }\n            }\n        )\n    }\n\n    // create subscription\n    // TODO move to separate function? so that past logs can go first?\n\n    if (typeof payload.params[1] === 'object') {\n        delete payload.params[1].fromBlock\n    }\n\n    this.options.requestManager.send(payload, function(err, result) {\n        if (!err && result) {\n            _this.id = result\n            _this.emit('connected', result)\n\n            // call callback on notifications\n            _this.options.requestManager.addSubscription(_this.id, payload.params[0], _this.options.type, function(error, ret) {\n                if (!error) {\n                    if (!_.isArray(ret)) {\n                        ret = [ret]\n                    }\n\n                    ret.forEach(function(resultItem) {\n                        const output = _this._formatOutput(resultItem)\n\n                        if (_.isFunction(_this.options.subscription.subscriptionHandler)) {\n                            return _this.options.subscription.subscriptionHandler.call(_this, output)\n                        }\n                        _this.emit('data', output)\n\n                        // call the callback, last so that unsubscribe there won't affect the emit above\n                        if (_.isFunction(_this.callback)) {\n                            _this.callback(null, output, _this)\n                        }\n                    })\n                } else {\n                    // unsubscribe, but keep listeners\n                    _this.options.requestManager.removeSubscription(_this.id)\n\n                    // re-subscribe, if connection fails\n                    if (_this.options.requestManager.provider.once) {\n                        _this._reconnectIntervalId = setInterval(function() {\n                            // TODO check if that makes sense!\n                            if (_this.options.requestManager.provider.reconnect) {\n                                _this.options.requestManager.provider.reconnect()\n                            }\n                        }, 500)\n\n                        _this.options.requestManager.provider.once('connect', function() {\n                            clearInterval(_this._reconnectIntervalId)\n                            _this.subscribe(_this.callback)\n                        })\n                    }\n                    _this.emit('error', error)\n\n                    // call the callback, last so that unsubscribe there won't affect the emit above\n                    if (_.isFunction(_this.callback)) {\n                        _this.callback(error, null, _this)\n                    }\n                }\n            })\n        } else if (_.isFunction(_this.callback)) {\n            _this.callback(err, null, _this)\n            _this.emit('error', err)\n        } else {\n            // emit the event even if no callback was provided\n            _this.emit('error', err)\n        }\n    })\n    // return an object to cancel the subscription\n    return this\n}\n\nmodule.exports = Subscription\n"]},"metadata":{},"sourceType":"script"}