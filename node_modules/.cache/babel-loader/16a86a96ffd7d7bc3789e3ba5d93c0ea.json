{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-requestmanager/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst errors = require('../../caver-core-helpers').errors;\n\nconst middleware = require('../../caver-middleware');\n\nconst Jsonrpc = require('./jsonrpc.js');\n\nconst BatchManager = require('./batch.js');\n\nconst RequestManager = function RequestManager(provider, net) {\n  this.provider = null;\n  this.providers = RequestManager.providers;\n  this.setProvider(provider, net);\n  this.subscriptions = {};\n};\n\nRequestManager.providers = {\n  WebsocketProvider: require('../caver-providers-ws'),\n  HttpProvider: require('../caver-providers-http'),\n  IpcProvider: require('../caver-providers-ipc')\n};\n/**\n * Should be used to set provider of request manager\n *\n * @method setProvider\n * @param {Object} p\n */\n\nRequestManager.prototype.setProvider = function (p, net) {\n  const _this = this;\n\n  if (p && typeof p === 'string' && this.providers) {\n    // HTTP\n    if (/^http(s)?:\\/\\//i.test(p)) {\n      p = new this.providers.HttpProvider(p); // WS\n    } else if (/^ws(s)?:\\/\\//i.test(p)) {\n      p = new this.providers.WebsocketProvider(p); // IPC\n    } else if (p && typeof net === 'object' && typeof net.connect === 'function') {\n      p = new this.providers.IpcProvider(p, net);\n    } else if (p) {\n      throw new Error(`Can't autodetect provider for \"${p}\"`);\n    }\n  }\n\n  if (this.provider) {\n    this.clearSubscriptions();\n  }\n\n  this.provider = p || null; // listen to incoming notifications\n\n  if (this.provider && this.provider.on) {\n    this.provider.on('data', function requestManagerNotification(result, deprecatedResult) {\n      result = result || deprecatedResult; // this is for possible old providers, which may had the error first handler\n      // check for result.method, to prevent old providers errors to pass as result\n\n      if (result.method && _this.subscriptions[result.params.subscription] && _this.subscriptions[result.params.subscription].callback) {\n        _this.subscriptions[result.params.subscription].callback(null, result.params.result);\n      }\n    }); // TODO add error, end, timeout, connect??\n    // this.provider.on('error', function requestManagerNotification(result){\n    //     Object.keys(_this.subscriptions).forEach(function(id){\n    //         if(_this.subscriptions[id].callback)\n    //             _this.subscriptions[id].callback(err);\n    //     });\n    // }\n  }\n\n  return this;\n};\n/**\n * Should be used to asynchronously send request\n *\n * @method sendAsync\n * @param {Object} data\n * @param {Function} callback\n */\n\n\nRequestManager.prototype.send = function (data, callback) {\n  callback = callback || function () {};\n\n  if (!this.provider) {\n    return callback(errors.InvalidProvider());\n  }\n\n  const payload = Jsonrpc.toPayload(data.method, data.params);\n  const isMiddlewareExist = middleware.getMiddlewares().length !== 0;\n  if (!isMiddlewareExist) return sendRPC(this.provider)(payload); // Attach outbound middleware\n\n  middleware.applyMiddleware(payload, 'outbound', sendRPC(this.provider));\n\n  function sendRPC(provider) {\n    return function (p) {\n      provider[provider.sendAsync ? 'sendAsync' : 'send'](p, function (err, result) {\n        // Attach inbound middleware\n        if (isMiddlewareExist) middleware.applyMiddleware(p, 'inbound');\n        /**\n         * result = json rpc response object\n         * {\n         *  jsonrpc: '2.0'\n         *  result: ...,\n         *  id: ...,\n         *  error: ...,\n         * }\n         *\n         * Reference: https://www.jsonrpc.org/specification\n         */\n\n        if (result && result.id && p.id !== result.id) {\n          return callback(new Error(`Wrong response id \"${result.id}\" (expected: \"${p.id}\") in ${JSON.stringify(p)}`));\n        }\n\n        if (err) {\n          return callback(err);\n        }\n\n        if (result && result.error) {\n          return callback(errors.ErrorResponse(result));\n        }\n\n        if (!Jsonrpc.isValidResponse(result)) {\n          return callback(errors.InvalidResponse(result));\n        }\n\n        callback(null, result.result);\n      });\n    };\n  }\n};\n/**\n * Should be called to asynchronously send batch request\n *\n * @method sendBatch\n * @param {Array} batch data\n * @param {Function} callback\n */\n\n\nRequestManager.prototype.sendBatch = function (data, callback) {\n  if (!this.provider) {\n    return callback(errors.InvalidProvider());\n  }\n\n  const payload = Jsonrpc.toBatchPayload(data);\n  this.provider[this.provider.sendAsync ? 'sendAsync' : 'send'](payload, function (err, results) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (!_.isArray(results)) {\n      return callback(errors.InvalidResponse(results));\n    }\n\n    callback(null, results);\n  });\n};\n/**\n * Waits for notifications\n *\n * @method addSubscription\n * @param {String} id           the subscription id\n * @param {String} name         the subscription name\n * @param {String} type         the subscription namespace (eth, personal, etc)\n * @param {Function} callback   the callback to call for incoming notifications\n */\n\n\nRequestManager.prototype.addSubscription = function (id, name, type, callback) {\n  if (this.provider.on) {\n    this.subscriptions[id] = {\n      callback: callback,\n      type: type,\n      name: name\n    };\n  } else {\n    throw new Error(`The provider doesn't support subscriptions: ${this.provider.constructor.name}`);\n  }\n};\n/**\n * Waits for notifications\n *\n * @method removeSubscription\n * @param {String} id           the subscription id\n * @param {Function} callback   fired once the subscription is removed\n */\n\n\nRequestManager.prototype.removeSubscription = function (id, callback) {\n  const _this = this;\n\n  if (this.subscriptions[id]) {\n    this.send({\n      method: `${this.subscriptions[id].type}_unsubscribe`,\n      params: [id]\n    }, callback); // remove subscription\n\n    delete _this.subscriptions[id];\n  }\n};\n/**\n * Should be called to reset the subscriptions\n *\n * @method reset\n */\n\n\nRequestManager.prototype.clearSubscriptions = function (keepIsSyncing) {\n  const _this = this; // uninstall all subscriptions\n\n\n  Object.keys(this.subscriptions).forEach(function (id) {\n    if (!keepIsSyncing || _this.subscriptions[id].name !== 'syncing') {\n      _this.removeSubscription(id);\n    }\n  }); //  reset notification callbacks etc.\n\n  if (this.provider.reset) {\n    this.provider.reset();\n  }\n};\n\nmodule.exports = {\n  Manager: RequestManager,\n  BatchManager: BatchManager\n};","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-core-requestmanager/src/index.js"],"names":["_","require","errors","middleware","Jsonrpc","BatchManager","RequestManager","provider","net","providers","setProvider","subscriptions","WebsocketProvider","HttpProvider","IpcProvider","prototype","p","_this","test","connect","Error","clearSubscriptions","on","requestManagerNotification","result","deprecatedResult","method","params","subscription","callback","send","data","InvalidProvider","payload","toPayload","isMiddlewareExist","getMiddlewares","length","sendRPC","applyMiddleware","sendAsync","err","id","JSON","stringify","error","ErrorResponse","isValidResponse","InvalidResponse","sendBatch","toBatchPayload","results","isArray","addSubscription","name","type","constructor","removeSubscription","keepIsSyncing","Object","keys","forEach","reset","module","exports","Manager"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-core-requestmanager/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst errors = require('../../caver-core-helpers').errors\nconst middleware = require('../../caver-middleware')\n\nconst Jsonrpc = require('./jsonrpc.js')\n\nconst BatchManager = require('./batch.js')\n\nconst RequestManager = function RequestManager(provider, net) {\n    this.provider = null\n    this.providers = RequestManager.providers\n\n    this.setProvider(provider, net)\n    this.subscriptions = {}\n}\n\nRequestManager.providers = {\n    WebsocketProvider: require('../caver-providers-ws'),\n    HttpProvider: require('../caver-providers-http'),\n    IpcProvider: require('../caver-providers-ipc'),\n}\n\n/**\n * Should be used to set provider of request manager\n *\n * @method setProvider\n * @param {Object} p\n */\nRequestManager.prototype.setProvider = function(p, net) {\n    const _this = this\n\n    if (p && typeof p === 'string' && this.providers) {\n        // HTTP\n        if (/^http(s)?:\\/\\//i.test(p)) {\n            p = new this.providers.HttpProvider(p)\n\n            // WS\n        } else if (/^ws(s)?:\\/\\//i.test(p)) {\n            p = new this.providers.WebsocketProvider(p)\n\n            // IPC\n        } else if (p && typeof net === 'object' && typeof net.connect === 'function') {\n            p = new this.providers.IpcProvider(p, net)\n        } else if (p) {\n            throw new Error(`Can't autodetect provider for \"${p}\"`)\n        }\n    }\n\n    if (this.provider) {\n        this.clearSubscriptions()\n    }\n\n    this.provider = p || null\n\n    // listen to incoming notifications\n    if (this.provider && this.provider.on) {\n        this.provider.on('data', function requestManagerNotification(result, deprecatedResult) {\n            result = result || deprecatedResult // this is for possible old providers, which may had the error first handler\n\n            // check for result.method, to prevent old providers errors to pass as result\n            if (\n                result.method &&\n                _this.subscriptions[result.params.subscription] &&\n                _this.subscriptions[result.params.subscription].callback\n            ) {\n                _this.subscriptions[result.params.subscription].callback(null, result.params.result)\n            }\n        })\n        // TODO add error, end, timeout, connect??\n        // this.provider.on('error', function requestManagerNotification(result){\n        //     Object.keys(_this.subscriptions).forEach(function(id){\n        //         if(_this.subscriptions[id].callback)\n        //             _this.subscriptions[id].callback(err);\n        //     });\n        // }\n    }\n\n    return this\n}\n\n/**\n * Should be used to asynchronously send request\n *\n * @method sendAsync\n * @param {Object} data\n * @param {Function} callback\n */\nRequestManager.prototype.send = function(data, callback) {\n    callback = callback || function() {}\n\n    if (!this.provider) {\n        return callback(errors.InvalidProvider())\n    }\n\n    const payload = Jsonrpc.toPayload(data.method, data.params)\n\n    const isMiddlewareExist = middleware.getMiddlewares().length !== 0\n\n    if (!isMiddlewareExist) return sendRPC(this.provider)(payload)\n\n    // Attach outbound middleware\n    middleware.applyMiddleware(payload, 'outbound', sendRPC(this.provider))\n\n    function sendRPC(provider) {\n        return function(p) {\n            provider[provider.sendAsync ? 'sendAsync' : 'send'](p, function(err, result) {\n                // Attach inbound middleware\n                if (isMiddlewareExist) middleware.applyMiddleware(p, 'inbound')\n                /**\n                 * result = json rpc response object\n                 * {\n                 *  jsonrpc: '2.0'\n                 *  result: ...,\n                 *  id: ...,\n                 *  error: ...,\n                 * }\n                 *\n                 * Reference: https://www.jsonrpc.org/specification\n                 */\n                if (result && result.id && p.id !== result.id) {\n                    return callback(new Error(`Wrong response id \"${result.id}\" (expected: \"${p.id}\") in ${JSON.stringify(p)}`))\n                }\n\n                if (err) {\n                    return callback(err)\n                }\n\n                if (result && result.error) {\n                    return callback(errors.ErrorResponse(result))\n                }\n\n                if (!Jsonrpc.isValidResponse(result)) {\n                    return callback(errors.InvalidResponse(result))\n                }\n\n                callback(null, result.result)\n            })\n        }\n    }\n}\n\n/**\n * Should be called to asynchronously send batch request\n *\n * @method sendBatch\n * @param {Array} batch data\n * @param {Function} callback\n */\nRequestManager.prototype.sendBatch = function(data, callback) {\n    if (!this.provider) {\n        return callback(errors.InvalidProvider())\n    }\n\n    const payload = Jsonrpc.toBatchPayload(data)\n    this.provider[this.provider.sendAsync ? 'sendAsync' : 'send'](payload, function(err, results) {\n        if (err) {\n            return callback(err)\n        }\n\n        if (!_.isArray(results)) {\n            return callback(errors.InvalidResponse(results))\n        }\n\n        callback(null, results)\n    })\n}\n\n/**\n * Waits for notifications\n *\n * @method addSubscription\n * @param {String} id           the subscription id\n * @param {String} name         the subscription name\n * @param {String} type         the subscription namespace (eth, personal, etc)\n * @param {Function} callback   the callback to call for incoming notifications\n */\nRequestManager.prototype.addSubscription = function(id, name, type, callback) {\n    if (this.provider.on) {\n        this.subscriptions[id] = {\n            callback: callback,\n            type: type,\n            name: name,\n        }\n    } else {\n        throw new Error(`The provider doesn't support subscriptions: ${this.provider.constructor.name}`)\n    }\n}\n\n/**\n * Waits for notifications\n *\n * @method removeSubscription\n * @param {String} id           the subscription id\n * @param {Function} callback   fired once the subscription is removed\n */\nRequestManager.prototype.removeSubscription = function(id, callback) {\n    const _this = this\n\n    if (this.subscriptions[id]) {\n        this.send(\n            {\n                method: `${this.subscriptions[id].type}_unsubscribe`,\n                params: [id],\n            },\n            callback\n        )\n\n        // remove subscription\n        delete _this.subscriptions[id]\n    }\n}\n\n/**\n * Should be called to reset the subscriptions\n *\n * @method reset\n */\nRequestManager.prototype.clearSubscriptions = function(keepIsSyncing) {\n    const _this = this\n\n    // uninstall all subscriptions\n    Object.keys(this.subscriptions).forEach(function(id) {\n        if (!keepIsSyncing || _this.subscriptions[id].name !== 'syncing') {\n            _this.removeSubscription(id)\n        }\n    })\n\n    //  reset notification callbacks etc.\n    if (this.provider.reset) {\n        this.provider.reset()\n    }\n}\n\nmodule.exports = {\n    Manager: RequestManager,\n    BatchManager: BatchManager,\n}\n"]},"metadata":{},"sourceType":"script"}