{"ast":null,"code":"'use strict';\n/* eslint-env browser */\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst toAsyncIterable = require('../lib/file-data-to-async-iterable');\n/*\nTransform one of:\n\nBuffer|ArrayBuffer|TypedArray\nBlob|File\n{ path, content: Buffer }\n{ path, content: Blob }\n{ path, content: Iterable<Buffer> }\n{ path, content: AsyncIterable<Buffer> }\n{ path, content: PullStream<Buffer> }\nIterable<Number>\nIterable<{ path, content: Buffer }>\nIterable<{ path, content: Blob }>\nIterable<{ path, content: Iterable<Number> }>\nIterable<{ path, content: AsyncIterable<Buffer> }>\nIterable<{ path, content: PullStream<Buffer> }>\nAsyncIterable<Buffer>\nAsyncIterable<{ path, content: Buffer }>\nAsyncIterable<{ path, content: Blob }>\nAsyncIterable<{ path, content: Iterable<Buffer> }>\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\nAsyncIterable<{ path, content: PullStream<Buffer> }>\nPullStream<Buffer>\n\nInto:\n\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n*/\n\n\nmodule.exports = function normalizeInput(input) {\n  // Buffer|ArrayBuffer|TypedArray\n  if (Buffer.isBuffer(input) || ArrayBuffer.isView(input) || input instanceof ArrayBuffer) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  } // Blob|File\n\n\n  if (typeof Blob !== 'undefined' && input instanceof Blob) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  } // Iterable<Number>\n  // Iterable<{ path, content: Buffer }>\n  // Iterable<{ path, content: Blob }>\n  // Iterable<{ path, content: Iterable<Number> }>\n  // Iterable<{ path, content: AsyncIterable<Buffer> }>\n  // Iterable<{ path, content: PullStream<Buffer> }>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      for (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk);\n        } else {\n          // Must be an Iterable<Number> i.e. Buffer/ArrayBuffer/Array of bytes\n          yield normalizeTuple({\n            path: '',\n            content: input\n          });\n          return;\n        }\n      }\n    }();\n  } // AsyncIterable<Buffer>\n  // AsyncIterable<{ path, content: Buffer }>\n  // AsyncIterable<{ path, content: Blob }>\n  // AsyncIterable<{ path, content: Iterable<Buffer> }>\n  // AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n  // AsyncIterable<{ path, content: PullStream<Buffer> }>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      for await (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk);\n        } else {\n          // Must be an AsyncIterable<Buffer> i.e. a Stream\n          let path = ''; // fs.createReadStream will create a stream with a `path` prop\n          // If available, use it here!\n\n          if (input.path && input.path.split) {\n            path = input.path.split(/[/\\\\]/).pop() || '';\n          }\n\n          yield normalizeTuple({\n            path,\n            content: async function* () {\n              yield chunk;\n\n              for await (const restChunk of input) {\n                yield restChunk;\n              }\n            }()\n          });\n          return;\n        }\n      }\n    }();\n  } // { path, content: Buffer }\n  // { path, content: Blob }\n  // { path, content: Iterable<Buffer> }\n  // { path, content: AsyncIterable<Buffer> }\n  // { path, content: PullStream<Buffer> }\n\n\n  if (typeof input === 'object' && (input.path || input.content)) {\n    // eslint-disable-next-line require-await\n    return async function* () {\n      yield normalizeTuple(input);\n    }();\n  } // PullStream\n\n\n  if (typeof input === 'function') {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  }\n\n  throw new Error('Unexpected input: ' + typeof input);\n};\n\nfunction normalizeTuple({\n  path,\n  content\n}) {\n  return {\n    path: path || '',\n    content: content ? toAsyncIterable(content) : null\n  };\n}","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/ipfs-http-client-lite/src/add/normalise-input.js"],"names":["Buffer","require","toAsyncIterable","module","exports","normalizeInput","input","isBuffer","ArrayBuffer","isView","normalizeTuple","path","content","Blob","Symbol","iterator","chunk","asyncIterator","split","pop","restChunk","Error"],"mappings":"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","sourcesContent":["'use strict'\n/* eslint-env browser */\n\nconst { Buffer } = require('buffer')\nconst toAsyncIterable = require('../lib/file-data-to-async-iterable')\n\n/*\nTransform one of:\n\nBuffer|ArrayBuffer|TypedArray\nBlob|File\n{ path, content: Buffer }\n{ path, content: Blob }\n{ path, content: Iterable<Buffer> }\n{ path, content: AsyncIterable<Buffer> }\n{ path, content: PullStream<Buffer> }\nIterable<Number>\nIterable<{ path, content: Buffer }>\nIterable<{ path, content: Blob }>\nIterable<{ path, content: Iterable<Number> }>\nIterable<{ path, content: AsyncIterable<Buffer> }>\nIterable<{ path, content: PullStream<Buffer> }>\nAsyncIterable<Buffer>\nAsyncIterable<{ path, content: Buffer }>\nAsyncIterable<{ path, content: Blob }>\nAsyncIterable<{ path, content: Iterable<Buffer> }>\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\nAsyncIterable<{ path, content: PullStream<Buffer> }>\nPullStream<Buffer>\n\nInto:\n\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n*/\n\nmodule.exports = function normalizeInput (input) {\n  // Buffer|ArrayBuffer|TypedArray\n  if (Buffer.isBuffer(input) || ArrayBuffer.isView(input) || input instanceof ArrayBuffer) {\n    return (async function * () { // eslint-disable-line require-await\n      yield normalizeTuple({ path: '', content: input })\n    })()\n  }\n\n  // Blob|File\n  if (typeof Blob !== 'undefined' && input instanceof Blob) {\n    return (async function * () { // eslint-disable-line require-await\n      yield normalizeTuple({ path: '', content: input })\n    })()\n  }\n\n  // Iterable<Number>\n  // Iterable<{ path, content: Buffer }>\n  // Iterable<{ path, content: Blob }>\n  // Iterable<{ path, content: Iterable<Number> }>\n  // Iterable<{ path, content: AsyncIterable<Buffer> }>\n  // Iterable<{ path, content: PullStream<Buffer> }>\n  if (input[Symbol.iterator]) {\n    return (async function * () { // eslint-disable-line require-await\n      for (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk)\n        } else { // Must be an Iterable<Number> i.e. Buffer/ArrayBuffer/Array of bytes\n          yield normalizeTuple({ path: '', content: input })\n          return\n        }\n      }\n    })()\n  }\n\n  // AsyncIterable<Buffer>\n  // AsyncIterable<{ path, content: Buffer }>\n  // AsyncIterable<{ path, content: Blob }>\n  // AsyncIterable<{ path, content: Iterable<Buffer> }>\n  // AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n  // AsyncIterable<{ path, content: PullStream<Buffer> }>\n  if (input[Symbol.asyncIterator]) {\n    return (async function * () {\n      for await (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk)\n        } else { // Must be an AsyncIterable<Buffer> i.e. a Stream\n          let path = ''\n\n          // fs.createReadStream will create a stream with a `path` prop\n          // If available, use it here!\n          if (input.path && input.path.split) {\n            path = input.path.split(/[/\\\\]/).pop() || ''\n          }\n\n          yield normalizeTuple({\n            path,\n            content: (async function * () {\n              yield chunk\n              for await (const restChunk of input) {\n                yield restChunk\n              }\n            })()\n          })\n          return\n        }\n      }\n    })()\n  }\n\n  // { path, content: Buffer }\n  // { path, content: Blob }\n  // { path, content: Iterable<Buffer> }\n  // { path, content: AsyncIterable<Buffer> }\n  // { path, content: PullStream<Buffer> }\n  if (typeof input === 'object' && (input.path || input.content)) {\n    // eslint-disable-next-line require-await\n    return (async function * () { yield normalizeTuple(input) })()\n  }\n\n  // PullStream\n  if (typeof input === 'function') {\n    return (async function * () { // eslint-disable-line require-await\n      yield normalizeTuple({ path: '', content: input })\n    })()\n  }\n\n  throw new Error('Unexpected input: ' + typeof input)\n}\n\nfunction normalizeTuple ({ path, content }) {\n  return { path: path || '', content: content ? toAsyncIterable(content) : null }\n}\n"]},"metadata":{},"sourceType":"script"}