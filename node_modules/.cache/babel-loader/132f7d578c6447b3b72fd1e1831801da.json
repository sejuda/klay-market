{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable class-methods-use-this */\nconst _ = require('lodash');\n\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst {\n  KEY_ROLE\n} = require('./keyringHelper');\n\nconst Account = require('../../../caver-account');\n\nconst {\n  fillWeightedMultiSigOptionsForMultiSig\n} = require('../../../caver-account/src/accountKey/accountKeyHelper');\n\nconst {\n  validateForSigning,\n  validateIndexWithKeys,\n  encryptKey,\n  formatEncrypted\n} = require('./keyringHelper');\n/**\n * representing a Keyring which includes `address` and `private keys`.\n * @class\n */\n\n\nclass MultipleKeyring {\n  /**\n   * creates a MultipleKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<string>|Array.<PrivateKey>} keys - The keys to use in MultipleKeyring.\n   */\n  constructor(address, keys) {\n    this.address = address;\n    this.keys = keys;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n\n  set address(addressInput) {\n    if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`);\n    this._address = utils.addHexPrefix(addressInput).toLowerCase();\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get keys() {\n    return this._keys;\n  }\n\n  set keys(keyInput) {\n    if (keyInput === null) {\n      this._key = null;\n      return;\n    }\n\n    this._keys = formattingForKeyInKeyring(keyInput);\n  }\n  /**\n   * returns public key strings.\n   *\n   * @param {boolean} [compressed] Whether in compressed format or not.\n   * @return {Array.<string>}\n   */\n\n\n  getPublicKey(compressed = false) {\n    const publicKeys = [];\n\n    for (let i = 0; i < this.keys.length; i++) {\n      publicKeys.push(this.keys[i].getPublicKey(compressed));\n    }\n\n    return publicKeys;\n  }\n  /**\n   * returns a copied multipleKeyring instance\n   *\n   * @return {MultipleKeyring}\n   */\n\n\n  copy() {\n    return new MultipleKeyring(this.address, this.keys);\n  }\n  /**\n   * signs with transactionHash with key and returns signature(s).\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId specific to the network.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {Array.<string>|Array.<Array.<string>>}\n   */\n\n\n  sign(transactionHash, chainId, role, index) {\n    validateForSigning(transactionHash, chainId);\n    const keys = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      return keys[index].sign(transactionHash, chainId);\n    }\n\n    const signatures = [];\n\n    for (const k of keys) {\n      signatures.push(k.sign(transactionHash, chainId));\n    }\n\n    return signatures;\n  }\n  /**\n   * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n   *\n   * @param {string} message The message string to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used.\n   * @return {object}\n   */\n\n\n  signMessage(message, role, index) {\n    if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`);\n    const messageHash = utils.hashMessage(message);\n    const keys = this.getKeyByRole(role);\n    const signatures = [];\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      signatures.push(keys[index].signMessage(messageHash));\n    } else {\n      for (const k of keys) {\n        signatures.push(k.signMessage(messageHash));\n      }\n    }\n\n    return {\n      messageHash,\n      signatures,\n      message\n    };\n  }\n  /**\n   * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n   *\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @return {Array.<PrivateKey>}\n   */\n\n\n  getKeyByRole(role) {\n    if (role === undefined) throw new Error(`role should be defined.`);\n    if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`);\n    return this.keys;\n  }\n  /**\n   * returns an instance of Account.\n   *\n   * @param {WeightedMultiSigOptions} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n   * @return {Account}\n   */\n\n\n  toAccount(options) {\n    if (_.isArray(options)) throw new Error(`For AccountKeyWeightedMultiSig, options cannot be defined as an array of WeightedMultiSigOptions.`);\n    options = fillWeightedMultiSigOptionsForMultiSig(this.keys.length, options);\n    const publicKeys = this.getPublicKey();\n    return Account.createWithAccountKeyWeightedMultiSig(this.address, publicKeys, options);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v4 object.\n   *\n   * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n   * @return {object}\n   */\n\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n\n\n  encrypt(password, options = {}) {\n    let keyring = [];\n    keyring = encryptKey(this.keys, password, options);\n    return formatEncrypted(4, this.address, keyring, options);\n  }\n  /**\n   * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n   *\n   * @return {string}\n   */\n\n\n  getKlaytnWalletKey() {\n    throw new Error(`Not supported for this class.`);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v3 object.\n   *\n   * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n   * @return {object}\n   */\n\n\n  encryptV3(password, options) {\n    throw new Error(`Not supported for this class. Use 'keyring.encrypt(password)'.`);\n  }\n  /**\n   * returns true if keyring has decoupled key.\n   *\n   * @return {boolean}\n   */\n\n\n  isDecoupled() {\n    return true;\n  }\n\n}\n\nmodule.exports = MultipleKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance.\n * @param {Array.<string|PrivateKey>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<PrivateKey>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (!_.isArray(keyInput)) {\n    throw new Error(`Invalid parameter. The private keys to add should be defined as an array.`);\n  }\n\n  const keys = [];\n\n  for (let i = 0; i < keyInput.length; i++) {\n    keys.push(keyInput[i] instanceof PrivateKey ? keyInput[i] : new PrivateKey(keyInput[i]));\n  }\n\n  return keys;\n}","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-wallet/src/keyring/multipleKeyring.js"],"names":["_","require","utils","PrivateKey","KEY_ROLE","Account","fillWeightedMultiSigOptionsForMultiSig","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","MultipleKeyring","constructor","address","keys","_address","addressInput","isAddress","Error","addHexPrefix","toLowerCase","_keys","keyInput","_key","formattingForKeyInKeyring","getPublicKey","compressed","publicKeys","i","length","push","copy","sign","transactionHash","chainId","role","index","getKeyByRole","undefined","signatures","k","signMessage","message","messageHash","hashMessage","roleLast","toAccount","options","isArray","createWithAccountKeyWeightedMultiSig","encrypt","password","keyring","getKlaytnWalletKey","encryptV3","isDecoupled","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* eslint-disable no-unused-vars */\n/* eslint-disable class-methods-use-this */\n\nconst _ = require('lodash')\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { fillWeightedMultiSigOptionsForMultiSig } = require('../../../caver-account/src/accountKey/accountKeyHelper')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * representing a Keyring which includes `address` and `private keys`.\n * @class\n */\nclass MultipleKeyring {\n    /**\n     * creates a MultipleKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {Array.<string>|Array.<PrivateKey>} keys - The keys to use in MultipleKeyring.\n     */\n    constructor(address, keys) {\n        this.address = address\n        this.keys = keys\n    }\n\n    /**\n     * @type {string}\n     */\n    get address() {\n        return this._address\n    }\n\n    set address(addressInput) {\n        if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`)\n\n        this._address = utils.addHexPrefix(addressInput).toLowerCase()\n    }\n\n    /**\n     * @type {Array.<PrivateKey>}\n     */\n    get keys() {\n        return this._keys\n    }\n\n    set keys(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n        this._keys = formattingForKeyInKeyring(keyInput)\n    }\n\n    /**\n     * returns public key strings.\n     *\n     * @param {boolean} [compressed] Whether in compressed format or not.\n     * @return {Array.<string>}\n     */\n    getPublicKey(compressed = false) {\n        const publicKeys = []\n        for (let i = 0; i < this.keys.length; i++) {\n            publicKeys.push(this.keys[i].getPublicKey(compressed))\n        }\n        return publicKeys\n    }\n\n    /**\n     * returns a copied multipleKeyring instance\n     *\n     * @return {MultipleKeyring}\n     */\n    copy() {\n        return new MultipleKeyring(this.address, this.keys)\n    }\n\n    /**\n     * signs with transactionHash with key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const keys = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            return keys[index].sign(transactionHash, chainId)\n        }\n\n        const signatures = []\n        for (const k of keys) {\n            signatures.push(k.sign(transactionHash, chainId))\n        }\n        return signatures\n    }\n\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const keys = this.getKeyByRole(role)\n\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, keys.length)\n            signatures.push(keys[index].signMessage(messageHash))\n        } else {\n            for (const k of keys) {\n                signatures.push(k.signMessage(messageHash))\n            }\n        }\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        return this.keys\n    }\n\n    /**\n     * returns an instance of Account.\n     *\n     * @param {WeightedMultiSigOptions} [options] The options that includes 'threshold' and 'weight'. This is only necessary when keyring use multiple private keys.\n     * @return {Account}\n     */\n    toAccount(options) {\n        if (_.isArray(options))\n            throw new Error(`For AccountKeyWeightedMultiSig, options cannot be defined as an array of WeightedMultiSigOptions.`)\n\n        options = fillWeightedMultiSigOptionsForMultiSig(this.keys.length, options)\n\n        const publicKeys = this.getPublicKey()\n        return Account.createWithAccountKeyWeightedMultiSig(this.address, publicKeys, options)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    encrypt(password, options = {}) {\n        let keyring = []\n        keyring = encryptKey(this.keys, password, options)\n        return formatEncrypted(4, this.address, keyring, options)\n    }\n\n    /**\n     * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n     *\n     * @return {string}\n     */\n    getKlaytnWalletKey() {\n        throw new Error(`Not supported for this class.`)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v3 object.\n     *\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n     * @return {object}\n     */\n    encryptV3(password, options) {\n        throw new Error(`Not supported for this class. Use 'keyring.encrypt(password)'.`)\n    }\n\n    /**\n     * returns true if keyring has decoupled key.\n     *\n     * @return {boolean}\n     */\n    isDecoupled() {\n        return true\n    }\n}\n\nmodule.exports = MultipleKeyring\n\n/**\n * Format the key parameters passed by the user to create a keyring instance.\n * @param {Array.<string|PrivateKey>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<PrivateKey>}\n */\nfunction formattingForKeyInKeyring(keyInput) {\n    if (!_.isArray(keyInput)) {\n        throw new Error(`Invalid parameter. The private keys to add should be defined as an array.`)\n    }\n\n    const keys = []\n    for (let i = 0; i < keyInput.length; i++) {\n        keys.push(keyInput[i] instanceof PrivateKey ? keyInput[i] : new PrivateKey(keyInput[i]))\n    }\n\n    return keys\n}\n"]},"metadata":{},"sourceType":"script"}