{"ast":null,"code":"/* eslint-env browser */\nmodule.exports = source => async function* () {\n  const matcher = /\\r?\\n/;\n  const decoder = new TextDecoder('utf8');\n  let buffer = '';\n\n  for await (let chunk of source) {\n    if (typeof chunk === 'string') {\n      chunk = new TextEncoder().encode(chunk);\n    }\n\n    buffer += decoder.decode(chunk, {\n      stream: true\n    });\n    const parts = buffer.split(matcher);\n    buffer = parts.pop();\n\n    for (let i = 0; i < parts.length; i++) yield JSON.parse(parts[i]);\n  }\n\n  buffer += decoder.decode();\n  if (buffer) yield JSON.parse(buffer);\n}();","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/iterable-ndjson/parse.browser.js"],"names":["module","exports","source","matcher","decoder","TextDecoder","buffer","chunk","TextEncoder","encode","decode","stream","parts","split","pop","i","length","JSON","parse"],"mappings":"AAAA;AAEAA,MAAM,CAACC,OAAP,GAAiBC,MAAM,IAAK,mBAAoB;AAC9C,QAAMC,OAAO,GAAG,OAAhB;AACA,QAAMC,OAAO,GAAG,IAAIC,WAAJ,CAAgB,MAAhB,CAAhB;AACA,MAAIC,MAAM,GAAG,EAAb;;AACA,aAAW,IAAIC,KAAf,IAAwBL,MAAxB,EAAgC;AAC9B,QAAI,OAAOK,KAAP,KAAiB,QAArB,EAA+B;AAC7BA,MAAAA,KAAK,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBF,KAAzB,CAAR;AACD;;AACDD,IAAAA,MAAM,IAAIF,OAAO,CAACM,MAAR,CAAeH,KAAf,EAAsB;AAAEI,MAAAA,MAAM,EAAE;AAAV,KAAtB,CAAV;AACA,UAAMC,KAAK,GAAGN,MAAM,CAACO,KAAP,CAAaV,OAAb,CAAd;AACAG,IAAAA,MAAM,GAAGM,KAAK,CAACE,GAAN,EAAT;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC,MAAME,IAAI,CAACC,KAAL,CAAWN,KAAK,CAACG,CAAD,CAAhB,CAAN;AACxC;;AACDT,EAAAA,MAAM,IAAIF,OAAO,CAACM,MAAR,EAAV;AACA,MAAIJ,MAAJ,EAAY,MAAMW,IAAI,CAACC,KAAL,CAAWZ,MAAX,CAAN;AACb,CAf0B,EAA3B","sourcesContent":["/* eslint-env browser */\n\nmodule.exports = source => (async function * () {\n  const matcher = /\\r?\\n/\n  const decoder = new TextDecoder('utf8')\n  let buffer = ''\n  for await (let chunk of source) {\n    if (typeof chunk === 'string') {\n      chunk = new TextEncoder().encode(chunk)\n    }\n    buffer += decoder.decode(chunk, { stream: true })\n    const parts = buffer.split(matcher)\n    buffer = parts.pop()\n    for (let i = 0; i < parts.length; i++) yield JSON.parse(parts[i])\n  }\n  buffer += decoder.decode()\n  if (buffer) yield JSON.parse(buffer)\n})()\n"]},"metadata":{},"sourceType":"script"}