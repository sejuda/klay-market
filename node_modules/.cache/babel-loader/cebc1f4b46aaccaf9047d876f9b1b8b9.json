{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst TransactionHasher = require('../transactionHasher/transactionHasher');\n\nconst AbstractTransaction = require('./abstractTransaction');\n\nconst {\n  refineSignatures,\n  typeDetectionFromRLPEncoding\n} = require('../transactionHelper/transactionHelper');\n\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nconst SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring');\n\nconst MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring');\n\nconst RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring');\n\nconst {\n  KEY_ROLE\n} = require('../../../caver-wallet/src/keyring/keyringHelper');\n\nconst utils = require('../../../caver-utils/src');\n\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\n * Abstract class that implements common logic for each fee delegated transaction type.\n * @class\n */\n\n\nclass AbstractFeeDelegatedTransaction extends AbstractTransaction {\n  /**\n   * Abstract class that implements common logic for each fee-delegated transaction type.\n   * In this constructor, feePayer and feePayerSignatures are set as transaction member variables.\n   *\n   * @constructor\n   * @param {string} typeString - The type string of transaction.\n   * @param {object} createTxObj - The parameters to create an instance of transaction.\n   */\n  constructor(typeString, createTxObj) {\n    super(typeString, createTxObj);\n    this.feePayer = createTxObj.feePayer;\n    this.feePayerSignatures = createTxObj.feePayerSignatures || [];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get feePayer() {\n    return this._feePayer;\n  }\n\n  set feePayer(f) {\n    if (!f || f === '0x') f = '0x0000000000000000000000000000000000000000';\n    if (!utils.isAddress(f)) throw new Error(`Invalid address of fee payer: ${f}`);\n    this._feePayer = f.toLowerCase();\n  }\n  /**\n   * @type {Array.<Array.<string>>}\n   */\n\n\n  get feePayerSignatures() {\n    return this._feePayerSignatures;\n  }\n\n  set feePayerSignatures(sigs) {\n    this._feePayerSignatures = refineSignatures(sigs);\n  }\n  /**\n   * Signs to the transaction with private key(s) in `key` as a fee payer.\n   * @async\n   * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n   * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] - The function to get the transaction hash.\n   * @return {Transaction}\n   */\n\n\n  async signAsFeePayer(key, index, hasher = TransactionHasher.getHashForFeePayerSignature) {\n    // User parameter input cases\n    // (key) / (key index) / (key hasher) / (key index hasher)\n    if (_.isFunction(index)) {\n      hasher = index;\n      index = undefined;\n    }\n\n    let keyring = key;\n\n    if (_.isString(key)) {\n      keyring = Keyring.createFromPrivateKey(key);\n    }\n\n    if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring)) throw new Error(`Unsupported key type. The key parameter of the signAsFeePayer must be a single private key string, KlaytnWalletKey string, or Keyring instance.`);\n    if (!this.feePayer || this.feePayer === '0x' || this.feePayer === '0x0000000000000000000000000000000000000000') this.feePayer = keyring.address;\n    if (this.feePayer.toLowerCase() !== keyring.address.toLowerCase()) throw new Error(`The feePayer address of the transaction is different with the address of the keyring to use.`);\n    await this.fillTransaction();\n    const hash = hasher(this);\n    const sig = keyring.sign(hash, this.chainId, KEY_ROLE.roleFeePayerKey, index);\n    this.appendFeePayerSignatures(sig);\n    return this;\n  }\n  /**\n   * Appends feePayerSignatures to the transaction.\n   *\n   * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of feePayerSignatures to append to the transaction.\n   *                                                      One feePayerSignature can be defined in the form of a one-dimensional array or two-dimensional array,\n   *                                                      and more than one feePayerSignatures should be defined in the form of a two-dimensional array.\n   */\n\n\n  appendFeePayerSignatures(signatures) {\n    let sig = signatures;\n    if (_.isString(sig)) sig = utils.resolveSignature(sig);\n    if (sig instanceof SignatureData) sig = [sig];\n    if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`);\n    if (_.isString(sig[0])) sig = [sig];\n    this.feePayerSignatures = this.feePayerSignatures.concat(sig);\n  }\n  /**\n   * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n   * When combining the signatures into a transaction instance,\n   * an error is thrown if the decoded transaction contains different value except signatures.\n   *\n   * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n   * @return {string}\n   */\n\n\n  combineSignedRawTransactions(rlpEncodedTxs) {\n    if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP encoded transaction strings.`); // If the signatures are empty, there may be an undefined member variable.\n    // In this case, the empty information is filled with the decoded result.\n\n    let fillVariables = false;\n    if (utils.isEmptySig(this.signatures) || utils.isEmptySig(this.feePayerSignatures)) fillVariables = true;\n\n    for (const encoded of rlpEncodedTxs) {\n      const type = typeDetectionFromRLPEncoding(encoded);\n      if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`);\n      const decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n      // Therefore, compare whether the decoded transaction is the same as this.\n\n      for (const k in decoded) {\n        if (k === '_signatures' || k === '_feePayerSignatures') continue;\n\n        if (k === '_feePayer') {\n          const emtpyAddress = '0x0000000000000000000000000000000000000000';\n          if ((decoded[k] !== '0x' && decoded[k] !== emtpyAddress || this[k] === '0x' || this[k] === emtpyAddress) && fillVariables) this[k] = decoded[k];\n          if (decoded[k] === '0x' || decoded[k] === emtpyAddress) continue;\n        }\n\n        if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n        const differentTxError = `Transactions containing different information cannot be combined.`; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n        if (k === '_account') {\n          if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n          continue;\n        }\n\n        if (this[k] !== decoded[k]) throw new Error(differentTxError);\n      }\n\n      this.appendSignatures(decoded.signatures);\n      this.appendFeePayerSignatures(decoded.feePayerSignatures);\n    }\n\n    return this.getRLPEncoding();\n  }\n  /**\n   * Returns a senderTxHash of transaction\n   *\n   * @return {string}\n   */\n\n\n  getSenderTxHash() {\n    const rlpEncoded = this.getRLPEncoding();\n    const type = rlpEncoded.slice(0, 4);\n    const typeDetached = `0x${rlpEncoded.slice(4)}`;\n    const data = RLP.decode(typeDetached);\n    return Hash.keccak256(type + RLP.encode(data.slice(0, data.length - 2)).slice(2));\n  }\n  /**\n   * Returns an RLP-encoded transaction string for making signature as a fee payer\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncodingForFeePayerSignature() {\n    return RLP.encode([this.getCommonRLPEncodingForSignature(), this.feePayer, Bytes.fromNat(this.chainId), '0x', '0x']);\n  }\n\n}\n\nmodule.exports = AbstractFeeDelegatedTransaction;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/abstractFeeDelegatedTransaction.js"],"names":["_","require","RLP","Hash","Bytes","TransactionHasher","AbstractTransaction","refineSignatures","typeDetectionFromRLPEncoding","Keyring","SingleKeyring","MultipleKeyring","RoleBasedKeyring","KEY_ROLE","utils","SignatureData","AbstractFeeDelegatedTransaction","constructor","typeString","createTxObj","feePayer","feePayerSignatures","_feePayer","f","isAddress","Error","toLowerCase","_feePayerSignatures","sigs","signAsFeePayer","key","index","hasher","getHashForFeePayerSignature","isFunction","undefined","keyring","isString","createFromPrivateKey","address","fillTransaction","hash","sig","sign","chainId","roleFeePayerKey","appendFeePayerSignatures","signatures","resolveSignature","isArray","concat","combineSignedRawTransactions","rlpEncodedTxs","fillVariables","isEmptySig","encoded","type","decoded","decode","k","emtpyAddress","differentTxError","getRLPEncodingAccountKey","appendSignatures","getRLPEncoding","getSenderTxHash","rlpEncoded","slice","typeDetached","data","keccak256","encode","length","getRLPEncodingForFeePayerSignature","getCommonRLPEncodingForSignature","fromNat","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst RLP = require('eth-lib/lib/rlp')\nconst Hash = require('eth-lib/lib/hash')\nconst Bytes = require('eth-lib/lib/bytes')\nconst TransactionHasher = require('../transactionHasher/transactionHasher')\nconst AbstractTransaction = require('./abstractTransaction')\nconst { refineSignatures, typeDetectionFromRLPEncoding } = require('../transactionHelper/transactionHelper')\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory')\nconst SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring')\nconst MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring')\nconst RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring')\nconst { KEY_ROLE } = require('../../../caver-wallet/src/keyring/keyringHelper')\nconst utils = require('../../../caver-utils/src')\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData')\n\n/**\n * Abstract class that implements common logic for each fee delegated transaction type.\n * @class\n */\nclass AbstractFeeDelegatedTransaction extends AbstractTransaction {\n    /**\n     * Abstract class that implements common logic for each fee-delegated transaction type.\n     * In this constructor, feePayer and feePayerSignatures are set as transaction member variables.\n     *\n     * @constructor\n     * @param {string} typeString - The type string of transaction.\n     * @param {object} createTxObj - The parameters to create an instance of transaction.\n     */\n    constructor(typeString, createTxObj) {\n        super(typeString, createTxObj)\n        this.feePayer = createTxObj.feePayer\n        this.feePayerSignatures = createTxObj.feePayerSignatures || []\n    }\n\n    /**\n     * @type {string}\n     */\n    get feePayer() {\n        return this._feePayer\n    }\n\n    set feePayer(f) {\n        if (!f || f === '0x') f = '0x0000000000000000000000000000000000000000'\n        if (!utils.isAddress(f)) throw new Error(`Invalid address of fee payer: ${f}`)\n\n        this._feePayer = f.toLowerCase()\n    }\n\n    /**\n     * @type {Array.<Array.<string>>}\n     */\n    get feePayerSignatures() {\n        return this._feePayerSignatures\n    }\n\n    set feePayerSignatures(sigs) {\n        this._feePayerSignatures = refineSignatures(sigs)\n    }\n\n    /**\n     * Signs to the transaction with private key(s) in `key` as a fee payer.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get the transaction hash.\n     * @return {Transaction}\n     */\n    async signAsFeePayer(key, index, hasher = TransactionHasher.getHashForFeePayerSignature) {\n        // User parameter input cases\n        // (key) / (key index) / (key hasher) / (key index hasher)\n        if (_.isFunction(index)) {\n            hasher = index\n            index = undefined\n        }\n\n        let keyring = key\n        if (_.isString(key)) {\n            keyring = Keyring.createFromPrivateKey(key)\n        }\n        if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))\n            throw new Error(\n                `Unsupported key type. The key parameter of the signAsFeePayer must be a single private key string, KlaytnWalletKey string, or Keyring instance.`\n            )\n\n        if (!this.feePayer || this.feePayer === '0x' || this.feePayer === '0x0000000000000000000000000000000000000000')\n            this.feePayer = keyring.address\n        if (this.feePayer.toLowerCase() !== keyring.address.toLowerCase())\n            throw new Error(`The feePayer address of the transaction is different with the address of the keyring to use.`)\n\n        await this.fillTransaction()\n        const hash = hasher(this)\n        const sig = keyring.sign(hash, this.chainId, KEY_ROLE.roleFeePayerKey, index)\n\n        this.appendFeePayerSignatures(sig)\n\n        return this\n    }\n\n    /**\n     * Appends feePayerSignatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of feePayerSignatures to append to the transaction.\n     *                                                      One feePayerSignature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one feePayerSignatures should be defined in the form of a two-dimensional array.\n     */\n    appendFeePayerSignatures(signatures) {\n        let sig = signatures\n        if (_.isString(sig)) sig = utils.resolveSignature(sig)\n        if (sig instanceof SignatureData) sig = [sig]\n\n        if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`)\n\n        if (_.isString(sig[0])) sig = [sig]\n\n        this.feePayerSignatures = this.feePayerSignatures.concat(sig)\n    }\n\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n    combineSignedRawTransactions(rlpEncodedTxs) {\n        if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP encoded transaction strings.`)\n\n        // If the signatures are empty, there may be an undefined member variable.\n        // In this case, the empty information is filled with the decoded result.\n        let fillVariables = false\n        if (utils.isEmptySig(this.signatures) || utils.isEmptySig(this.feePayerSignatures)) fillVariables = true\n\n        for (const encoded of rlpEncodedTxs) {\n            const type = typeDetectionFromRLPEncoding(encoded)\n            if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`)\n\n            const decoded = this.constructor.decode(encoded)\n\n            // Signatures can only be combined for the same transaction.\n            // Therefore, compare whether the decoded transaction is the same as this.\n            for (const k in decoded) {\n                if (k === '_signatures' || k === '_feePayerSignatures') continue\n                if (k === '_feePayer') {\n                    const emtpyAddress = '0x0000000000000000000000000000000000000000'\n                    if (\n                        ((decoded[k] !== '0x' && decoded[k] !== emtpyAddress) || (this[k] === '0x' || this[k] === emtpyAddress)) &&\n                        fillVariables\n                    )\n                        this[k] = decoded[k]\n                    if (decoded[k] === '0x' || decoded[k] === emtpyAddress) continue\n                }\n\n                if (this[k] === undefined && fillVariables) this[k] = decoded[k]\n\n                const differentTxError = `Transactions containing different information cannot be combined.`\n\n                // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n                if (k === '_account') {\n                    if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError)\n                    continue\n                }\n\n                if (this[k] !== decoded[k]) throw new Error(differentTxError)\n            }\n\n            this.appendSignatures(decoded.signatures)\n            this.appendFeePayerSignatures(decoded.feePayerSignatures)\n        }\n\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n    getSenderTxHash() {\n        const rlpEncoded = this.getRLPEncoding()\n        const type = rlpEncoded.slice(0, 4)\n        const typeDetached = `0x${rlpEncoded.slice(4)}`\n\n        const data = RLP.decode(typeDetached)\n\n        return Hash.keccak256(type + RLP.encode(data.slice(0, data.length - 2)).slice(2))\n    }\n\n    /**\n     * Returns an RLP-encoded transaction string for making signature as a fee payer\n     *\n     * @return {string}\n     */\n    getRLPEncodingForFeePayerSignature() {\n        return RLP.encode([this.getCommonRLPEncodingForSignature(), this.feePayer, Bytes.fromNat(this.chainId), '0x', '0x'])\n    }\n}\n\nmodule.exports = AbstractFeeDelegatedTransaction\n"]},"metadata":{},"sourceType":"script"}