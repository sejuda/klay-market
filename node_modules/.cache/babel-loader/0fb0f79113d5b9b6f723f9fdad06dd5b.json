{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst TransactionHasher = require('../transactionHasher/transactionHasher');\n\nconst utils = require('../../../caver-utils');\n\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory');\n\nconst SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring');\n\nconst MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring');\n\nconst RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring');\n\nconst {\n  TX_TYPE_STRING,\n  refineSignatures,\n  typeDetectionFromRLPEncoding\n} = require('../transactionHelper/transactionHelper');\n\nconst {\n  KEY_ROLE\n} = require('../../../caver-wallet/src/keyring/keyringHelper');\n\nconst {\n  validateParams\n} = require('../../../caver-core-helpers/src/validateFunction');\n\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData');\n/**\n * Abstract class that implements common logic for each transaction type.\n * @class\n */\n\n\nclass AbstractTransaction {\n  /**\n   * Abstract class that implements common logic for each transaction type.\n   * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\n   *\n   * @constructor\n   * @param {string} typeString - The type string of transaction.\n   * @param {object} createTxObj - The parameters to create a transaction instance.\n   */\n  constructor(typeString, createTxObj) {\n    this._type = typeString;\n    createTxObj.type = typeString;\n    const err = validateParams(createTxObj);\n    if (err) throw err;\n    this.from = createTxObj.from;\n    this.gas = createTxObj.gas; // The variables below are values that the user does not need to pass to the parameter.\n\n    if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce;\n    if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice;\n    if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId;\n    this.signatures = createTxObj.signatures || [];\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get type() {\n    return this._type;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get from() {\n    return this._from;\n  }\n\n  set from(address) {\n    if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && (address === '0x' || address === '0x0000000000000000000000000000000000000000')) {\n      this._from = address.toLowerCase();\n    } else {\n      if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}`);\n      this._from = address.toLowerCase();\n    }\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get nonce() {\n    return this._nonce;\n  }\n\n  set nonce(n) {\n    this._nonce = utils.numberToHex(n);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get gas() {\n    return this._gas;\n  }\n\n  set gas(g) {\n    this._gas = utils.numberToHex(g);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get gasPrice() {\n    return this._gasPrice;\n  }\n\n  set gasPrice(g) {\n    this._gasPrice = utils.numberToHex(g);\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get chainId() {\n    return this._chainId;\n  }\n\n  set chainId(ch) {\n    this._chainId = utils.toHex(ch);\n  }\n  /**\n   * @type {Array<string>|Array.<Array<string>>}\n   */\n\n\n  get signatures() {\n    return this._signatures;\n  }\n\n  set signatures(sigs) {\n    this._signatures = refineSignatures(sigs, this.type === TX_TYPE_STRING.TxTypeLegacyTransaction);\n  }\n  /**\n   * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\n   * This method has to be overrided in classes which extends AbstractTransaction.\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncoding() {\n    throw new Error(`Not implemented.`);\n  }\n  /**\n   * Returns the RLP-encoded string to make the signature of this transaction.\n   * This method has to be overrided in classes which extends AbstractTransaction.\n   * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\n   *\n   * @return {string}\n   */\n\n\n  getCommonRLPEncodingForSignature() {\n    throw new Error(`Not implemented.`);\n  }\n  /**\n   * Signs to the transaction with private key(s) in the `key`.\n   * @async\n   * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n   * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] - The function to get hash of transaction. In order to use a custom hasher, the index must be defined.\n   * @return {Transaction}\n   */\n\n\n  async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\n    // User parameter input cases\n    // (key) / (key index) / (key hasher) / (key index hasher)\n    if (_.isFunction(index)) {\n      hasher = index;\n      index = undefined;\n    }\n\n    let keyring = key;\n\n    if (_.isString(key)) {\n      keyring = Keyring.createFromPrivateKey(key);\n    }\n\n    if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring)) throw new Error(`Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.`); // When user attempt to sign with a updated keyring into a TxTypeLegacyTransaction error should be thrown.\n\n    if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && keyring.isDecoupled()) throw new Error(`A legacy transaction cannot be signed with a decoupled keyring.`);\n    if (!this.from || this.from === '0x' || this.from === '0x0000000000000000000000000000000000000000') this.from = keyring.address;\n    if (this.from.toLowerCase() !== keyring.address.toLowerCase()) throw new Error(`The from address of the transaction is different with the address of the keyring to use.`);\n    await this.fillTransaction();\n    const hash = hasher(this);\n    const role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n    const sig = keyring.sign(hash, this.chainId, role, index);\n    this.appendSignatures(sig);\n    return this;\n  }\n  /**\n   * Appends signatures to the transaction.\n   *\n   * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of signatures to append to the transaction.\n   *                                                      One signature can be defined in the form of a one-dimensional array or two-dimensional array,\n   *                                                      and more than one signatures should be defined in the form of a two-dimensional array.\n   */\n\n\n  appendSignatures(signatures) {\n    let sig = signatures;\n    if (_.isString(sig)) sig = utils.resolveSignature(sig);\n    if (sig instanceof SignatureData) sig = [sig];\n    if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`);\n    if (_.isString(sig[0])) sig = [sig];\n    this.signatures = this.signatures.concat(sig);\n  }\n  /**\n   * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n   * When combining the signatures into a transaction instance,\n   * an error is thrown if the decoded transaction contains different value except signatures.\n   *\n   * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n   * @return {string}\n   */\n\n\n  combineSignedRawTransactions(rlpEncodedTxs) {\n    if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP-encoded transaction strings.`); // If the signatures are empty, there may be an undefined member variable.\n    // In this case, the empty information is filled with the decoded result.\n\n    let fillVariables = false;\n    if (utils.isEmptySig(this.signatures)) fillVariables = true;\n\n    for (const encoded of rlpEncodedTxs) {\n      const type = typeDetectionFromRLPEncoding(encoded);\n      if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`);\n      const decoded = this.constructor.decode(encoded); // Signatures can only be combined for the same transaction.\n      // Therefore, compare whether the decoded transaction is the same as this.\n\n      for (const k in decoded) {\n        if (k === '_signatures' || k === '_feePayerSignatures') continue;\n        if (this[k] === undefined && fillVariables) this[k] = decoded[k];\n        const differentTxError = `Transactions containing different information cannot be combined.`; // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n\n        if (k === '_account') {\n          if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError);\n          continue;\n        }\n\n        if (this[k] !== decoded[k]) throw new Error(differentTxError);\n      }\n\n      this.appendSignatures(decoded.signatures);\n    }\n\n    return this.getRLPEncoding();\n  }\n  /**\n   * Returns RawTransaction(RLP-encoded transaction string)\n   *\n   * @return {string}\n   */\n\n\n  getRawTransaction() {\n    return this.getRLPEncoding();\n  }\n  /**\n   * Returns a hash string of transaction\n   *\n   * @return {string}\n   */\n\n\n  getTransactionHash() {\n    return Hash.keccak256(this.getRLPEncoding());\n  }\n  /**\n   * Returns a senderTxHash of transaction\n   *\n   * @return {string}\n   */\n\n\n  getSenderTxHash() {\n    return this.getTransactionHash();\n  }\n  /**\n   * Returns an RLP-encoded transaction string for making signature\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncodingForSignature() {\n    this.validateOptionalValues();\n    if (this.chainId === undefined) throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`);\n    return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x']);\n  }\n  /**\n   * Fills empty optional transaction properties(gasPrice, nonce, chainId).\n   */\n\n\n  async fillTransaction() {\n    const [chainId, gasPrice, nonce] = await Promise.all([isNot(this.chainId) ? AbstractTransaction._klaytnCall.getChainId() : this.chainId, isNot(this.gasPrice) ? AbstractTransaction._klaytnCall.getGasPrice() : this.gasPrice, isNot(this.nonce) ? AbstractTransaction._klaytnCall.getTransactionCount(this.from, 'pending') : this.nonce]);\n    this.chainId = chainId;\n    this.gasPrice = gasPrice;\n    this.nonce = nonce;\n  }\n  /**\n   * Checks that member variables that can be defined by the user are defined.\n   * If there is an undefined variable, an error occurs.\n   */\n\n\n  validateOptionalValues() {\n    if (this.gasPrice === undefined) throw new Error(`gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.`);\n    if (this.nonce === undefined) throw new Error(`nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.`);\n  }\n\n}\n\nconst isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nmodule.exports = AbstractTransaction;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-transaction/src/transactionTypes/abstractTransaction.js"],"names":["_","require","Bytes","RLP","Hash","TransactionHasher","utils","Keyring","SingleKeyring","MultipleKeyring","RoleBasedKeyring","TX_TYPE_STRING","refineSignatures","typeDetectionFromRLPEncoding","KEY_ROLE","validateParams","SignatureData","AbstractTransaction","constructor","typeString","createTxObj","_type","type","err","from","gas","nonce","undefined","gasPrice","chainId","signatures","_from","address","TxTypeLegacyTransaction","toLowerCase","isAddress","Error","_nonce","n","numberToHex","_gas","g","_gasPrice","_chainId","ch","toHex","_signatures","sigs","getRLPEncoding","getCommonRLPEncodingForSignature","sign","key","index","hasher","getHashForSignature","isFunction","keyring","isString","createFromPrivateKey","isDecoupled","fillTransaction","hash","role","includes","roleAccountUpdateKey","roleTransactionKey","sig","appendSignatures","resolveSignature","isArray","concat","combineSignedRawTransactions","rlpEncodedTxs","fillVariables","isEmptySig","encoded","decoded","decode","k","differentTxError","getRLPEncodingAccountKey","getRawTransaction","getTransactionHash","keccak256","getSenderTxHash","getRLPEncodingForSignature","validateOptionalValues","encode","fromNat","Promise","all","isNot","_klaytnCall","getChainId","getGasPrice","getTransactionCount","value","isUndefined","isNull","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst Bytes = require('eth-lib/lib/bytes')\nconst RLP = require('eth-lib/lib/rlp')\nconst Hash = require('eth-lib/lib/hash')\nconst TransactionHasher = require('../transactionHasher/transactionHasher')\nconst utils = require('../../../caver-utils')\nconst Keyring = require('../../../caver-wallet/src/keyring/keyringFactory')\nconst SingleKeyring = require('../../../caver-wallet/src/keyring/singleKeyring')\nconst MultipleKeyring = require('../../../caver-wallet/src/keyring/multipleKeyring')\nconst RoleBasedKeyring = require('../../../caver-wallet/src/keyring/roleBasedKeyring')\nconst { TX_TYPE_STRING, refineSignatures, typeDetectionFromRLPEncoding } = require('../transactionHelper/transactionHelper')\nconst { KEY_ROLE } = require('../../../caver-wallet/src/keyring/keyringHelper')\nconst { validateParams } = require('../../../caver-core-helpers/src/validateFunction')\nconst SignatureData = require('../../../caver-wallet/src/keyring/signatureData')\n\n/**\n * Abstract class that implements common logic for each transaction type.\n * @class\n */\nclass AbstractTransaction {\n    /**\n     * Abstract class that implements common logic for each transaction type.\n     * In this constructor, type, tag, nonce, gasPrice, chainId, gas and signatures are set as transaction member variables.\n     *\n     * @constructor\n     * @param {string} typeString - The type string of transaction.\n     * @param {object} createTxObj - The parameters to create a transaction instance.\n     */\n    constructor(typeString, createTxObj) {\n        this._type = typeString\n\n        createTxObj.type = typeString\n\n        const err = validateParams(createTxObj)\n        if (err) throw err\n\n        this.from = createTxObj.from\n\n        this.gas = createTxObj.gas\n\n        // The variables below are values that the user does not need to pass to the parameter.\n        if (createTxObj.nonce !== undefined) this.nonce = createTxObj.nonce\n        if (createTxObj.gasPrice !== undefined) this.gasPrice = createTxObj.gasPrice\n        if (createTxObj.chainId !== undefined) this.chainId = createTxObj.chainId\n\n        this.signatures = createTxObj.signatures || []\n    }\n\n    /**\n     * @type {string}\n     */\n    get type() {\n        return this._type\n    }\n\n    /**\n     * @type {string}\n     */\n    get from() {\n        return this._from\n    }\n\n    set from(address) {\n        if (\n            this.type === TX_TYPE_STRING.TxTypeLegacyTransaction &&\n            (address === '0x' || address === '0x0000000000000000000000000000000000000000')\n        ) {\n            this._from = address.toLowerCase()\n        } else {\n            if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}`)\n            this._from = address.toLowerCase()\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get nonce() {\n        return this._nonce\n    }\n\n    set nonce(n) {\n        this._nonce = utils.numberToHex(n)\n    }\n\n    /**\n     * @type {string}\n     */\n    get gas() {\n        return this._gas\n    }\n\n    set gas(g) {\n        this._gas = utils.numberToHex(g)\n    }\n\n    /**\n     * @type {string}\n     */\n    get gasPrice() {\n        return this._gasPrice\n    }\n\n    set gasPrice(g) {\n        this._gasPrice = utils.numberToHex(g)\n    }\n\n    /**\n     * @type {string}\n     */\n    get chainId() {\n        return this._chainId\n    }\n\n    set chainId(ch) {\n        this._chainId = utils.toHex(ch)\n    }\n\n    /**\n     * @type {Array<string>|Array.<Array<string>>}\n     */\n    get signatures() {\n        return this._signatures\n    }\n\n    set signatures(sigs) {\n        this._signatures = refineSignatures(sigs, this.type === TX_TYPE_STRING.TxTypeLegacyTransaction)\n    }\n\n    /**\n     * Returns the RLP-encoded string of this transaction (i.e., rawTransaction).\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     *\n     * @return {string}\n     */\n    getRLPEncoding() {\n        throw new Error(`Not implemented.`)\n    }\n\n    /**\n     * Returns the RLP-encoded string to make the signature of this transaction.\n     * This method has to be overrided in classes which extends AbstractTransaction.\n     * getCommonRLPEncodingForSignature is used in getRLPEncodingForSignature.\n     *\n     * @return {string}\n     */\n    getCommonRLPEncodingForSignature() {\n        throw new Error(`Not implemented.`)\n    }\n\n    /**\n     * Signs to the transaction with private key(s) in the `key`.\n     * @async\n     * @param {Keyring|string} key - The instance of Keyring, private key string or KlaytnWalletKey string.\n     * @param {number} [index] - The index of private key to use. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] - The function to get hash of transaction. In order to use a custom hasher, the index must be defined.\n     * @return {Transaction}\n     */\n    async sign(key, index, hasher = TransactionHasher.getHashForSignature) {\n        // User parameter input cases\n        // (key) / (key index) / (key hasher) / (key index hasher)\n        if (_.isFunction(index)) {\n            hasher = index\n            index = undefined\n        }\n\n        let keyring = key\n        if (_.isString(key)) {\n            keyring = Keyring.createFromPrivateKey(key)\n        }\n        if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))\n            throw new Error(\n                `Unsupported key type. The key must be a single private key string, KlaytnWalletKey string, or Keyring instance.`\n            )\n\n        // When user attempt to sign with a updated keyring into a TxTypeLegacyTransaction error should be thrown.\n        if (this.type === TX_TYPE_STRING.TxTypeLegacyTransaction && keyring.isDecoupled())\n            throw new Error(`A legacy transaction cannot be signed with a decoupled keyring.`)\n\n        if (!this.from || this.from === '0x' || this.from === '0x0000000000000000000000000000000000000000') this.from = keyring.address\n        if (this.from.toLowerCase() !== keyring.address.toLowerCase())\n            throw new Error(`The from address of the transaction is different with the address of the keyring to use.`)\n\n        await this.fillTransaction()\n        const hash = hasher(this)\n        const role = this.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey\n\n        const sig = keyring.sign(hash, this.chainId, role, index)\n\n        this.appendSignatures(sig)\n\n        return this\n    }\n\n    /**\n     * Appends signatures to the transaction.\n     *\n     * @param {SignatureData|Array.<SignatureData>|Array.<string>|Array.<Array.<string>>} signatures - An array of signatures to append to the transaction.\n     *                                                      One signature can be defined in the form of a one-dimensional array or two-dimensional array,\n     *                                                      and more than one signatures should be defined in the form of a two-dimensional array.\n     */\n    appendSignatures(signatures) {\n        let sig = signatures\n        if (_.isString(sig)) sig = utils.resolveSignature(sig)\n        if (sig instanceof SignatureData) sig = [sig]\n\n        if (!_.isArray(sig)) throw new Error(`Failed to append signatures: invalid signatures format ${sig}`)\n\n        if (_.isString(sig[0])) sig = [sig]\n\n        this.signatures = this.signatures.concat(sig)\n    }\n\n    /**\n     * Combines RLP-encoded transactions (rawTransaction) to the transaction from RLP-encoded transaction strings and returns a single transaction with all signatures combined.\n     * When combining the signatures into a transaction instance,\n     * an error is thrown if the decoded transaction contains different value except signatures.\n     *\n     * @param {Array.<string>} rlpEncodedTxs - An array of RLP-encoded transaction strings.\n     * @return {string}\n     */\n    combineSignedRawTransactions(rlpEncodedTxs) {\n        if (!_.isArray(rlpEncodedTxs)) throw new Error(`The parameter must be an array of RLP-encoded transaction strings.`)\n\n        // If the signatures are empty, there may be an undefined member variable.\n        // In this case, the empty information is filled with the decoded result.\n        let fillVariables = false\n        if (utils.isEmptySig(this.signatures)) fillVariables = true\n\n        for (const encoded of rlpEncodedTxs) {\n            const type = typeDetectionFromRLPEncoding(encoded)\n            if (this.type !== type) throw new Error(`Transaction type mismatch: Signatures from different transactions cannot be combined.`)\n\n            const decoded = this.constructor.decode(encoded)\n\n            // Signatures can only be combined for the same transaction.\n            // Therefore, compare whether the decoded transaction is the same as this.\n            for (const k in decoded) {\n                if (k === '_signatures' || k === '_feePayerSignatures') continue\n                if (this[k] === undefined && fillVariables) this[k] = decoded[k]\n\n                const differentTxError = `Transactions containing different information cannot be combined.`\n\n                // Compare with the RLP-encoded accountKey string, because 'account' is an object.\n                if (k === '_account') {\n                    if (this[k].getRLPEncodingAccountKey() !== decoded[k].getRLPEncodingAccountKey()) throw new Error(differentTxError)\n                    continue\n                }\n\n                if (this[k] !== decoded[k]) throw new Error(differentTxError)\n            }\n\n            this.appendSignatures(decoded.signatures)\n        }\n\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns RawTransaction(RLP-encoded transaction string)\n     *\n     * @return {string}\n     */\n    getRawTransaction() {\n        return this.getRLPEncoding()\n    }\n\n    /**\n     * Returns a hash string of transaction\n     *\n     * @return {string}\n     */\n    getTransactionHash() {\n        return Hash.keccak256(this.getRLPEncoding())\n    }\n\n    /**\n     * Returns a senderTxHash of transaction\n     *\n     * @return {string}\n     */\n    getSenderTxHash() {\n        return this.getTransactionHash()\n    }\n\n    /**\n     * Returns an RLP-encoded transaction string for making signature\n     *\n     * @return {string}\n     */\n    getRLPEncodingForSignature() {\n        this.validateOptionalValues()\n        if (this.chainId === undefined)\n            throw new Error(`chainId is undefined. Define chainId in transaction or use 'transaction.fillTransaction' to fill values.`)\n\n        return RLP.encode([this.getCommonRLPEncodingForSignature(), Bytes.fromNat(this.chainId), '0x', '0x'])\n    }\n\n    /**\n     * Fills empty optional transaction properties(gasPrice, nonce, chainId).\n     */\n    async fillTransaction() {\n        const [chainId, gasPrice, nonce] = await Promise.all([\n            isNot(this.chainId) ? AbstractTransaction._klaytnCall.getChainId() : this.chainId,\n            isNot(this.gasPrice) ? AbstractTransaction._klaytnCall.getGasPrice() : this.gasPrice,\n            isNot(this.nonce) ? AbstractTransaction._klaytnCall.getTransactionCount(this.from, 'pending') : this.nonce,\n        ])\n\n        this.chainId = chainId\n        this.gasPrice = gasPrice\n        this.nonce = nonce\n    }\n\n    /**\n     * Checks that member variables that can be defined by the user are defined.\n     * If there is an undefined variable, an error occurs.\n     */\n    validateOptionalValues() {\n        if (this.gasPrice === undefined)\n            throw new Error(`gasPrice is undefined. Define gasPrice in transaction or use 'transaction.fillTransaction' to fill values.`)\n        if (this.nonce === undefined)\n            throw new Error(`nonce is undefined. Define nonce in transaction or use 'transaction.fillTransaction' to fill values.`)\n    }\n}\n\nconst isNot = function(value) {\n    return _.isUndefined(value) || _.isNull(value)\n}\n\nmodule.exports = AbstractTransaction\n"]},"metadata":{},"sourceType":"script"}