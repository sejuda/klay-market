{"ast":null,"code":"/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-utils/src/utils.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n\n/**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst BN = require('bn.js');\n\nconst BigNumber = require('bignumber.js');\n\nconst numberToBN = require('number-to-bn');\n\nconst utf8 = require('utf8');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Account = require('eth-lib/lib/account');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\nconst txTypeToString = {\n  '0x20': 'ACCOUNT_UPDATE',\n  '0x21': 'FEE_DELEGATED_ACCOUNT_UPDATE',\n  '0x22': 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO',\n  '0x08': 'VALUE_TRANSFER',\n  '0x10': 'VALUE_TRANSFER_MEMO',\n  '0x09': 'FEE_DELEGATED_VALUE_TRANSFER',\n  '0x0a': 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO',\n  '0x11': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO',\n  '0x12': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO',\n  '0x28': 'SMART_CONTRACT_DEPLOY',\n  '0x29': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY',\n  '0x2a': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO',\n  '0x30': 'SMART_CONTRACT_EXECUTION',\n  '0x31': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION',\n  '0x32': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO',\n  '0x38': 'CANCEL',\n  '0x39': 'FEE_DELEGATED_CANCEL',\n  '0x3a': 'FEE_DELEGATED_CANCEL_WITH_RATIO',\n  '0x48': 'CHAIN_DATA_ANCHORING'\n};\nconst HASH_LENGTH = 66;\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */\n\nconst isBN = function (object) {\n  return BN.isBN(object);\n};\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */\n\n\nconst isBigNumber = function (num) {\n  return BigNumber.isBigNumber(num);\n};\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */\n\n\nfunction toBN(number) {\n  try {\n    return numberToBN.apply(null, arguments);\n  } catch (e) {\n    throw new Error(`${e} Given value: \"${number}\"`);\n  }\n}\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */\n\n\nconst toTwosComplement = function (number) {\n  return `0x${toBN(number).toTwos(256).toString(16, 64)}`;\n};\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\n\n\nconst isAddress = function (address) {\n  // check if it has the basic requirements of an address\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false; // If it's ALL lowercase or ALL upppercase\n  }\n\n  if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n    return true; // Otherwise check each case\n  }\n\n  return checkAddressChecksum(address);\n};\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\n\n\nconst checkAddressChecksum = function (address) {\n  // Check each case\n  address = address.replace(/^0x/i, '');\n  const addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');\n\n  for (let i = 0; i < 40; i++) {\n    // the nth letter should be uppercase if the nth digit of casemap is 1\n    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\n\n\nconst leftPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string;\n};\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\n\n\nconst rightPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0');\n};\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\n\n\nconst utf8ToHex = function (str) {\n  str = utf8.encode(str);\n  let hex = ''; // remove \\u0000 padding from either side\n\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i); // if (code !== 0) {\n\n    const n = code.toString(16);\n    hex += n.length < 2 ? `0${n}` : n; // }\n  }\n\n  return `0x${hex}`;\n};\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\n\n\nconst hexToUtf8 = function (hex) {\n  if (!isHexStrict(hex)) {\n    throw new Error(`The parameter \"${hex}\" must be a valid HEX string.`);\n  }\n\n  let str = '';\n  let code = 0;\n  hex = hex.replace(/^0x/i, ''); // remove 00 padding from either side\n\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  const l = hex.length;\n\n  for (let i = 0; i < l; i += 2) {\n    code = parseInt(hex.substr(i, 2), 16); // if (code !== 0) {\n\n    str += String.fromCharCode(code); // }\n  }\n\n  return utf8.decode(str);\n};\n/**\n * Converts value to it's number representation\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @return {String}\n */\n\n\nconst hexToNumber = function (value) {\n  if (!value) return value;\n  return toBN(value).toNumber();\n};\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */\n\n\nconst hexToNumberString = function (value) {\n  if (!value) return value;\n  return toBN(value).toString(10);\n};\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */\n\n\nconst numberToHex = function (value) {\n  if (_.isNull(value) || _.isUndefined(value)) {\n    return value;\n  }\n\n  if (!isFinite(value) && !isHexStrict(value)) {\n    throw new Error(`Given input \"${value}\" is not a number.`);\n  }\n\n  const number = toBN(value);\n  const result = number.toString(16);\n  return number.lt(new BN(0)) ? `-0x${result.substr(1)}` : `0x${result}`;\n};\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */\n\n\nconst bytesToHex = function (bytes) {\n  const hex = [];\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    hex.push((bytes[i] >>> 4).toString(16)); // eslint-disable-next-line no-bitwise\n\n    hex.push((bytes[i] & 0xf).toString(16));\n  }\n\n  return `0x${hex.join('')}`;\n};\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */\n\n\nconst hexToBytes = function (hex) {\n  hex = hex.toString(16);\n\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n\n  hex = hex.replace(/^0x/i, '');\n  const bytes = [];\n\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n};\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object} value\n * @param {Boolean} returnType\n * @return {String}\n */\n\n/* eslint-disable complexity */\n\n\nconst toHex = function (value, returnType) {\n  if (Buffer.isBuffer(value)) {\n    return returnType ? 'buffer' : bufferToHex(value);\n  }\n\n  if (isAddress(value)) {\n    return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n  }\n\n  if (_.isBoolean(value)) {\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n\n  if (_.isObject(value) && !isBigNumber(value) && !isBN(value)) {\n    return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n  } // if its a negative number, pass it through numberToHex\n\n\n  if (_.isString(value)) {\n    if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n      return returnType ? 'int256' : numberToHex(value);\n    }\n\n    if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n      return returnType ? 'bytes' : value;\n    }\n\n    if (!isFinite(value)) {\n      return returnType ? 'string' : utf8ToHex(value);\n    }\n  }\n\n  return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);\n};\n/* eslint-enable complexity */\n\n\nconst bufferToHex = function (buf) {\n  buf = toBuffer(buf);\n  return `0x${buf.toString('hex')}`;\n};\n/**\n * Convert a input into a Buffer.\n *\n * @method toBuffer\n * @param {Buffer|Array|String|Number|BN|Object} input\n * @return {Buffer}\n */\n\n\nconst toBuffer = function (input) {\n  if (Buffer.isBuffer(input)) return input;\n  if (input === null || input === undefined) return Buffer.alloc(0);\n  if (Array.isArray(input)) return Buffer.from(input);\n  if (isBN(input)) return input.toArrayLike(Buffer);\n\n  if (_.isObject(input)) {\n    if (input.toArray && _.isFunction(input.toArray)) return Buffer.from(input.toArray());\n    throw new Error('To convert an object to a buffer, the toArray function must be implemented inside the object');\n  }\n\n  switch (typeof input) {\n    case 'string':\n      if (isHexStrict(input)) return Buffer.from(makeEven(input).replace('0x', ''), 'hex');\n      throw new Error(\"Failed to convert string to Buffer. 'toBuffer' function only supports 0x-prefixed hex string\");\n\n    case 'number':\n      return numberToBuffer(input);\n  }\n\n  throw new Error(`Not supported type with ${input}`);\n};\n/**\n * Convert a number to a Buffer.\n *\n * @method numberToBuffer\n * @param {Number|String|BN} num\n * @return {Buffer}\n */\n\n\nconst numberToBuffer = function (num) {\n  return Buffer.from(makeEven(numberToHex(num)).replace('0x', ''), 'hex');\n};\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\n\n\nconst isHexStrict = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\n\n\nconst isHex = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\n * Checks if the given string is a hexadecimal transaction hash with or without prefix 0x\n * @deprecated since version v1.5.0\n * @method isTxHash\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\n\n\nconst isTxHash = txHash => isValidHash(txHash);\n/**\n * Checks if the given string is a hexadecimal hash with or without prefix 0x\n * @method isValidHash\n * @param {String} hash given hexadecimal hash\n * @return {Boolean}\n */\n\n\nconst isValidHash = hash => new RegExp(`^(0x|0X)?[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash);\n/**\n * Checks if the given string is a hexadecimal transaction hash that starts with 0x\n * @deprecated since version v1.5.0\n * @method isTxHashStrict\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\n\n\nconst isTxHashStrict = txHash => isValidHashStrict(txHash);\n/**\n * Checks if the given string is a hexadecimal hash with prefix 0x\n * @method isValidHashStrict\n * @param {String} hash given hexadecimal hash\n * @return {Boolean}\n */\n\n\nconst isValidHashStrict = hash => new RegExp(`^(0x|0X)[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash);\n/**\n * Returns true if given string is a valid Klaytn block header bloom.\n *\n * TODO UNDOCUMENTED\n *\n * @method isBloom\n * @param {String} hex encoded bloom filter\n * @return {Boolean}\n */\n\n\nconst isBloom = function (bloom) {\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns true if given string is a valid log topic.\n *\n * TODO UNDOCUMENTED\n *\n * @method isTopic\n * @param {String} hex encoded topic\n * @return {Boolean}\n */\n\n\nconst isTopic = function (topic) {\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst parsePredefinedBlockNumber = blockNumber => {\n  switch (blockNumber) {\n    case 'genesis':\n    case 'earliest':\n      return '0x0';\n\n    default:\n      return blockNumber;\n  }\n};\n\nconst isPredefinedBlockNumber = function (blockNumber) {\n  return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest' || blockNumber === 'genesis';\n};\n/**\n * valid block number should be one of a type below:\n * 1) predefined block number ex:) 'latest', 'earliest', 'pending', 'genesis'\n * 2) hex\n * 3) finite number\n * @param  {String | Number}  blockNumber\n * @return {Boolean}\n */\n\n\nconst isValidBlockNumberCandidate = blockNumber => {\n  return isPredefinedBlockNumber(blockNumber) || isHexStrict(blockNumber) || Number.isFinite(Number(blockNumber));\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */\n\n\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n\nconst sha3 = function (value) {\n  // return null when value is not string type.\n  if (typeof value === 'number') return null;\n\n  if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n    value = hexToBytes(value);\n  }\n\n  if (isBN(value)) {\n    value = value.toString(10);\n  }\n\n  const returnValue = Hash.keccak256(value);\n\n  if (returnValue === SHA3_NULL_S) {\n    return null;\n  }\n\n  return returnValue;\n}; // expose the under the hood keccak256\n\n\nsha3._Hash = Hash;\n\nfunction parsePrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') throw new Error('The private key must be of type string');\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110 && privateKey.length !== 64) {\n    throw new Error(`Invalid private key(${privateKey})`);\n  }\n\n  const parsedPrivateKey = privateKey.slice(0, 64);\n\n  if (!isHex(parsedPrivateKey)) {\n    throw new Error('Invalid private key format : privateKey must be in hex format.');\n  }\n\n  if (privateKey.length !== 110) {\n    return {\n      privateKey: `0x${privateKey}`,\n      address: '',\n      isHumanReadable: false\n    };\n  }\n\n  if (!isKlaytnWalletKey(privateKey)) throw new Error(`Invalid KlaytnWalletKey format.`);\n  const humanReadableFlag = privateKey.slice(66, 68);\n  if (humanReadableFlag === '01') throw new Error('HumanReadableAddress is not supported yet.');\n  const parsedAddress = privateKey.slice(68);\n  return {\n    privateKey: `0x${parsedPrivateKey}`,\n    address: parsedAddress,\n    isHumanReadable: false\n  };\n}\n\nfunction parseKlaytnWalletKey(key) {\n  if (!isKlaytnWalletKey(key)) throw new Error(`Invalid KlaytnWalletKey format: ${key}`);\n  const klaytnWalletKey = key.startsWith('0x') ? key.slice(2) : key;\n  const splitted = klaytnWalletKey.split('0x');\n  return [`0x${splitted[0]}`, `0x${splitted[1]}`, `0x${splitted[2]}`];\n}\n\nconst isKlaytnWalletKey = privateKey => {\n  if (!_.isString(privateKey)) return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110) {\n    return false;\n  }\n\n  const splited = privateKey.split('0x');\n  if (splited.length !== 3) return false;\n\n  for (let i = 0; i < splited.length; i++) {\n    if (!isHex(splited[i])) return false;\n\n    switch (i) {\n      case 0:\n        if (splited[i].length !== 64 || !isValidPrivateKey(splited[i])) return false;\n        break;\n\n      case 1:\n        if (splited[i].length !== 2 || splited[i] !== '00' && splited[i] !== '01') return false;\n        break;\n\n      case 2:\n        if (splited[i].length !== 40 || !isAddress(splited[i])) return false;\n        break;\n    }\n  }\n\n  return true;\n};\n\nfunction isValidPrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey; // Private key validation 1: private key should be string and minimum length of it is 64.\n\n  if (privateKey.length !== 64 || !isHex(privateKey)) return false; // order n value in secp256k1. privateKey should be less than order n value.\n\n  const VALID_PRIVATE_KEY_LIMIT = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141';\n  const VALID_PRIVATE_LOWER_BOUND = '0000000000000000000000000000000000000000000000000000000000000000';\n  return VALID_PRIVATE_LOWER_BOUND < privateKey.toUpperCase() && privateKey.toUpperCase() < VALID_PRIVATE_KEY_LIMIT;\n} // Check is 1)Number string or 2)Hex string or 3)Number.\n\n\nfunction isValidNSHSN(value) {\n  switch (typeof value) {\n    case 'number':\n      if (value < 0) {\n        return false;\n      }\n\n      break;\n\n    case 'string':\n      if (Number(value) != value && !isHexStrict(value)) {\n        return false;\n      }\n\n      break;\n\n    default:\n      return false;\n  }\n\n  return true;\n}\n\nconst rlpEncode = data => RLP.encode(data);\n\nconst rlpDecode = encodedData => RLP.decode(encodedData);\n\nconst xyPointFromPublicKey = pub => {\n  let publicKey = pub;\n  if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(pub);\n  publicKey = publicKey.replace('0x', '');\n  if (publicKey.length === 130 && publicKey.slice(0, 2) === '04') publicKey = publicKey.slice(2);\n  if (publicKey.length !== 128) throw Error('Invalid public key'); // + 2 means '0x'\n\n  const pubX = `0x${publicKey.slice(0, 64).replace(/^0+/, '')}`;\n  const pubY = `0x${publicKey.slice(64).replace(/^0+/, '')}`;\n  return [pubX, pubY];\n};\n\nconst trimLeadingZero = function (hex) {\n  while (hex && hex.startsWith('0x0')) {\n    hex = `0x${hex.slice(3)}`;\n  }\n\n  return hex;\n};\n\nconst makeEven = function (hex) {\n  if (hex.length % 2 === 1) {\n    hex = hex.replace('0x', '0x0');\n  }\n\n  return hex;\n};\n/**\n * Returns an array of signatures.\n *\n * @param {string|object|Array.<string>} signature The address entered by the user for use in creating an account.\n * @return {Array.<string>} the sha3 string\n */\n\n\nconst resolveSignature = signature => {\n  if (_.isArray(signature)) {\n    const [v, r, s] = signature;\n    return [v, r, s];\n  }\n\n  if (_.isObject(signature)) {\n    const v = signature.V || signature.v;\n    const r = signature.R || signature.r;\n    const s = signature.S || signature.s;\n    if (!v || !r || !s) throw new Error('v, r, s fields should exist in signature');\n    return [v, r, s];\n  }\n\n  if (_.isString(signature)) {\n    const v = `0x${signature.slice(64 * 2 + 2)}`;\n    const decoded = Account.decodeSignature(signature);\n    return [v, decoded[1], decoded[2]];\n  }\n};\n\nconst transformSignaturesToObject = signatures => {\n  let isSingular = false;\n  if (!signatures) throw new Error(`Failed to transform signatures to object: invalid signatures ${signatures}`); // Input cases\n  // case 1. '0xf1998...'\n  // case 2. {V: '0x4e44', R: '0x1692a...', S: '0x277b9...'} or {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}\n  // case 3. ['0xf1998...', '0x53fe7...']\n  // case 4. ['0x4e44', '0x1692a...', '0x277b9...']\n  // case 5. [{V: '0x4e44', R: '0x1692a...', S: '0x277b9...'}, {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}]\n  // case 6. [['0x4e44', '0x1692a...', '0x277b9...'], ['0x4e44', '0x1692a...', '0x277b9...']]\n  // Transform a signature to an array of signatures to execute the same logic in the for loop below.\n\n  if (!_.isArray(signatures)) {\n    signatures = [signatures];\n    isSingular = true;\n  } else if (_.isString(signatures[0])) {\n    // This logic is performed for case 3 and case 4.\n    // In case 3, the signature string is in the array.\n    // In case 4, v, r, and s are separately included in the array.\n    // The signature string is a combination of v, r, and s, so the length of the signature string will be longer than 64.\n    // Hence, only case 4 will perform the below logic to form an array of signatures.\n    const stripped = signatures[0].replace('0x', '');\n\n    if (stripped.length <= 64) {\n      signatures = [signatures];\n      isSingular = true;\n    }\n  }\n\n  const ret = [];\n\n  for (const sig of signatures) {\n    const sigObj = {};\n\n    if (_.isArray(sig)) {\n      if (sig.length !== 3) throw new Error(`Failed to transform signatures to object: invalid length of signature (${sig.length})`);\n      if (isEmptySig(sig)) continue;\n      const [V, R, S] = sig;\n      sigObj.V = V;\n      sigObj.R = R;\n      sigObj.S = S;\n    } else if (_.isString(sig)) {\n      const decoded = Account.decodeSignature(sig).map(s => makeEven(trimLeadingZero(s)));\n      sigObj.V = decoded[0];\n      sigObj.R = decoded[1];\n      sigObj.S = decoded[2];\n    } else if (_.isObject(sig)) {\n      Object.keys(sig).map(key => {\n        if (key === 'v' || key === 'V' || key === '_v') {\n          sigObj.V = sig[key];\n        } else if (key === 'r' || key === 'R' || key === '_r') {\n          sigObj.R = sig[key];\n        } else if (key === 's' || key === 'S' || key === '_s') {\n          sigObj.S = sig[key];\n        } else {\n          throw new Error(`Failed to transform signatures to object: invalid key(${key}) is defined in signature object.`);\n        }\n      });\n    } else {\n      throw new Error(`Unsupported signature type: ${typeof sig}`);\n    }\n\n    if (!sigObj.V || !sigObj.R || !sigObj.S) {\n      throw new Error(`Failed to transform signatures to object: invalid signature ${sig}`);\n    }\n\n    Object.keys(sigObj).map(k => {\n      sigObj[k] = trimLeadingZero(sigObj[k]);\n    });\n    ret.push(sigObj);\n  }\n\n  return isSingular ? ret[0] : ret;\n};\n\nconst getTxTypeStringFromRawTransaction = rawTransaction => {\n  if (typeof rawTransaction !== 'string') throw new Error('Invalid raw Tx', rawTransaction);\n  const type = rawTransaction.slice(0, 4);\n  const typeString = txTypeToString[type];\n  return typeString;\n};\n\nconst isValidPublicKey = publicKey => {\n  let pubString = publicKey.replace('0x', '');\n  if (pubString.length === 130 && pubString.slice(0, 2) === '04') pubString = pubString.slice(2);\n  if (pubString.length !== 66 && pubString.length !== 128) return false;\n  if (pubString.length === 66 && !isCompressedPublicKey(pubString)) return false;\n  if (pubString.length === 66) pubString = decompressPublicKey(pubString);\n  const xyPoints = xyPointFromPublicKey(pubString);\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) return false;\n  const point = secp256k1.curve.point(xyPoints[0].slice(2), xyPoints[1].slice(2), true);\n  return secp256k1.keyFromPublic(point).validate().result;\n};\n\nconst isCompressedPublicKey = publicKey => {\n  const compressedIndicators = ['02', '03'];\n  const withoutPrefix = publicKey.replace('0x', '');\n  return withoutPrefix.length === 66 && compressedIndicators.includes(withoutPrefix.slice(0, 2));\n};\n\nconst compressPublicKey = uncompressedPublicKey => {\n  const isAlreadyCompressed = isCompressedPublicKey(uncompressedPublicKey);\n  if (isAlreadyCompressed) return uncompressedPublicKey;\n  const xyPoints = xyPointFromPublicKey(uncompressedPublicKey);\n\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) {\n    throw new Error('invalid public key');\n  }\n\n  const [x, y] = xyPoints;\n  const keyPair = secp256k1.keyPair({\n    pub: {\n      x: x.replace('0x', ''),\n      y: y.replace('0x', '')\n    },\n    pubEnc: 'hex'\n  });\n  const compressedPublicKey = `0x${keyPair.getPublic(true, 'hex')}`;\n  return compressedPublicKey;\n};\n\nconst decompressPublicKey = compressedPublicKey => {\n  if (!isCompressedPublicKey(compressedPublicKey)) {\n    if (!isValidPublicKey(compressedPublicKey)) throw new Error(`Invalid public key`);\n    return compressedPublicKey;\n  }\n\n  const compressedWithoutPrefix = compressedPublicKey.replace('0x', '');\n  const curve = secp256k1.curve;\n  const decoded = curve.decodePoint(compressedWithoutPrefix, 'hex');\n  const hexEncoded = decoded.encode('hex').slice(2);\n  return `0x${hexEncoded}`;\n};\n\nconst isContractDeployment = txObject => {\n  if (txObject.type) {\n    if (txObject.type.includes('SMART_CONTRACT_DEPLOY') || txObject.type.includes('SmartContractDeploy')) return true;\n    if (txObject.type !== 'LEGACY' && txObject.type !== 'TxTypeLegacyTransaction') return false;\n  }\n\n  if (txObject.data && txObject.data !== '0x' && (!txObject.to || txObject.to === '0x')) return true;\n  return false;\n};\n\nconst isValidRole = role => {\n  switch (role) {\n    case 'roleTransactionKey':\n    case 'roleAccountUpdateKey':\n    case 'roleFeePayerKey':\n    case 'transactionKey':\n    case 'updateKey':\n    case 'feePayerKey':\n      return true;\n  }\n\n  return false;\n}; // ['0x01', '0x', '0x]\n// [['0x01', '0x', '0x]]\n// '0x....'\n// { v: '0x01', r: '0x', s:'0x' }\n// SignatureData { _v: '0x01', _r: '0x', _s:'0x' }\n// [SignatureData { _v: '0x01', _r: '0x', _s:'0x' }]\n\n\nconst isEmptySig = sig => {\n  let sigs = sig; // Convert to array format\n\n  if (!_.isArray(sig)) sigs = resolveSignature(sigs); // Format to two-dimentional array\n\n  if (_.isString(sigs[0])) sigs = [sigs];\n\n  for (let s of sigs) {\n    if (!_.isArray(s)) s = resolveSignature(s);\n    if (s.length !== 3) throw new Error(`Invalid signatures length: ${s.length}`);\n    if (s[0] !== '0x01' || s[1] !== '0x' || s[2] !== '0x') return false;\n  }\n\n  return true;\n};\n\nconst hashMessage = data => {\n  const message = isHexStrict(data) ? hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`;\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n\nconst recover = (message, signature, preFixed = false) => {\n  if (!preFixed) {\n    message = hashMessage(message);\n  }\n\n  return Account.recover(message, Account.encodeSignature(signature.encode())).toLowerCase();\n};\n\nmodule.exports = {\n  BN: BN,\n  isBN: isBN,\n  isBigNumber: isBigNumber,\n  toBN: toBN,\n  isAddress: isAddress,\n  isBloom: isBloom,\n  // TODO UNDOCUMENTED\n  isTopic: isTopic,\n  // TODO UNDOCUMENTED\n  checkAddressChecksum: checkAddressChecksum,\n  utf8ToHex: utf8ToHex,\n  hexToUtf8: hexToUtf8,\n  hexToNumber: hexToNumber,\n  hexToNumberString: hexToNumberString,\n  numberToHex: numberToHex,\n  toHex: toHex,\n  bufferToHex: bufferToHex,\n  toBuffer: toBuffer,\n  numberToBuffer: numberToBuffer,\n  hexToBytes: hexToBytes,\n  bytesToHex: bytesToHex,\n  isHex: isHex,\n  isHexStrict: isHexStrict,\n  leftPad: leftPad,\n  rightPad: rightPad,\n  toTwosComplement: toTwosComplement,\n  sha3: sha3,\n  parsePredefinedBlockNumber: parsePredefinedBlockNumber,\n  isPredefinedBlockNumber: isPredefinedBlockNumber,\n  isValidBlockNumberCandidate: isValidBlockNumberCandidate,\n  isValidPrivateKey: isValidPrivateKey,\n  isValidNSHSN: isValidNSHSN,\n  parsePrivateKey: parsePrivateKey,\n  parseKlaytnWalletKey: parseKlaytnWalletKey,\n  isKlaytnWalletKey: isKlaytnWalletKey,\n  isContractDeployment: isContractDeployment,\n  rlpEncode: rlpEncode,\n  rlpDecode: rlpDecode,\n  xyPointFromPublicKey: xyPointFromPublicKey,\n  resolveSignature: resolveSignature,\n  transformSignaturesToObject: transformSignaturesToObject,\n  getTxTypeStringFromRawTransaction,\n  trimLeadingZero,\n  makeEven,\n  txTypeToString,\n  isValidPublicKey,\n  isCompressedPublicKey,\n  compressPublicKey,\n  decompressPublicKey,\n  isTxHash,\n  isTxHashStrict,\n  isValidHash,\n  isValidHashStrict,\n  isValidRole: isValidRole,\n  isEmptySig: isEmptySig,\n  hashMessage: hashMessage,\n  recover: recover\n};","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-utils/src/utils.js"],"names":["_","require","BN","BigNumber","numberToBN","utf8","Hash","RLP","Account","elliptic","secp256k1","ec","txTypeToString","HASH_LENGTH","isBN","object","isBigNumber","num","toBN","number","apply","arguments","e","Error","toTwosComplement","toTwos","toString","isAddress","address","test","checkAddressChecksum","replace","addressHash","sha3","toLowerCase","i","parseInt","toUpperCase","leftPad","string","chars","sign","hasPrefix","padding","length","Array","join","rightPad","utf8ToHex","str","encode","hex","split","reverse","code","charCodeAt","n","hexToUtf8","isHexStrict","l","substr","String","fromCharCode","decode","hexToNumber","value","toNumber","hexToNumberString","numberToHex","isNull","isUndefined","isFinite","result","lt","bytesToHex","bytes","push","hexToBytes","c","toHex","returnType","Buffer","isBuffer","bufferToHex","isBoolean","isObject","JSON","stringify","isString","indexOf","buf","toBuffer","input","undefined","alloc","isArray","from","toArrayLike","toArray","isFunction","makeEven","numberToBuffer","isNumber","isHex","isTxHash","txHash","isValidHash","hash","RegExp","isTxHashStrict","isValidHashStrict","isBloom","bloom","isTopic","topic","parsePredefinedBlockNumber","blockNumber","isPredefinedBlockNumber","isValidBlockNumberCandidate","Number","SHA3_NULL_S","returnValue","keccak256","_Hash","parsePrivateKey","privateKey","has0xPrefix","slice","parsedPrivateKey","isHumanReadable","isKlaytnWalletKey","humanReadableFlag","parsedAddress","parseKlaytnWalletKey","key","klaytnWalletKey","startsWith","splitted","splited","isValidPrivateKey","VALID_PRIVATE_KEY_LIMIT","VALID_PRIVATE_LOWER_BOUND","isValidNSHSN","rlpEncode","data","rlpDecode","encodedData","xyPointFromPublicKey","pub","publicKey","isCompressedPublicKey","decompressPublicKey","pubX","pubY","trimLeadingZero","resolveSignature","signature","v","r","s","V","R","S","decoded","decodeSignature","transformSignaturesToObject","signatures","isSingular","stripped","ret","sig","sigObj","isEmptySig","map","Object","keys","k","getTxTypeStringFromRawTransaction","rawTransaction","type","typeString","isValidPublicKey","pubString","xyPoints","point","curve","keyFromPublic","validate","compressedIndicators","withoutPrefix","includes","compressPublicKey","uncompressedPublicKey","isAlreadyCompressed","x","y","keyPair","pubEnc","compressedPublicKey","getPublic","compressedWithoutPrefix","decodePoint","hexEncoded","isContractDeployment","txObject","to","isValidRole","role","sigs","hashMessage","message","messageBuffer","preamble","preambleBuffer","klayMessage","concat","recover","preFixed","encodeSignature","module","exports"],"mappings":"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","sourcesContent":["/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-utils/src/utils.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n/**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst BN = require('bn.js')\nconst BigNumber = require('bignumber.js')\nconst numberToBN = require('number-to-bn')\nconst utf8 = require('utf8')\nconst Hash = require('eth-lib/lib/hash')\nconst RLP = require('eth-lib/lib/rlp')\nconst Account = require('eth-lib/lib/account')\n\nconst elliptic = require('elliptic')\n\nconst secp256k1 = new elliptic.ec('secp256k1')\n\nconst txTypeToString = {\n    '0x20': 'ACCOUNT_UPDATE',\n    '0x21': 'FEE_DELEGATED_ACCOUNT_UPDATE',\n    '0x22': 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO',\n    '0x08': 'VALUE_TRANSFER',\n    '0x10': 'VALUE_TRANSFER_MEMO',\n    '0x09': 'FEE_DELEGATED_VALUE_TRANSFER',\n    '0x0a': 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO',\n    '0x11': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO',\n    '0x12': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO',\n    '0x28': 'SMART_CONTRACT_DEPLOY',\n    '0x29': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY',\n    '0x2a': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO',\n    '0x30': 'SMART_CONTRACT_EXECUTION',\n    '0x31': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION',\n    '0x32': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO',\n    '0x38': 'CANCEL',\n    '0x39': 'FEE_DELEGATED_CANCEL',\n    '0x3a': 'FEE_DELEGATED_CANCEL_WITH_RATIO',\n    '0x48': 'CHAIN_DATA_ANCHORING',\n}\n\nconst HASH_LENGTH = 66\n\n/**\n * Returns true if object is BN, otherwise false\n *\n * @method isBN\n * @param {Object} object\n * @return {Boolean}\n */\nconst isBN = function(object) {\n    return BN.isBN(object)\n}\n\n/**\n * Returns true if object is BigNumber, otherwise false\n *\n * @method isBigNumber\n * @param {Object} object\n * @return {Boolean}\n */\nconst isBigNumber = function(num) {\n    return BigNumber.isBigNumber(num)\n}\n\n/**\n * Takes an input and transforms it into an BN\n *\n * @method toBN\n * @param {Number|String|BN} number, string, HEX string or BN\n * @return {BN} BN\n */\nfunction toBN(number) {\n    try {\n        return numberToBN.apply(null, arguments)\n    } catch (e) {\n        throw new Error(`${e} Given value: \"${number}\"`)\n    }\n}\n\n/**\n * Takes and input transforms it into BN and if it is negative value, into two's complement\n *\n * @method toTwosComplement\n * @param {Number|String|BN} number\n * @return {String}\n */\nconst toTwosComplement = function(number) {\n    return `0x${toBN(number)\n        .toTwos(256)\n        .toString(16, 64)}`\n}\n\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nconst isAddress = function(address) {\n    // check if it has the basic requirements of an address\n    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false\n        // If it's ALL lowercase or ALL upppercase\n    }\n    if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n        return true\n        // Otherwise check each case\n    }\n    return checkAddressChecksum(address)\n}\n\n/**\n * Checks if the given string is a checksummed address\n *\n * @method checkAddressChecksum\n * @param {String} address the given HEX address\n * @return {Boolean}\n */\nconst checkAddressChecksum = function(address) {\n    // Check each case\n    address = address.replace(/^0x/i, '')\n    const addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '')\n\n    for (let i = 0; i < 40; i++) {\n        // the nth letter should be uppercase if the nth digit of casemap is 1\n        if (\n            (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) ||\n            (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\n/**\n * Should be called to pad string to expected length\n *\n * @method leftPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nconst leftPad = function(string, chars, sign) {\n    const hasPrefix = /^0x/i.test(string) || typeof string === 'number'\n    string = string.toString(16).replace(/^0x/i, '')\n\n    const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0\n\n    return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string\n}\n\n/**\n * Should be called to pad string to expected length\n *\n * @method rightPad\n * @param {String} string to be padded\n * @param {Number} chars that result string should have\n * @param {String} sign, by default 0\n * @returns {String} right aligned string\n */\nconst rightPad = function(string, chars, sign) {\n    const hasPrefix = /^0x/i.test(string) || typeof string === 'number'\n    string = string.toString(16).replace(/^0x/i, '')\n\n    const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0\n\n    return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0')\n}\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n *\n * @method utf8ToHex\n * @param {String} str\n * @returns {String} hex representation of input string\n */\nconst utf8ToHex = function(str) {\n    str = utf8.encode(str)\n    let hex = ''\n\n    // remove \\u0000 padding from either side\n    str = str.replace(/^(?:\\u0000)*/, '')\n    str = str\n        .split('')\n        .reverse()\n        .join('')\n    str = str.replace(/^(?:\\u0000)*/, '')\n    str = str\n        .split('')\n        .reverse()\n        .join('')\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i)\n        // if (code !== 0) {\n        const n = code.toString(16)\n        hex += n.length < 2 ? `0${n}` : n\n        // }\n    }\n\n    return `0x${hex}`\n}\n\n/**\n * Should be called to get utf8 from it's hex representation\n *\n * @method hexToUtf8\n * @param {String} hex\n * @returns {String} ascii string representation of hex value\n */\nconst hexToUtf8 = function(hex) {\n    if (!isHexStrict(hex)) {\n        throw new Error(`The parameter \"${hex}\" must be a valid HEX string.`)\n    }\n\n    let str = ''\n    let code = 0\n    hex = hex.replace(/^0x/i, '')\n\n    // remove 00 padding from either side\n    hex = hex.replace(/^(?:00)*/, '')\n    hex = hex\n        .split('')\n        .reverse()\n        .join('')\n    hex = hex.replace(/^(?:00)*/, '')\n    hex = hex\n        .split('')\n        .reverse()\n        .join('')\n\n    const l = hex.length\n\n    for (let i = 0; i < l; i += 2) {\n        code = parseInt(hex.substr(i, 2), 16)\n        // if (code !== 0) {\n        str += String.fromCharCode(code)\n        // }\n    }\n\n    return utf8.decode(str)\n}\n\n/**\n * Converts value to it's number representation\n *\n * @method hexToNumber\n * @param {String|Number|BN} value\n * @return {String}\n */\nconst hexToNumber = function(value) {\n    if (!value) return value\n    return toBN(value).toNumber()\n}\n\n/**\n * Converts value to it's decimal representation in string\n *\n * @method hexToNumberString\n * @param {String|Number|BN} value\n * @return {String}\n */\nconst hexToNumberString = function(value) {\n    if (!value) return value\n\n    return toBN(value).toString(10)\n}\n\n/**\n * Converts value to it's hex representation\n *\n * @method numberToHex\n * @param {String|Number|BN} value\n * @return {String}\n */\nconst numberToHex = function(value) {\n    if (_.isNull(value) || _.isUndefined(value)) {\n        return value\n    }\n\n    if (!isFinite(value) && !isHexStrict(value)) {\n        throw new Error(`Given input \"${value}\" is not a number.`)\n    }\n\n    const number = toBN(value)\n    const result = number.toString(16)\n\n    return number.lt(new BN(0)) ? `-0x${result.substr(1)}` : `0x${result}`\n}\n\n/**\n * Convert a byte array to a hex string\n *\n * Note: Implementation from crypto-js\n *\n * @method bytesToHex\n * @param {Array} bytes\n * @return {String} the hex string\n */\nconst bytesToHex = function(bytes) {\n    const hex = []\n    for (let i = 0; i < bytes.length; i++) {\n        // eslint-disable-next-line no-bitwise\n        hex.push((bytes[i] >>> 4).toString(16))\n\n        // eslint-disable-next-line no-bitwise\n        hex.push((bytes[i] & 0xf).toString(16))\n    }\n    return `0x${hex.join('')}`\n}\n\n/**\n * Convert a hex string to a byte array\n *\n * Note: Implementation from crypto-js\n *\n * @method hexToBytes\n * @param {string} hex\n * @return {Array} the byte array\n */\nconst hexToBytes = function(hex) {\n    hex = hex.toString(16)\n\n    if (!isHexStrict(hex)) {\n        throw new Error(`Given value \"${hex}\" is not a valid hex string.`)\n    }\n\n    hex = hex.replace(/^0x/i, '')\n\n    const bytes = []\n    for (let c = 0; c < hex.length; c += 2) {\n        bytes.push(parseInt(hex.substr(c, 2), 16))\n    }\n    return bytes\n}\n\n/**\n * Auto converts any given value into it's hex representation.\n *\n * And even stringifys objects before.\n *\n * @method toHex\n * @param {String|Number|BN|Object} value\n * @param {Boolean} returnType\n * @return {String}\n */\n/* eslint-disable complexity */\nconst toHex = function(value, returnType) {\n    if (Buffer.isBuffer(value)) {\n        return returnType ? 'buffer' : bufferToHex(value)\n    }\n    if (isAddress(value)) {\n        return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`\n    }\n\n    if (_.isBoolean(value)) {\n        return returnType ? 'bool' : value ? '0x01' : '0x00'\n    }\n\n    if (_.isObject(value) && !isBigNumber(value) && !isBN(value)) {\n        return returnType ? 'string' : utf8ToHex(JSON.stringify(value))\n    }\n\n    // if its a negative number, pass it through numberToHex\n    if (_.isString(value)) {\n        if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n            return returnType ? 'int256' : numberToHex(value)\n        }\n        if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n            return returnType ? 'bytes' : value\n        }\n        if (!isFinite(value)) {\n            return returnType ? 'string' : utf8ToHex(value)\n        }\n    }\n\n    return returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value)\n}\n/* eslint-enable complexity */\n\nconst bufferToHex = function(buf) {\n    buf = toBuffer(buf)\n    return `0x${buf.toString('hex')}`\n}\n\n/**\n * Convert a input into a Buffer.\n *\n * @method toBuffer\n * @param {Buffer|Array|String|Number|BN|Object} input\n * @return {Buffer}\n */\nconst toBuffer = function(input) {\n    if (Buffer.isBuffer(input)) return input\n    if (input === null || input === undefined) return Buffer.alloc(0)\n    if (Array.isArray(input)) return Buffer.from(input)\n    if (isBN(input)) return input.toArrayLike(Buffer)\n    if (_.isObject(input)) {\n        if (input.toArray && _.isFunction(input.toArray)) return Buffer.from(input.toArray())\n        throw new Error('To convert an object to a buffer, the toArray function must be implemented inside the object')\n    }\n\n    switch (typeof input) {\n        case 'string':\n            if (isHexStrict(input)) return Buffer.from(makeEven(input).replace('0x', ''), 'hex')\n            throw new Error(\"Failed to convert string to Buffer. 'toBuffer' function only supports 0x-prefixed hex string\")\n        case 'number':\n            return numberToBuffer(input)\n    }\n    throw new Error(`Not supported type with ${input}`)\n}\n\n/**\n * Convert a number to a Buffer.\n *\n * @method numberToBuffer\n * @param {Number|String|BN} num\n * @return {Buffer}\n */\nconst numberToBuffer = function(num) {\n    return Buffer.from(makeEven(numberToHex(num)).replace('0x', ''), 'hex')\n}\n\n/**\n * Check if string is HEX, requires a 0x in front\n *\n * @method isHexStrict\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nconst isHexStrict = function(hex) {\n    return (_.isString(hex) || _.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex)\n}\n\n/**\n * Check if string is HEX\n *\n * @method isHex\n * @param {String} hex to be checked\n * @returns {Boolean}\n */\nconst isHex = function(hex) {\n    return (_.isString(hex) || _.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex)\n}\n\n/**\n * Checks if the given string is a hexadecimal transaction hash with or without prefix 0x\n * @deprecated since version v1.5.0\n * @method isTxHash\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\nconst isTxHash = txHash => isValidHash(txHash)\n\n/**\n * Checks if the given string is a hexadecimal hash with or without prefix 0x\n * @method isValidHash\n * @param {String} hash given hexadecimal hash\n * @return {Boolean}\n */\nconst isValidHash = hash => new RegExp(`^(0x|0X)?[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash)\n\n/**\n * Checks if the given string is a hexadecimal transaction hash that starts with 0x\n * @deprecated since version v1.5.0\n * @method isTxHashStrict\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\nconst isTxHashStrict = txHash => isValidHashStrict(txHash)\n\n/**\n * Checks if the given string is a hexadecimal hash with prefix 0x\n * @method isValidHashStrict\n * @param {String} hash given hexadecimal hash\n * @return {Boolean}\n */\nconst isValidHashStrict = hash => new RegExp(`^(0x|0X)[0-9a-fA-F]{${HASH_LENGTH - 2}}$`).test(hash)\n\n/**\n * Returns true if given string is a valid Klaytn block header bloom.\n *\n * TODO UNDOCUMENTED\n *\n * @method isBloom\n * @param {String} hex encoded bloom filter\n * @return {Boolean}\n */\nconst isBloom = function(bloom) {\n    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n        return false\n    }\n    if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n        return true\n    }\n    return false\n}\n\n/**\n * Returns true if given string is a valid log topic.\n *\n * TODO UNDOCUMENTED\n *\n * @method isTopic\n * @param {String} hex encoded topic\n * @return {Boolean}\n */\nconst isTopic = function(topic) {\n    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n        return false\n    }\n    if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n        return true\n    }\n    return false\n}\n\nconst parsePredefinedBlockNumber = blockNumber => {\n    switch (blockNumber) {\n        case 'genesis':\n        case 'earliest':\n            return '0x0'\n        default:\n            return blockNumber\n    }\n}\n\nconst isPredefinedBlockNumber = function(blockNumber) {\n    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest' || blockNumber === 'genesis'\n}\n\n/**\n * valid block number should be one of a type below:\n * 1) predefined block number ex:) 'latest', 'earliest', 'pending', 'genesis'\n * 2) hex\n * 3) finite number\n * @param  {String | Number}  blockNumber\n * @return {Boolean}\n */\nconst isValidBlockNumberCandidate = blockNumber => {\n    return isPredefinedBlockNumber(blockNumber) || isHexStrict(blockNumber) || Number.isFinite(Number(blockNumber))\n}\n\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @method sha3\n * @return {String} the sha3 string\n */\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n\nconst sha3 = function(value) {\n    // return null when value is not string type.\n    if (typeof value === 'number') return null\n\n    if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n        value = hexToBytes(value)\n    }\n\n    if (isBN(value)) {\n        value = value.toString(10)\n    }\n\n    const returnValue = Hash.keccak256(value)\n\n    if (returnValue === SHA3_NULL_S) {\n        return null\n    }\n    return returnValue\n}\n// expose the under the hood keccak256\nsha3._Hash = Hash\n\nfunction parsePrivateKey(privateKey) {\n    if (typeof privateKey !== 'string') throw new Error('The private key must be of type string')\n\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\n\n    if (privateKey.length !== 110 && privateKey.length !== 64) {\n        throw new Error(`Invalid private key(${privateKey})`)\n    }\n\n    const parsedPrivateKey = privateKey.slice(0, 64)\n\n    if (!isHex(parsedPrivateKey)) {\n        throw new Error('Invalid private key format : privateKey must be in hex format.')\n    }\n\n    if (privateKey.length !== 110) {\n        return {\n            privateKey: `0x${privateKey}`,\n            address: '',\n            isHumanReadable: false,\n        }\n    }\n\n    if (!isKlaytnWalletKey(privateKey)) throw new Error(`Invalid KlaytnWalletKey format.`)\n\n    const humanReadableFlag = privateKey.slice(66, 68)\n    if (humanReadableFlag === '01') throw new Error('HumanReadableAddress is not supported yet.')\n    const parsedAddress = privateKey.slice(68)\n    return {\n        privateKey: `0x${parsedPrivateKey}`,\n        address: parsedAddress,\n        isHumanReadable: false,\n    }\n}\n\nfunction parseKlaytnWalletKey(key) {\n    if (!isKlaytnWalletKey(key)) throw new Error(`Invalid KlaytnWalletKey format: ${key}`)\n    const klaytnWalletKey = key.startsWith('0x') ? key.slice(2) : key\n    const splitted = klaytnWalletKey.split('0x')\n    return [`0x${splitted[0]}`, `0x${splitted[1]}`, `0x${splitted[2]}`]\n}\n\nconst isKlaytnWalletKey = privateKey => {\n    if (!_.isString(privateKey)) return false\n\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\n\n    if (privateKey.length !== 110) {\n        return false\n    }\n\n    const splited = privateKey.split('0x')\n    if (splited.length !== 3) return false\n\n    for (let i = 0; i < splited.length; i++) {\n        if (!isHex(splited[i])) return false\n        switch (i) {\n            case 0:\n                if (splited[i].length !== 64 || !isValidPrivateKey(splited[i])) return false\n                break\n            case 1:\n                if (splited[i].length !== 2 || (splited[i] !== '00' && splited[i] !== '01')) return false\n                break\n            case 2:\n                if (splited[i].length !== 40 || !isAddress(splited[i])) return false\n                break\n        }\n    }\n\n    return true\n}\n\nfunction isValidPrivateKey(privateKey) {\n    if (typeof privateKey !== 'string') return false\n\n    const has0xPrefix = privateKey.slice(0, 2) === '0x'\n    privateKey = has0xPrefix ? privateKey.slice(2) : privateKey\n    // Private key validation 1: private key should be string and minimum length of it is 64.\n    if (privateKey.length !== 64 || !isHex(privateKey)) return false\n\n    // order n value in secp256k1. privateKey should be less than order n value.\n    const VALID_PRIVATE_KEY_LIMIT = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141'\n    const VALID_PRIVATE_LOWER_BOUND = '0000000000000000000000000000000000000000000000000000000000000000'\n    return VALID_PRIVATE_LOWER_BOUND < privateKey.toUpperCase() && privateKey.toUpperCase() < VALID_PRIVATE_KEY_LIMIT\n}\n\n// Check is 1)Number string or 2)Hex string or 3)Number.\nfunction isValidNSHSN(value) {\n    switch (typeof value) {\n        case 'number':\n            if (value < 0) {\n                return false\n            }\n            break\n        case 'string':\n            if (Number(value) != value && !isHexStrict(value)) {\n                return false\n            }\n            break\n        default:\n            return false\n    }\n\n    return true\n}\n\nconst rlpEncode = data => RLP.encode(data)\n\nconst rlpDecode = encodedData => RLP.decode(encodedData)\n\nconst xyPointFromPublicKey = pub => {\n    let publicKey = pub\n    if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(pub)\n\n    publicKey = publicKey.replace('0x', '')\n    if (publicKey.length === 130 && publicKey.slice(0, 2) === '04') publicKey = publicKey.slice(2)\n    if (publicKey.length !== 128) throw Error('Invalid public key') // + 2 means '0x'\n\n    const pubX = `0x${publicKey.slice(0, 64).replace(/^0+/, '')}`\n    const pubY = `0x${publicKey.slice(64).replace(/^0+/, '')}`\n    return [pubX, pubY]\n}\n\nconst trimLeadingZero = function(hex) {\n    while (hex && hex.startsWith('0x0')) {\n        hex = `0x${hex.slice(3)}`\n    }\n    return hex\n}\n\nconst makeEven = function(hex) {\n    if (hex.length % 2 === 1) {\n        hex = hex.replace('0x', '0x0')\n    }\n    return hex\n}\n\n/**\n * Returns an array of signatures.\n *\n * @param {string|object|Array.<string>} signature The address entered by the user for use in creating an account.\n * @return {Array.<string>} the sha3 string\n */\nconst resolveSignature = signature => {\n    if (_.isArray(signature)) {\n        const [v, r, s] = signature\n        return [v, r, s]\n    }\n\n    if (_.isObject(signature)) {\n        const v = signature.V || signature.v\n        const r = signature.R || signature.r\n        const s = signature.S || signature.s\n        if (!v || !r || !s) throw new Error('v, r, s fields should exist in signature')\n\n        return [v, r, s]\n    }\n\n    if (_.isString(signature)) {\n        const v = `0x${signature.slice(64 * 2 + 2)}`\n        const decoded = Account.decodeSignature(signature)\n        return [v, decoded[1], decoded[2]]\n    }\n}\n\nconst transformSignaturesToObject = signatures => {\n    let isSingular = false\n\n    if (!signatures) throw new Error(`Failed to transform signatures to object: invalid signatures ${signatures}`)\n\n    // Input cases\n    // case 1. '0xf1998...'\n    // case 2. {V: '0x4e44', R: '0x1692a...', S: '0x277b9...'} or {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}\n    // case 3. ['0xf1998...', '0x53fe7...']\n    // case 4. ['0x4e44', '0x1692a...', '0x277b9...']\n    // case 5. [{V: '0x4e44', R: '0x1692a...', S: '0x277b9...'}, {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}]\n    // case 6. [['0x4e44', '0x1692a...', '0x277b9...'], ['0x4e44', '0x1692a...', '0x277b9...']]\n\n    // Transform a signature to an array of signatures to execute the same logic in the for loop below.\n    if (!_.isArray(signatures)) {\n        signatures = [signatures]\n        isSingular = true\n    } else if (_.isString(signatures[0])) {\n        // This logic is performed for case 3 and case 4.\n        // In case 3, the signature string is in the array.\n        // In case 4, v, r, and s are separately included in the array.\n        // The signature string is a combination of v, r, and s, so the length of the signature string will be longer than 64.\n        // Hence, only case 4 will perform the below logic to form an array of signatures.\n        const stripped = signatures[0].replace('0x', '')\n        if (stripped.length <= 64) {\n            signatures = [signatures]\n            isSingular = true\n        }\n    }\n\n    const ret = []\n\n    for (const sig of signatures) {\n        const sigObj = {}\n        if (_.isArray(sig)) {\n            if (sig.length !== 3) throw new Error(`Failed to transform signatures to object: invalid length of signature (${sig.length})`)\n            if (isEmptySig(sig)) continue\n            const [V, R, S] = sig\n            sigObj.V = V\n            sigObj.R = R\n            sigObj.S = S\n        } else if (_.isString(sig)) {\n            const decoded = Account.decodeSignature(sig).map(s => makeEven(trimLeadingZero(s)))\n            sigObj.V = decoded[0]\n            sigObj.R = decoded[1]\n            sigObj.S = decoded[2]\n        } else if (_.isObject(sig)) {\n            Object.keys(sig).map(key => {\n                if (key === 'v' || key === 'V' || key === '_v') {\n                    sigObj.V = sig[key]\n                } else if (key === 'r' || key === 'R' || key === '_r') {\n                    sigObj.R = sig[key]\n                } else if (key === 's' || key === 'S' || key === '_s') {\n                    sigObj.S = sig[key]\n                } else {\n                    throw new Error(`Failed to transform signatures to object: invalid key(${key}) is defined in signature object.`)\n                }\n            })\n        } else {\n            throw new Error(`Unsupported signature type: ${typeof sig}`)\n        }\n\n        if (!sigObj.V || !sigObj.R || !sigObj.S) {\n            throw new Error(`Failed to transform signatures to object: invalid signature ${sig}`)\n        }\n\n        Object.keys(sigObj).map(k => {\n            sigObj[k] = trimLeadingZero(sigObj[k])\n        })\n        ret.push(sigObj)\n    }\n\n    return isSingular ? ret[0] : ret\n}\n\nconst getTxTypeStringFromRawTransaction = rawTransaction => {\n    if (typeof rawTransaction !== 'string') throw new Error('Invalid raw Tx', rawTransaction)\n\n    const type = rawTransaction.slice(0, 4)\n\n    const typeString = txTypeToString[type]\n\n    return typeString\n}\n\nconst isValidPublicKey = publicKey => {\n    let pubString = publicKey.replace('0x', '')\n\n    if (pubString.length === 130 && pubString.slice(0, 2) === '04') pubString = pubString.slice(2)\n\n    if (pubString.length !== 66 && pubString.length !== 128) return false\n\n    if (pubString.length === 66 && !isCompressedPublicKey(pubString)) return false\n\n    if (pubString.length === 66) pubString = decompressPublicKey(pubString)\n\n    const xyPoints = xyPointFromPublicKey(pubString)\n    if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) return false\n\n    const point = secp256k1.curve.point(xyPoints[0].slice(2), xyPoints[1].slice(2), true)\n    return secp256k1.keyFromPublic(point).validate().result\n}\n\nconst isCompressedPublicKey = publicKey => {\n    const compressedIndicators = ['02', '03']\n    const withoutPrefix = publicKey.replace('0x', '')\n    return withoutPrefix.length === 66 && compressedIndicators.includes(withoutPrefix.slice(0, 2))\n}\n\nconst compressPublicKey = uncompressedPublicKey => {\n    const isAlreadyCompressed = isCompressedPublicKey(uncompressedPublicKey)\n\n    if (isAlreadyCompressed) return uncompressedPublicKey\n\n    const xyPoints = xyPointFromPublicKey(uncompressedPublicKey)\n\n    if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) {\n        throw new Error('invalid public key')\n    }\n\n    const [x, y] = xyPoints\n\n    const keyPair = secp256k1.keyPair({\n        pub: {\n            x: x.replace('0x', ''),\n            y: y.replace('0x', ''),\n        },\n        pubEnc: 'hex',\n    })\n\n    const compressedPublicKey = `0x${keyPair.getPublic(true, 'hex')}`\n\n    return compressedPublicKey\n}\n\nconst decompressPublicKey = compressedPublicKey => {\n    if (!isCompressedPublicKey(compressedPublicKey)) {\n        if (!isValidPublicKey(compressedPublicKey)) throw new Error(`Invalid public key`)\n        return compressedPublicKey\n    }\n\n    const compressedWithoutPrefix = compressedPublicKey.replace('0x', '')\n\n    const curve = secp256k1.curve\n    const decoded = curve.decodePoint(compressedWithoutPrefix, 'hex')\n    const hexEncoded = decoded.encode('hex').slice(2)\n\n    return `0x${hexEncoded}`\n}\n\nconst isContractDeployment = txObject => {\n    if (txObject.type) {\n        if (txObject.type.includes('SMART_CONTRACT_DEPLOY') || txObject.type.includes('SmartContractDeploy')) return true\n        if (txObject.type !== 'LEGACY' && txObject.type !== 'TxTypeLegacyTransaction') return false\n    }\n\n    if (txObject.data && txObject.data !== '0x' && (!txObject.to || txObject.to === '0x')) return true\n\n    return false\n}\n\nconst isValidRole = role => {\n    switch (role) {\n        case 'roleTransactionKey':\n        case 'roleAccountUpdateKey':\n        case 'roleFeePayerKey':\n        case 'transactionKey':\n        case 'updateKey':\n        case 'feePayerKey':\n            return true\n    }\n    return false\n}\n\n// ['0x01', '0x', '0x]\n// [['0x01', '0x', '0x]]\n// '0x....'\n// { v: '0x01', r: '0x', s:'0x' }\n// SignatureData { _v: '0x01', _r: '0x', _s:'0x' }\n// [SignatureData { _v: '0x01', _r: '0x', _s:'0x' }]\nconst isEmptySig = sig => {\n    let sigs = sig\n\n    // Convert to array format\n    if (!_.isArray(sig)) sigs = resolveSignature(sigs)\n    // Format to two-dimentional array\n    if (_.isString(sigs[0])) sigs = [sigs]\n\n    for (let s of sigs) {\n        if (!_.isArray(s)) s = resolveSignature(s)\n        if (s.length !== 3) throw new Error(`Invalid signatures length: ${s.length}`)\n        if (s[0] !== '0x01' || s[1] !== '0x' || s[2] !== '0x') return false\n    }\n\n    return true\n}\n\nconst hashMessage = data => {\n    const message = isHexStrict(data) ? hexToBytes(data) : data\n    const messageBuffer = Buffer.from(message)\n    const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`\n    const preambleBuffer = Buffer.from(preamble)\n    // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n    const klayMessage = Buffer.concat([preambleBuffer, messageBuffer])\n    // Finally, run keccak256 on klayMessage.\n    return Hash.keccak256(klayMessage)\n}\n\nconst recover = (message, signature, preFixed = false) => {\n    if (!preFixed) {\n        message = hashMessage(message)\n    }\n\n    return Account.recover(message, Account.encodeSignature(signature.encode())).toLowerCase()\n}\n\nmodule.exports = {\n    BN: BN,\n    isBN: isBN,\n    isBigNumber: isBigNumber,\n    toBN: toBN,\n    isAddress: isAddress,\n    isBloom: isBloom, // TODO UNDOCUMENTED\n    isTopic: isTopic, // TODO UNDOCUMENTED\n    checkAddressChecksum: checkAddressChecksum,\n    utf8ToHex: utf8ToHex,\n    hexToUtf8: hexToUtf8,\n    hexToNumber: hexToNumber,\n    hexToNumberString: hexToNumberString,\n    numberToHex: numberToHex,\n    toHex: toHex,\n    bufferToHex: bufferToHex,\n    toBuffer: toBuffer,\n    numberToBuffer: numberToBuffer,\n    hexToBytes: hexToBytes,\n    bytesToHex: bytesToHex,\n    isHex: isHex,\n    isHexStrict: isHexStrict,\n    leftPad: leftPad,\n    rightPad: rightPad,\n    toTwosComplement: toTwosComplement,\n    sha3: sha3,\n    parsePredefinedBlockNumber: parsePredefinedBlockNumber,\n    isPredefinedBlockNumber: isPredefinedBlockNumber,\n    isValidBlockNumberCandidate: isValidBlockNumberCandidate,\n    isValidPrivateKey: isValidPrivateKey,\n    isValidNSHSN: isValidNSHSN,\n    parsePrivateKey: parsePrivateKey,\n    parseKlaytnWalletKey: parseKlaytnWalletKey,\n    isKlaytnWalletKey: isKlaytnWalletKey,\n    isContractDeployment: isContractDeployment,\n\n    rlpEncode: rlpEncode,\n    rlpDecode: rlpDecode,\n    xyPointFromPublicKey: xyPointFromPublicKey,\n    resolveSignature: resolveSignature,\n    transformSignaturesToObject: transformSignaturesToObject,\n    getTxTypeStringFromRawTransaction,\n    trimLeadingZero,\n    makeEven,\n    txTypeToString,\n    isValidPublicKey,\n    isCompressedPublicKey,\n    compressPublicKey,\n    decompressPublicKey,\n    isTxHash,\n    isTxHashStrict,\n    isValidHash,\n    isValidHashStrict,\n\n    isValidRole: isValidRole,\n\n    isEmptySig: isEmptySig,\n\n    hashMessage: hashMessage,\n    recover: recover,\n}\n"]},"metadata":{},"sourceType":"script"}