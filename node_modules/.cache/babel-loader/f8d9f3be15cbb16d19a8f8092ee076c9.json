{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst Keyring = require('./keyring/keyringFactory');\n\nconst SingleKeyring = require('./keyring/singleKeyring');\n\nconst MultipleKeyring = require('./keyring/multipleKeyring');\n\nconst RoleBasedKeyring = require('./keyring/roleBasedKeyring');\n\nconst utils = require('../../caver-utils/src');\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\n\n\nclass KeyringContainer {\n  /**\n   * creates a keyringContainer.\n   * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n   */\n  constructor(keyrings) {\n    keyrings = keyrings || [];\n    this._addressKeyringMap = new Map(); // add keyrings to keyringContainer\n\n    for (const keyring of keyrings) {\n      this.add(keyring);\n    }\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get length() {\n    return this._addressKeyringMap.size;\n  }\n  /**\n   * generates keyrings in the keyringContainer with randomly generated key pairs.\n   *\n   * @param {number} numberOfKeyrings The number of keyrings to create.\n   * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n   * @return {Array.<string>}\n   */\n\n\n  generate(numberOfKeyrings, entropy) {\n    const addresses = [];\n\n    for (let i = 0; i < numberOfKeyrings; ++i) {\n      addresses.push(this.add(Keyring.generate(entropy)).address);\n    }\n\n    return addresses;\n  }\n  /**\n   * creates a keyring instance with given parameters and adds it to the keyringContainer.\n   * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n   *\n   * @param {string} address The address of the keyring.\n   * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n   * @return {Keyring}\n   */\n\n\n  newKeyring(address, key) {\n    // The format of key parameter can be\n    // 1. single private key string   => `0x{private key}`\n    // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n    // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n    let keyring;\n    if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key);\n\n    if (_.isArray(key)) {\n      if (key.length === 0) throw new Error(`Insufficient private key information: Empty array`);\n\n      if (_.isArray(key[0])) {\n        keyring = Keyring.createWithRoleBasedKey(address, key);\n      } else {\n        keyring = Keyring.createWithMultipleKey(address, key);\n      }\n    }\n\n    if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring)) throw new Error(`Unsupported type value: ${key} (type:${typeof key})`);\n    return this.add(keyring);\n  }\n  /**\n   * updates the keyring inside the keyringContainer.\n   * Query the keyring to be updated from keyringContainer with the keyring's address,\n   * and an error occurs when the keyring is not found in the keyringContainer.\n   *\n   * @param {Keyring} keyring The keyring with new key.\n   * @return {Keyring}\n   */\n\n\n  updateKeyring(keyring) {\n    const founded = this._addressKeyringMap.get(keyring.address.toLowerCase());\n\n    if (founded === undefined) throw new Error(`Failed to find keyring to update`);\n    this.remove(founded.address);\n    this.add(keyring);\n    return keyring;\n  }\n  /**\n   * Get the keyring in container corresponding to the address\n   *\n   * @param {string} address The address of keyring to query.\n   * @return {Keyring}\n   */\n\n\n  getKeyring(address) {\n    if (!utils.isAddress(address)) throw new Error(`Invalid address ${address}. To get keyring from wallet, you need to pass a valid address string as a parameter.`);\n\n    const founded = this._addressKeyringMap.get(address.toLowerCase());\n\n    return founded;\n  }\n  /**\n   * Returns whether the keyring corresponding to the address exists\n   *\n   * @param {string} address The address of keyring to check existence.\n   * @return {Keyring}\n   */\n\n\n  isExisted(address) {\n    return this.getKeyring(address) !== undefined;\n  }\n  /**\n   * adds a keyring to the keyringContainer.\n   *\n   * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n   * @return {Keyring}\n   */\n\n\n  add(keyring) {\n    if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined) throw new Error(`Duplicate Account ${keyring.address}. Please use updateKeyring() instead.`);\n    const keyringToAdd = keyring.copy();\n\n    this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd);\n\n    return keyringToAdd;\n  }\n  /**\n   * deletes the keyring that associates with the given address from keyringContainer.\n   *\n   * @param {string} address An address of the keyring to be deleted in keyringContainer.\n   * @return {boolean}\n   */\n\n\n  remove(address) {\n    let keyringToRemove;\n\n    if (utils.isAddress(address)) {\n      keyringToRemove = this.getKeyring(address);\n    } else {\n      throw new Error(`To remove the keyring, the first parameter should be an address string.`);\n    }\n\n    if (keyringToRemove === undefined) return false; // deallocate keyring object created for keyringContainer\n\n    keyringToRemove.keys = null;\n\n    this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase());\n\n    return true;\n  }\n  /**\n   * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {string} data The data string to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] An index of key to use for signing.\n   * @return {object}\n   */\n\n\n  signMessage(address, data, role, index) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`);\n    return keyring.signMessage(data, role, index);\n  }\n  /**\n   * signs the transaction using one key and return the transactionHash\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {Transaction} transaction A transaction object.\n   * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] A function to return hash of transaction.\n   * @return {Transaction}\n   */\n\n\n  async sign(address, transaction, index, hasher) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`);\n    const signed = await transaction.sign(keyring, index, hasher);\n    return signed;\n  }\n  /**\n   * signs the transaction as a fee payer using one key and return the transactionHash\n   *\n   * @param {string} address An address of keyring in keyringContainer.\n   * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n   * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n   * @param {function} [hasher] A function to return hash of transaction.\n   * @return {Transaction}\n   */\n\n\n  async signAsFeePayer(address, transaction, index, hasher) {\n    const keyring = this.getKeyring(address);\n    if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`);\n    const signed = await transaction.signAsFeePayer(keyring, index, hasher);\n    return signed;\n  }\n\n}\n\nmodule.exports = KeyringContainer;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-wallet/src/index.js"],"names":["_","require","Keyring","SingleKeyring","MultipleKeyring","RoleBasedKeyring","utils","KeyringContainer","constructor","keyrings","_addressKeyringMap","Map","keyring","add","length","size","generate","numberOfKeyrings","entropy","addresses","i","push","address","newKeyring","key","isString","createWithSingleKey","isArray","Error","createWithRoleBasedKey","createWithMultipleKey","updateKeyring","founded","get","toLowerCase","undefined","remove","getKeyring","isAddress","isExisted","keyringToAdd","copy","set","keyringToRemove","keys","delete","signMessage","data","role","index","sign","transaction","hasher","signed","signAsFeePayer","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst Keyring = require('./keyring/keyringFactory')\nconst SingleKeyring = require('./keyring/singleKeyring')\nconst MultipleKeyring = require('./keyring/multipleKeyring')\nconst RoleBasedKeyring = require('./keyring/roleBasedKeyring')\nconst utils = require('../../caver-utils/src')\n\n/**\n * representing a Keyring container which manages keyrings.\n * @class\n */\nclass KeyringContainer {\n    /**\n     * creates a keyringContainer.\n     * @param {Array.<Keyring>} keyrings - The keyrings to be managed in KeyringContainer.\n     */\n    constructor(keyrings) {\n        keyrings = keyrings || []\n        this._addressKeyringMap = new Map()\n\n        // add keyrings to keyringContainer\n        for (const keyring of keyrings) {\n            this.add(keyring)\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._addressKeyringMap.size\n    }\n\n    /**\n     * generates keyrings in the keyringContainer with randomly generated key pairs.\n     *\n     * @param {number} numberOfKeyrings The number of keyrings to create.\n     * @param {string} [entropy] A random string to increase entropy. If undefined, a random string will be generated using randomHex.\n     * @return {Array.<string>}\n     */\n    generate(numberOfKeyrings, entropy) {\n        const addresses = []\n        for (let i = 0; i < numberOfKeyrings; ++i) {\n            addresses.push(this.add(Keyring.generate(entropy)).address)\n        }\n        return addresses\n    }\n\n    /**\n     * creates a keyring instance with given parameters and adds it to the keyringContainer.\n     * KeyringContainer manages Keyring instance using Map <string:Keyring> which has address as key value.\n     *\n     * @param {string} address The address of the keyring.\n     * @param {string|Array.<string>|Array.<Array.<string>>} key Private key string(s) to use in keyring. If different keys are used for each role, key must be defined as a two-dimensional array.\n     * @return {Keyring}\n     */\n    newKeyring(address, key) {\n        // The format of key parameter can be\n        // 1. single private key string   => `0x{private key}`\n        // 2. multiple private key string =>[`0x{private key}`, `0x{private key}`, ...]\n        // 3. role based private keys     => [[`0x{private key}`, `0x{private key}`, ...], [], [`0x{private key}`]]\n\n        let keyring\n\n        if (_.isString(key)) keyring = Keyring.createWithSingleKey(address, key)\n\n        if (_.isArray(key)) {\n            if (key.length === 0) throw new Error(`Insufficient private key information: Empty array`)\n            if (_.isArray(key[0])) {\n                keyring = Keyring.createWithRoleBasedKey(address, key)\n            } else {\n                keyring = Keyring.createWithMultipleKey(address, key)\n            }\n        }\n\n        if (!(keyring instanceof SingleKeyring) && !(keyring instanceof MultipleKeyring) && !(keyring instanceof RoleBasedKeyring))\n            throw new Error(`Unsupported type value: ${key} (type:${typeof key})`)\n\n        return this.add(keyring)\n    }\n\n    /**\n     * updates the keyring inside the keyringContainer.\n     * Query the keyring to be updated from keyringContainer with the keyring's address,\n     * and an error occurs when the keyring is not found in the keyringContainer.\n     *\n     * @param {Keyring} keyring The keyring with new key.\n     * @return {Keyring}\n     */\n    updateKeyring(keyring) {\n        const founded = this._addressKeyringMap.get(keyring.address.toLowerCase())\n        if (founded === undefined) throw new Error(`Failed to find keyring to update`)\n\n        this.remove(founded.address)\n        this.add(keyring)\n\n        return keyring\n    }\n\n    /**\n     * Get the keyring in container corresponding to the address\n     *\n     * @param {string} address The address of keyring to query.\n     * @return {Keyring}\n     */\n    getKeyring(address) {\n        if (!utils.isAddress(address))\n            throw new Error(\n                `Invalid address ${address}. To get keyring from wallet, you need to pass a valid address string as a parameter.`\n            )\n\n        const founded = this._addressKeyringMap.get(address.toLowerCase())\n\n        return founded\n    }\n\n    /**\n     * Returns whether the keyring corresponding to the address exists\n     *\n     * @param {string} address The address of keyring to check existence.\n     * @return {Keyring}\n     */\n    isExisted(address) {\n        return this.getKeyring(address) !== undefined\n    }\n\n    /**\n     * adds a keyring to the keyringContainer.\n     *\n     * @param {Keyring} keyring A keyring instance to add to keyringContainer.\n     * @return {Keyring}\n     */\n    add(keyring) {\n        if (this._addressKeyringMap.get(keyring.address.toLowerCase()) !== undefined)\n            throw new Error(`Duplicate Account ${keyring.address}. Please use updateKeyring() instead.`)\n\n        const keyringToAdd = keyring.copy()\n\n        this._addressKeyringMap.set(keyringToAdd.address.toLowerCase(), keyringToAdd)\n\n        return keyringToAdd\n    }\n\n    /**\n     * deletes the keyring that associates with the given address from keyringContainer.\n     *\n     * @param {string} address An address of the keyring to be deleted in keyringContainer.\n     * @return {boolean}\n     */\n    remove(address) {\n        let keyringToRemove\n        if (utils.isAddress(address)) {\n            keyringToRemove = this.getKeyring(address)\n        } else {\n            throw new Error(`To remove the keyring, the first parameter should be an address string.`)\n        }\n\n        if (keyringToRemove === undefined) return false\n\n        // deallocate keyring object created for keyringContainer\n        keyringToRemove.keys = null\n        this._addressKeyringMap.delete(keyringToRemove.address.toLowerCase())\n\n        return true\n    }\n\n    /**\n     * signs with data and returns the result object that includes `signature`, `message` and `messageHash`\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {string} data The data string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] An index of key to use for signing.\n     * @return {object}\n     */\n    signMessage(address, data, role, index) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        return keyring.signMessage(data, role, index)\n    }\n\n    /**\n     * signs the transaction using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n    async sign(address, transaction, index, hasher) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        const signed = await transaction.sign(keyring, index, hasher)\n\n        return signed\n    }\n\n    /**\n     * signs the transaction as a fee payer using one key and return the transactionHash\n     *\n     * @param {string} address An address of keyring in keyringContainer.\n     * @param {Transaction} transaction A transaction object. This should be `FEE_DELEGATED` type.\n     * @param {number} [index] An index of key to use for signing. If index is undefined, all private keys in keyring will be used.\n     * @param {function} [hasher] A function to return hash of transaction.\n     * @return {Transaction}\n     */\n    async signAsFeePayer(address, transaction, index, hasher) {\n        const keyring = this.getKeyring(address)\n        if (keyring === undefined) throw new Error(`Failed to find keyring from wallet with ${address}`)\n        const signed = await transaction.signAsFeePayer(keyring, index, hasher)\n\n        return signed\n    }\n}\n\nmodule.exports = KeyringContainer\n"]},"metadata":{},"sourceType":"script"}