{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst configure = require('../lib/configure');\n\nconst {\n  objectToQuery\n} = require('../lib/querystring');\n\nconst {\n  ok\n} = require('../lib/fetch');\n\nmodule.exports = configure(({\n  fetch,\n  apiUrl,\n  apiPath,\n  headers\n}) => {\n  return async (topic, data, options) => {\n    options = options || {};\n    let qs = objectToQuery(options.qs);\n    qs = qs ? `&${qs.slice(1)}` : qs;\n    const url = `${apiUrl}${apiPath}/pubsub/pub?arg=${encodeURIComponent(topic)}&arg=${encodeBuffer(Buffer.from(data))}${qs}`;\n    const res = await ok(fetch(url, {\n      method: 'POST',\n      signal: options.signal,\n      headers: options.headers || headers\n    }));\n    return res.text();\n  };\n});\n\nfunction encodeBuffer(buf) {\n  let uriEncoded = '';\n\n  for (const byte of buf) {\n    // https://tools.ietf.org/html/rfc3986#page-14\n    // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),\n    // underscore (%5F), or tilde (%7E)\n    if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n      uriEncoded += String.fromCharCode(byte);\n    } else {\n      uriEncoded += `%${byte.toString(16).padStart(2, '0')}`;\n    }\n  }\n\n  return uriEncoded;\n}","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/ipfs-http-client-lite/src/pubsub/publish.js"],"names":["Buffer","require","configure","objectToQuery","ok","module","exports","fetch","apiUrl","apiPath","headers","topic","data","options","qs","slice","url","encodeURIComponent","encodeBuffer","from","res","method","signal","text","buf","uriEncoded","byte","String","fromCharCode","toString","padStart"],"mappings":"AAAA;;AAEA,MAAM;AAAEA,EAAAA;AAAF,IAAaC,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,kBAAD,CAAzB;;AACA,MAAM;AAAEE,EAAAA;AAAF,IAAoBF,OAAO,CAAC,oBAAD,CAAjC;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAASH,OAAO,CAAC,cAAD,CAAtB;;AAEAI,MAAM,CAACC,OAAP,GAAiBJ,SAAS,CAAC,CAAC;AAAEK,EAAAA,KAAF;AAASC,EAAAA,MAAT;AAAiBC,EAAAA,OAAjB;AAA0BC,EAAAA;AAA1B,CAAD,KAAyC;AAClE,SAAO,OAAOC,KAAP,EAAcC,IAAd,EAAoBC,OAApB,KAAgC;AACrCA,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEA,QAAIC,EAAE,GAAGX,aAAa,CAACU,OAAO,CAACC,EAAT,CAAtB;AACAA,IAAAA,EAAE,GAAGA,EAAE,GAAI,IAAGA,EAAE,CAACC,KAAH,CAAS,CAAT,CAAY,EAAnB,GAAuBD,EAA9B;AAEA,UAAME,GAAG,GAAI,GAAER,MAAO,GAAEC,OAAQ,mBAAkBQ,kBAAkB,CAACN,KAAD,CAAQ,QAAOO,YAAY,CAAClB,MAAM,CAACmB,IAAP,CAAYP,IAAZ,CAAD,CAAoB,GAAEE,EAAG,EAAxH;AACA,UAAMM,GAAG,GAAG,MAAMhB,EAAE,CAACG,KAAK,CAACS,GAAD,EAAM;AAC9BK,MAAAA,MAAM,EAAE,MADsB;AAE9BC,MAAAA,MAAM,EAAET,OAAO,CAACS,MAFc;AAG9BZ,MAAAA,OAAO,EAAEG,OAAO,CAACH,OAAR,IAAmBA;AAHE,KAAN,CAAN,CAApB;AAMA,WAAOU,GAAG,CAACG,IAAJ,EAAP;AACD,GAdD;AAeD,CAhByB,CAA1B;;AAkBA,SAASL,YAAT,CAAuBM,GAAvB,EAA4B;AAC1B,MAAIC,UAAU,GAAG,EAAjB;;AACA,OAAK,MAAMC,IAAX,IAAmBF,GAAnB,EAAwB;AACtB;AACA;AACA;AACA,QACGE,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAAzB,IACCA,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IADzB,IAECA,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAFzB,IAGCA,IAAI,KAAK,IAHV,IAICA,IAAI,KAAK,IAJV,IAKCA,IAAI,KAAK,IALV,IAMCA,IAAI,KAAK,IAPZ,EAQE;AACAD,MAAAA,UAAU,IAAIE,MAAM,CAACC,YAAP,CAAoBF,IAApB,CAAd;AACD,KAVD,MAUO;AACLD,MAAAA,UAAU,IAAK,IAAGC,IAAI,CAACG,QAAL,CAAc,EAAd,EAAkBC,QAAlB,CAA2B,CAA3B,EAA8B,GAA9B,CAAmC,EAArD;AACD;AACF;;AACD,SAAOL,UAAP;AACD","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst configure = require('../lib/configure')\nconst { objectToQuery } = require('../lib/querystring')\nconst { ok } = require('../lib/fetch')\n\nmodule.exports = configure(({ fetch, apiUrl, apiPath, headers }) => {\n  return async (topic, data, options) => {\n    options = options || {}\n\n    let qs = objectToQuery(options.qs)\n    qs = qs ? `&${qs.slice(1)}` : qs\n\n    const url = `${apiUrl}${apiPath}/pubsub/pub?arg=${encodeURIComponent(topic)}&arg=${encodeBuffer(Buffer.from(data))}${qs}`\n    const res = await ok(fetch(url, {\n      method: 'POST',\n      signal: options.signal,\n      headers: options.headers || headers\n    }))\n\n    return res.text()\n  }\n})\n\nfunction encodeBuffer (buf) {\n  let uriEncoded = ''\n  for (const byte of buf) {\n    // https://tools.ietf.org/html/rfc3986#page-14\n    // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),\n    // underscore (%5F), or tilde (%7E)\n    if (\n      (byte >= 0x41 && byte <= 0x5A) ||\n      (byte >= 0x61 && byte <= 0x7A) ||\n      (byte >= 0x30 && byte <= 0x39) ||\n      (byte === 0x2D) ||\n      (byte === 0x2E) ||\n      (byte === 0x5F) ||\n      (byte === 0x7E)\n    ) {\n      uriEncoded += String.fromCharCode(byte)\n    } else {\n      uriEncoded += `%${byte.toString(16).padStart(2, '0')}`\n    }\n  }\n  return uriEncoded\n}\n"]},"metadata":{},"sourceType":"script"}