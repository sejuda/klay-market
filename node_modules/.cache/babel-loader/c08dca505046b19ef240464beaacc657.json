{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst {\n  KEY_ROLE\n} = require('./keyringHelper');\n\nconst Account = require('../../../caver-account');\n\nconst {\n  validateForSigning,\n  validateIndexWithKeys,\n  encryptKey,\n  formatEncrypted\n} = require('./keyringHelper');\n/**\n * representing a Keyring which includes `address` and a `private key`.\n * @class\n */\n\n\nclass SingleKeyring {\n  /**\n   * creates a SingleKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {string|PrivateKey} key - The key to use in SingleKeyring.\n   */\n  constructor(address, key) {\n    this.address = address;\n    this.key = key;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n\n  set address(addressInput) {\n    if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`);\n    this._address = utils.addHexPrefix(addressInput).toLowerCase();\n  }\n  /**\n   * @type {PrivateKey}\n   */\n\n\n  get key() {\n    return this._key;\n  }\n\n  set key(keyInput) {\n    if (keyInput === null) {\n      this._key = null;\n      return;\n    }\n\n    this._key = keyInput instanceof PrivateKey ? keyInput : new PrivateKey(keyInput);\n  }\n  /**\n   * returns public key string.\n   *\n   * @param {boolean} [compressed] Whether in compressed format or not.\n   * @return {string}\n   */\n\n\n  getPublicKey(compressed = false) {\n    return this.key.getPublicKey(compressed);\n  }\n  /**\n   * returns a copied singleKeyring instance\n   *\n   * @return {SingleKeyring}\n   */\n\n\n  copy() {\n    return new SingleKeyring(this.address, this.key);\n  }\n  /**\n   * signs with transactionHash with a key and returns signature(s).\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId specific to the network.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {Array.<string>|Array.<Array.<string>>}\n   */\n\n\n  sign(transactionHash, chainId, role, index) {\n    validateForSigning(transactionHash, chainId);\n    const key = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, 1);\n      return key.sign(transactionHash, chainId);\n    }\n\n    return [key.sign(transactionHash, chainId)];\n  }\n  /**\n   * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n   *\n   * @param {string} message The message string to sign.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used.\n   * @return {object}\n   */\n\n\n  signMessage(message, role, index) {\n    if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`);\n    const messageHash = utils.hashMessage(message);\n    const key = this.getKeyByRole(role);\n    const signatures = [];\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, 1);\n    }\n\n    signatures.push(key.signMessage(messageHash));\n    return {\n      messageHash,\n      signatures,\n      message\n    };\n  }\n  /**\n   * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n   *\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @return {Array.<PrivateKey>}\n   */\n\n\n  getKeyByRole(role) {\n    if (role === undefined) throw new Error(`role should be defined.`);\n    if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`);\n    return this.key;\n  }\n  /**\n   * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n   *\n   * @return {string}\n   */\n\n\n  getKlaytnWalletKey() {\n    return `${this.key.privateKey}0x00${this.address}`;\n  }\n  /**\n   * returns an instance of Account.\n   *\n   * @return {Account}\n   */\n\n\n  toAccount() {\n    if (!this.key) throw new Error(`Failed to create Account instance: Empty key in keyring.`);\n    const publicKey = this.getPublicKey();\n    return Account.createWithAccountKeyPublic(this.address, publicKey);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v4 object.\n   *\n   * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n   * @return {object}\n   */\n\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n\n\n  encrypt(password, options = {}) {\n    let keyring = [];\n    keyring = encryptKey(this.key, password, options);\n    return formatEncrypted(4, this.address, keyring, options);\n  }\n  /**\n   * encrypts a keyring and returns a keystore v3 object.\n   *\n   * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n   * @return {object}\n   */\n\n\n  encryptV3(password, options) {\n    options = options || {};\n    const crypto = encryptKey(this.key, password, options)[0];\n    return formatEncrypted(3, this.address, crypto, options);\n  }\n  /**\n   * returns true if keyring has decoupled key.\n   *\n   * @return {boolean}\n   */\n\n\n  isDecoupled() {\n    return this.address.toLowerCase() !== this.key.getDerivedAddress().toLowerCase();\n  }\n\n}\n\nmodule.exports = SingleKeyring;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-wallet/src/keyring/singleKeyring.js"],"names":["utils","require","PrivateKey","KEY_ROLE","Account","validateForSigning","validateIndexWithKeys","encryptKey","formatEncrypted","SingleKeyring","constructor","address","key","_address","addressInput","isAddress","Error","addHexPrefix","toLowerCase","_key","keyInput","getPublicKey","compressed","copy","sign","transactionHash","chainId","role","index","getKeyByRole","undefined","signMessage","message","messageHash","hashMessage","signatures","push","roleLast","getKlaytnWalletKey","privateKey","toAccount","publicKey","createWithAccountKeyPublic","encrypt","password","options","keyring","encryptV3","crypto","isDecoupled","getDerivedAddress","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst utils = require('../../../caver-utils')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE } = require('./keyringHelper')\nconst Account = require('../../../caver-account')\nconst { validateForSigning, validateIndexWithKeys, encryptKey, formatEncrypted } = require('./keyringHelper')\n\n/**\n * representing a Keyring which includes `address` and a `private key`.\n * @class\n */\nclass SingleKeyring {\n    /**\n     * creates a SingleKeyring.\n     * @param {string} address - The address of keyring.\n     * @param {string|PrivateKey} key - The key to use in SingleKeyring.\n     */\n    constructor(address, key) {\n        this.address = address\n        this.key = key\n    }\n\n    /**\n     * @type {string}\n     */\n    get address() {\n        return this._address\n    }\n\n    set address(addressInput) {\n        if (!utils.isAddress(addressInput)) throw new Error(`Invalid address : ${addressInput}`)\n\n        this._address = utils.addHexPrefix(addressInput).toLowerCase()\n    }\n\n    /**\n     * @type {PrivateKey}\n     */\n    get key() {\n        return this._key\n    }\n\n    set key(keyInput) {\n        if (keyInput === null) {\n            this._key = null\n            return\n        }\n        this._key = keyInput instanceof PrivateKey ? keyInput : new PrivateKey(keyInput)\n    }\n\n    /**\n     * returns public key string.\n     *\n     * @param {boolean} [compressed] Whether in compressed format or not.\n     * @return {string}\n     */\n    getPublicKey(compressed = false) {\n        return this.key.getPublicKey(compressed)\n    }\n\n    /**\n     * returns a copied singleKeyring instance\n     *\n     * @return {SingleKeyring}\n     */\n    copy() {\n        return new SingleKeyring(this.address, this.key)\n    }\n\n    /**\n     * signs with transactionHash with a key and returns signature(s).\n     *\n     * @param {string} transactionHash The hash of transaction.\n     * @param {string|number} chainId The chainId specific to the network.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n     * @return {Array.<string>|Array.<Array.<string>>}\n     */\n    sign(transactionHash, chainId, role, index) {\n        validateForSigning(transactionHash, chainId)\n\n        const key = this.getKeyByRole(role)\n\n        if (index !== undefined) {\n            validateIndexWithKeys(index, 1)\n            return key.sign(transactionHash, chainId)\n        }\n\n        return [key.sign(transactionHash, chainId)]\n    }\n\n    /**\n     * signs with hashed message and returns result object that includes `signatures`, `message` and `messageHash`\n     *\n     * @param {string} message The message string to sign.\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @param {number} [index] The index of the key to be used.\n     * @return {object}\n     */\n    signMessage(message, role, index) {\n        if (role === undefined) throw new Error(`role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.`)\n        const messageHash = utils.hashMessage(message)\n\n        const key = this.getKeyByRole(role)\n        const signatures = []\n        if (index !== undefined) {\n            validateIndexWithKeys(index, 1)\n        }\n\n        signatures.push(key.signMessage(messageHash))\n        return {\n            messageHash,\n            signatures,\n            message,\n        }\n    }\n\n    /**\n     * returns keys by role. If the key of the role passed as parameter is empty, the default key is returned.\n     *\n     * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n     * @return {Array.<PrivateKey>}\n     */\n    getKeyByRole(role) {\n        if (role === undefined) throw new Error(`role should be defined.`)\n        if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(`Invalid role number: ${role}`)\n        return this.key\n    }\n\n    /**\n     * returns KlaytnWalletKey format. If keyring uses more than one private key, this function will throw error.\n     *\n     * @return {string}\n     */\n    getKlaytnWalletKey() {\n        return `${this.key.privateKey}0x00${this.address}`\n    }\n\n    /**\n     * returns an instance of Account.\n     *\n     * @return {Account}\n     */\n    toAccount() {\n        if (!this.key) throw new Error(`Failed to create Account instance: Empty key in keyring.`)\n        const publicKey = this.getPublicKey()\n        return Account.createWithAccountKeyPublic(this.address, publicKey)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v4 object.\n     *\n     * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. Also address can be defined specifically in options object.\n     * @return {object}\n     */\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    encrypt(password, options = {}) {\n        let keyring = []\n        keyring = encryptKey(this.key, password, options)\n        return formatEncrypted(4, this.address, keyring, options)\n    }\n\n    /**\n     * encrypts a keyring and returns a keystore v3 object.\n     *\n     * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n     * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n     * @return {object}\n     */\n    encryptV3(password, options) {\n        options = options || {}\n\n        const crypto = encryptKey(this.key, password, options)[0]\n\n        return formatEncrypted(3, this.address, crypto, options)\n    }\n\n    /**\n     * returns true if keyring has decoupled key.\n     *\n     * @return {boolean}\n     */\n    isDecoupled() {\n        return this.address.toLowerCase() !== this.key.getDerivedAddress().toLowerCase()\n    }\n}\n\nmodule.exports = SingleKeyring\n"]},"metadata":{},"sourceType":"script"}