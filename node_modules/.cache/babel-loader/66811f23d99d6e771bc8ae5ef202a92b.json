{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst Promise = require('any-promise'); // account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\n\n\nconst AccountLib = require('eth-lib/lib/account');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Nat = require('eth-lib/lib/nat');\n\nconst Bytes = require('eth-lib/lib/bytes');\n\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto');\n\nconst uuid = require('uuid');\n\nconst elliptic = require('elliptic');\n\nconst scrypt = require('scrypt-js');\n\nconst utils = require('../../../caver-utils');\n\nconst helpers = require('../../../caver-core-helpers');\n\nconst Method = require('../../../caver-core-method');\n\nconst core = require('../../../caver-core');\n\nconst {\n  encodeRLPByTxType,\n  makeRawTransaction,\n  getSenderTxHash,\n  decodeFromRawTransaction,\n  splitFeePayer,\n  extractSignatures\n} = require('./makeRawTransaction');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\n\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic');\n\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig');\n\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased');\n\nconst {\n  AccountKeyEnum\n} = require('./accountKey/accountKeyEnum');\n\nconst Account = require('./account/account');\n\nconst AccountForUpdate = require('./account/accountForUpdate');\n\nconst {\n  rpc\n} = require('../../../caver-rtm');\n\nconst isNot = function (value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nfunction coverInitialTxValue(tx) {\n  if (typeof tx !== 'object') throw new Error('Invalid transaction');\n\n  if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n    tx.to = tx.to || '0x';\n    tx.data = utils.addHexPrefix(tx.data || '0x');\n  }\n\n  tx.chainId = utils.numberToHex(tx.chainId);\n  return tx;\n}\n/**\n * resolveArgsForSignTransaction parse arguments for signTransaction.\n *\n * @method resolveArgsForSignTransaction\n * @param {Object} args Parameters of signTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransaction(args) {\n  if (args.length === 0 || args.length > 3) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 2\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (args.length === 2) {\n    if (_.isFunction(args[1])) {\n      callback = args[1];\n    } else {\n      privateKey = args[1];\n    }\n  } else if (args.length === 3) {\n    if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[1];\n    callback = args[2];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    callback\n  };\n}\n/**\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\n *\n * @method resolveArgsForFeePayerSignTransaction\n * @param {Object} args Parameters of feePayerSignTransaction.\n * @return {Object}\n */\n\n\nfunction resolveArgsForFeePayerSignTransaction(args) {\n  if (args.length === 0 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  } // privateKey and callback are optional parameter\n  // \"args.length === 3\" means that user sent parameter privateKey or callback\n\n\n  const tx = args[0];\n  const feePayer = args[1];\n  let privateKey;\n  let callback;\n\n  if (!tx || !_.isObject(tx) && !_.isString(tx)) {\n    throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string');\n  }\n\n  if (!utils.isAddress(feePayer)) {\n    throw new Error(`Invalid fee payer address : ${feePayer}`);\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      privateKey = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the private key is invalid');\n    }\n\n    privateKey = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    tx,\n    privateKey,\n    feePayer,\n    callback\n  };\n}\n/**\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\n *\n * @method resolveArgsForSignTransactionWithHash\n * @param {Object} args Parameters of signTransactionWithHash.\n * @return {Object}\n */\n\n\nfunction resolveArgsForSignTransactionWithHash(args) {\n  if (args.length < 2 || args.length > 4) {\n    throw new Error('Invalid parameter: The number of parameters is invalid.');\n  }\n\n  const hash = args[0];\n  const privateKeys = args[1];\n  let chainId;\n  let callback;\n\n  if (!hash) {\n    throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.');\n  }\n\n  if (!utils.isValidHashStrict(hash)) {\n    throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.');\n  }\n\n  if (!privateKeys || !Array.isArray(privateKeys) && !_.isString(privateKeys)) {\n    throw new Error(`Invalid parameter: The private key should be a private key string or an array of private keys.`);\n  }\n\n  if (args.length === 3) {\n    if (_.isFunction(args[2])) {\n      callback = args[2];\n    } else {\n      chainId = args[2];\n    }\n  } else if (args.length === 4) {\n    if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n      throw new Error('Invalid parameter: The parameter for the chain id is invalid.');\n    }\n\n    chainId = args[2];\n    callback = args[3];\n  } // For handling when callback is undefined.\n\n\n  callback = callback || function () {};\n\n  return {\n    hash,\n    privateKeys,\n    chainId,\n    callback\n  };\n}\n\nfunction encryptKey(privateKey, password, options) {\n  const encryptedArray = [];\n  if (!privateKey) return encryptedArray;\n  const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  for (let i = 0; i < privateKeyArray.length; i++) {\n    const salt = options.salt || cryp.randomBytes(32);\n    const iv = options.iv || cryp.randomBytes(16);\n    let derivedKey;\n    const kdf = options.kdf || 'scrypt';\n    const kdfparams = {\n      dklen: options.dklen || 32,\n      salt: salt.toString('hex')\n    };\n    /**\n     * Supported kdf modules are the following:\n     * 1) pbkdf2\n     * 2) scrypt - default\n     */\n\n    if (kdf === 'pbkdf2') {\n      kdfparams.c = options.c || 262144;\n      kdfparams.prf = 'hmac-sha256';\n      derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n    } else if (kdf === 'scrypt') {\n      // FIXME: support progress reporting callback\n      kdfparams.n = options.n || 4096; // 2048 4096 8192 16384\n\n      kdfparams.r = options.r || 8;\n      kdfparams.p = options.p || 1;\n      derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n    } else {\n      throw new Error('Unsupported kdf');\n    }\n\n    const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n    if (!cipher) {\n      throw new Error('Unsupported cipher');\n    }\n\n    const ciphertext = Buffer.from([...cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), ...cipher.final()]);\n    const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n    encryptedArray.push({\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf,\n      kdfparams,\n      mac: mac.toString('hex')\n    });\n  }\n\n  return encryptedArray;\n}\n\nconst Accounts = function Accounts(...args) {\n  const _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, args); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]; // attach methods to this._klaytnCall\n\n  this._klaytnCall = {};\n\n  _.each(_klaytnCall, function (method) {\n    method = new Method(method);\n    method.attachToObject(_this._klaytnCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  const _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    const roleKey = _this._getRoleKey(tx, account);\n\n    return _this.signTransaction(tx, roleKey, callback);\n  };\n\n  account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n    return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account.privateKey);\n  };\n\n  account.encrypt = function encrypt(password, options = {}) {\n    options.address = account.address;\n    return _this.encrypt(account.keys, password, options);\n  };\n\n  account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n    return genKlaytnWalletKeyStringFromAccount(account);\n  };\n\n  return account;\n};\n/**\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\n *\n * @method _determineAddress\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\n * @param {String} addressFromKey Address extracted from key.\n * @param {String} userInputAddress Address passed as parameter by user.\n * @return {String}\n */\n\n\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n  if (userInputAddress) {\n    if (addressFromKey && addressFromKey !== userInputAddress) {\n      throw new Error('The address extracted from the private key does not match the address received as the input value.');\n    }\n\n    if (!utils.isAddress(userInputAddress)) {\n      throw new Error('The address received as the input value is invalid.');\n    }\n\n    return userInputAddress;\n  }\n\n  if (addressFromKey) {\n    if (!utils.isAddress(addressFromKey)) {\n      throw new Error('The address extracted from the private key is invalid.');\n    } // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n\n\n    return addressFromKey;\n  }\n\n  return legacyAccount.address;\n};\n/**\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\n *\n * @method _getRoleKey\n * @param {Object} tx transaction object to be sign.\n * @param {Object} account Account to be used for signing.\n * @return {String|Array}\n */\n\n\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n  let key;\n\n  if (!account) {\n    throw new Error('The account to be used for signing is not defined.');\n  }\n\n  if (tx.senderRawTransaction && tx.feePayer) {\n    key = account.feePayerKey;\n  } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n    key = account.updateKey;\n  } else {\n    key = account.transactionKey;\n  }\n\n  if (!key) {\n    throw new Error('The key corresponding to the role used for signing is not defined.');\n  }\n\n  return key;\n};\n/**\n * create function creates random account with entropy.\n *\n * @method create\n * @param {Object} entropy A random string to increase entropy.\n * @return {Object}\n */\n\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))));\n};\n/**\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\n *\n * @method createAccountKey\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n  if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys;\n\n  if (_.isString(accountKey)) {\n    accountKey = this.createAccountKeyPublic(accountKey);\n  } else if (_.isArray(accountKey)) {\n    accountKey = this.createAccountKeyMultiSig(accountKey);\n  } else if (_.isObject(accountKey)) {\n    accountKey = this.createAccountKeyRoleBased(accountKey);\n  } else {\n    throw new Error(`Invalid accountKey type: ${typeof accountKey}`);\n  }\n\n  return accountKey;\n};\n/**\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\n *\n * @method createAccountKeyPublic\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n  if (privateKey instanceof AccountKeyPublic) return privateKey;\n\n  if (!_.isString(privateKey)) {\n    throw new Error('Creating a AccountKeyPublic requires a private key string.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error(`Failed to create AccountKeyPublic. Invalid private key : ${privateKey}`);\n  }\n\n  return new AccountKeyPublic(privateKey);\n};\n/**\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\n *\n * @method createAccountKeyMultiSig\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n  if (privateKeys instanceof AccountKeyMultiSig) return privateKeys;\n\n  if (!_.isArray(privateKeys)) {\n    throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.');\n  }\n\n  for (let i = 0; i < privateKeys.length; i++) {\n    const parsed = utils.parsePrivateKey(privateKeys[i]);\n    const p = parsed.privateKey;\n\n    if (!utils.isValidPrivateKey(p)) {\n      throw new Error(`Failed to create AccountKeyMultiSig. Invalid private key : ${p}`);\n    }\n  }\n\n  return new AccountKeyMultiSig(privateKeys);\n};\n/**\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\n *\n * @method createAccountKeyRoleBased\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n  if (keyObject instanceof AccountKeyRoleBased) return keyObject;\n\n  if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n    throw new Error('Creating a AccountKeyRoleBased requires an object.');\n  }\n\n  return new AccountKeyRoleBased(keyObject);\n};\n/**\n * accountKeyToPublicKey creates public key format with AccountKey.\n *\n * @method accountKeyToPublicKey\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\n * @return {String|Array|Object}\n */\n\n\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n  accountKey = this.createAccountKey(accountKey);\n  return accountKey.toPublicKey(this.privateKeyToPublicKey);\n};\n/**\n * createWithAccountKey creates Account instance with AccountKey.\n *\n * @method createWithAccountKey\n * @param {String} address The address of account.\n * @param {String|Array|Object} accountKey The accountKey of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n  const account = new Account(address, this.createAccountKey(accountKey));\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\n *\n * @method createWithAccountKeyPublic\n * @param {String} address An address of account.\n * @param {String|Object} key Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n  if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key);\n\n  if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error(`Failed to create account with AccountKeyPublic. Invalid account key : ${key.type}`);\n  }\n\n  const account = new Account(address, key);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\n *\n * @method createWithAccountKeyMultiSig\n * @param {String} address An address of account.\n * @param {String|Object} keys Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n  if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys);\n\n  if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n    throw new Error(`Failed to create account with AccountKeyMultiSig. Invalid account key : ${keys.type}`);\n  }\n\n  const account = new Account(address, keys);\n  return this._addAccountFunctions(account);\n};\n/**\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\n *\n * @method createWithAccountKeyRoleBased\n * @param {String} address An address of account.\n * @param {String|Object} keyObject Key of account.\n * @return {Object}\n */\n\n\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n  if (!Account.isAccountKey(keyObject)) {\n    keyObject = this.createAccountKeyRoleBased(keyObject);\n  }\n\n  if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n    throw new Error(`Failed to create account with AccountKeyRoleBased. Invalid account key : ${keyObject.type}`);\n  }\n\n  const account = new Account(address, keyObject);\n  return this._addAccountFunctions(account);\n};\n/**\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\n *\n * @method privateKeyToAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n  const {\n    legacyAccount: account,\n    klaytnWalletKeyAddress\n  } = this.getLegacyAccount(key);\n  account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress);\n  account.address = account.address.toLowerCase();\n  account.address = utils.addHexPrefix(account.address);\n  return account;\n};\n/**\n * createAccountForUpdate creates an AccountForUpdate instance.\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\n *\n * @method createAccountForUpdate\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n  let legacyOrFail; // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n\n  if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n    legacyOrFail = {};\n    Object.keys(accountKey).map(role => {\n      if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n        legacyOrFail[role] = accountKey[role];\n        delete accountKey[role];\n      }\n    });\n\n    if (Object.keys(accountKey).length === 0) {\n      return new AccountForUpdate(address, legacyOrFail, options);\n    }\n  }\n\n  const publicKey = this.accountKeyToPublicKey(accountKey);\n\n  if (legacyOrFail !== undefined) {\n    Object.assign(publicKey, legacyOrFail);\n  }\n\n  return new AccountForUpdate(address, publicKey, options);\n};\n/**\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\n *\n * @method createAccountForUpdateWithPublicKey\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} keyForUpdate Public key to update.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n  return new AccountForUpdate(address, keyForUpdate, options);\n};\n/**\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\n *\n * @method createAccountForUpdateWithLegacyKey\n * @param {String} address The address of account to update with the legacy key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n  return new AccountForUpdate(address, 'legacyKey');\n};\n/**\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\n *\n * @method createAccountForUpdateWithFailKey\n * @param {String} address The address of account to update with the fail key.\n * @return {Object}\n */\n\n\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n  return new AccountForUpdate(address, 'failKey');\n};\n/**\n * isDecoupled determines whether or not it is decoupled based on the input value.\n *\n * @method isDecoupled\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\n * @return {Boolean}\n */\n\n\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n  const {\n    legacyAccount,\n    klaytnWalletKeyAddress\n  } = this.getLegacyAccount(key);\n\n  const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress);\n\n  return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase();\n};\n/**\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\n *\n * @method getLegacyAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @return {Object}\n */\n\n\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n  const parsed = utils.parsePrivateKey(key);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const privateKey = utils.addHexPrefix(parsed.privateKey);\n\n  const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)));\n\n  return {\n    legacyAccount: account,\n    klaytnWalletKeyAddress: parsed.address\n  };\n};\n/**\n * signTransaction signs to transaction with private key.\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\n *\n * @method signTransaction\n * @param {String|Object} tx The transaction to sign.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransaction = function signTransaction() {\n  const _this = this;\n\n  let isLegacy = false;\n  let isFeePayer = false;\n  let existedSenderSignatures = [];\n  let existedFeePayerSignatures = [];\n  let result;\n  let tx;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransaction(arguments);\n    tx = resolved.tx;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  } // If the user signs an RLP encoded transaction, tx is of type string.\n\n\n  if (_.isString(tx)) {\n    tx = decodeFromRawTransaction(tx);\n  } // Validate tx object\n\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    if (tx.feePayerSignatures) {\n      existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures);\n    }\n\n    try {\n      // Decode senderRawTransaction to get signatures of fee payer\n      const {\n        senderRawTransaction,\n        feePayer,\n        feePayerSignatures\n      } = splitFeePayer(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n      if (feePayer !== '0x' && feePayer !== '0x0000000000000000000000000000000000000000') {\n        // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n        if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n          return handleError(`Invalid feePayer: The fee payer(${feePayer}) included in the transaction does not match the fee payer(${tx.feePayer}) you want to sign.`);\n        }\n\n        existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures);\n      }\n\n      tx.senderRawTransaction = senderRawTransaction;\n      isFeePayer = true;\n    } catch (e) {\n      return handleError(e);\n    }\n  } else {\n    isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY');\n\n    if (tx.signatures) {\n      // if there is existed signatures or feePayerSignatures, those should be preserved.\n      if (isLegacy) {\n        return handleError('Legacy transaction cannot be signed with multiple keys.');\n      }\n\n      existedSenderSignatures = existedSenderSignatures.concat(tx.signatures);\n    }\n  } // When privateKey is undefined, find Account from Wallet.\n\n\n  if (privateKey === undefined) {\n    try {\n      const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from);\n\n      if (!account) {\n        return handleError('Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.');\n      }\n\n      privateKey = this._getRoleKey(tx, account);\n    } catch (e) {\n      return handleError(e);\n    }\n  }\n\n  const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey];\n\n  try {\n    for (let i = 0; i < privateKeys.length; i++) {\n      const parsed = utils.parsePrivateKey(privateKeys[i]);\n      privateKeys[i] = parsed.privateKey;\n      privateKeys[i] = utils.addHexPrefix(privateKeys[i]);\n\n      if (!utils.isValidPrivateKey(privateKeys[i])) {\n        return handleError('Invalid private key');\n      }\n    }\n  } catch (e) {\n    return handleError(e);\n  } // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n\n\n  if (isLegacy) {\n    if (privateKeys.length > 1) {\n      return handleError('Legacy transaction cannot signed with multiple keys');\n    }\n\n    if (_this.isDecoupled(privateKeys[0], tx.from)) {\n      return handleError('A legacy transaction must be with a legacy account key');\n    }\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      const messageHash = Hash.keccak256(rlpEncoded);\n      const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures;\n\n      for (const p of privateKeys) {\n        const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p);\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n        sigs.push([v, r, s]);\n      } // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n\n\n      const {\n        rawTransaction,\n        signatures,\n        feePayerSignatures\n      } = makeRawTransaction(rlpEncoded, sigs, transaction);\n      result = {\n        messageHash,\n        v: sigs[0][0],\n        r: sigs[0][1],\n        s: sigs[0][2],\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (isFeePayer) {\n        result.feePayerSignatures = feePayerSignatures;\n      } else {\n        result.signatures = signatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // When the feePayer signs a transaction, required information is only chainId.\n\n\n  if (isFeePayer) {\n    return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function (args) {\n      if (isNot(args[0])) {\n        throw new Error(`\"chainId\" couldn't be fetched: ${JSON.stringify(args)}`);\n      }\n\n      return signed(_.extend(tx, {\n        chainId: args[0]\n      }));\n    });\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\n *\n * @method feePayerSignTransaction\n * @param {Object|String} tx The transaction to sign.\n * @param {String} feePayer The address of fee payer.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n  const _this = this;\n\n  let tx;\n  let feePayer;\n  let privateKey;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForFeePayerSignTransaction(arguments);\n    tx = resolved.tx;\n    feePayer = resolved.feePayer;\n    privateKey = resolved.privateKey;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  if (_.isString(tx)) {\n    return this.signTransaction({\n      senderRawTransaction: tx,\n      feePayer\n    }, privateKey, callback);\n  }\n\n  if (!tx.feePayer || tx.feePayer === '0x' || tx.feePayer === '0x0000000000000000000000000000000000000000') {\n    tx.feePayer = feePayer;\n  }\n\n  if (!tx.senderRawTransaction) {\n    if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n      return handleError(`Failed to sign transaction with fee payer: invalid transaction type(${tx.type ? tx.type : 'LEGACY'})`);\n    }\n  }\n\n  const e = helpers.validateFunction.validateParams(tx);\n\n  if (e) {\n    return handleError(e);\n  }\n\n  if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n    return handleError('Invalid parameter: The address of fee payer does not match.');\n  }\n\n  if (tx.senderRawTransaction) {\n    return this.signTransaction(tx, privateKey, callback);\n  }\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    const chainId = args[0];\n    const gasPrice = args[1];\n    const nonce = args[2];\n\n    if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    let transaction = _.extend(tx, {\n      chainId,\n      gasPrice,\n      nonce\n    });\n\n    transaction = helpers.formatters.inputCallFormatter(transaction);\n    transaction = coverInitialTxValue(transaction);\n    const rlpEncoded = encodeRLPByTxType(transaction);\n    const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']];\n    const {\n      rawTransaction\n    } = makeRawTransaction(rlpEncoded, sig, transaction);\n    return _this.signTransaction({\n      senderRawTransaction: rawTransaction,\n      feePayer,\n      chainId\n    }, privateKey, callback);\n  });\n};\n/**\n * signTransactionWithHash signs to transaction hash with private key(s).\n *\n * @method signTransactionWithHash\n * @param {String} hash The hash of transaction to sign.\n * @param {String|Array} privateKeys The private key(s) to use for signing.\n * @param {String|Number} chainId The chain id of the network.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n  const _this = this;\n\n  let hash;\n  let privateKeys;\n  let chainId;\n  let callback;\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  try {\n    const resolved = resolveArgsForSignTransactionWithHash(arguments);\n    hash = resolved.hash;\n    chainId = resolved.chainId;\n    privateKeys = resolved.privateKeys;\n    callback = resolved.callback;\n  } catch (e) {\n    return handleError(e);\n  }\n\n  privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys];\n\n  function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n    const result = [];\n    chain = utils.numberToHex(chain);\n\n    try {\n      for (const privateKey of prvKeys) {\n        const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey);\n\n        if (!utils.isValidPrivateKey(p)) {\n          return handleError(`Failed to sign transaction with hash: Invalid private key ${privateKey}`);\n        }\n\n        const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p);\n        const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)));\n        result.push(utils.transformSignaturesToObject([v, r, s]));\n      }\n    } catch (e) {\n      callbackFunc(e);\n      return Promise.reject(e);\n    }\n\n    callbackFunc(null, result);\n    return result;\n  }\n\n  return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n    return signWithHash(hash, privateKeys, id, callback);\n  });\n};\n/**\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\n *\n * @method getRawTransactionWithSignatures\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n  const _this = this;\n\n  let result;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!tx || !_.isObject(tx)) {\n    return handleError('Invalid parameter: The transaction must be defined as an object');\n  }\n\n  if (!tx.signatures && !tx.feePayerSignatures) {\n    return handleError('There are no signatures or feePayerSignatures defined in the transaction object.');\n  }\n\n  const error = helpers.validateFunction.validateParams(tx);\n  if (error) return handleError(error);\n\n  if (tx.senderRawTransaction) {\n    tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']];\n    const decoded = decodeFromRawTransaction(tx.senderRawTransaction); // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n\n    if (decoded.feePayer !== '0x' && decoded.feePayer !== '0x0000000000000000000000000000000000000000' && !utils.isEmptySig(decoded.feePayerSignatures)) {\n      if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n        return handleError('Invalid feePayer');\n      }\n\n      tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures);\n    }\n\n    decoded.feePayer = tx.feePayer;\n    decoded.feePayerSignatures = tx.feePayerSignatures;\n\n    if (tx.signatures) {\n      decoded.signatures = decoded.signatures.concat(tx.signatures);\n    }\n\n    tx = decoded;\n  }\n\n  function signed(txObject) {\n    try {\n      // Guarantee all property in transaction is hex.\n      txObject = helpers.formatters.inputCallFormatter(txObject);\n      const transaction = coverInitialTxValue(txObject);\n      const rlpEncoded = encodeRLPByTxType(transaction);\n      let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x'];\n      if (!_.isArray(sigs[0])) sigs = [sigs];\n      const {\n        rawTransaction,\n        signatures,\n        feePayerSignatures\n      } = makeRawTransaction(rlpEncoded, sigs, transaction);\n      result = {\n        rawTransaction,\n        txHash: Hash.keccak256(rawTransaction),\n        senderTxHash: getSenderTxHash(rawTransaction)\n      };\n\n      if (signatures && !utils.isEmptySig(signatures)) {\n        result.signatures = signatures;\n      }\n\n      if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n        result.feePayerSignatures = feePayerSignatures;\n      }\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  }\n\n  if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Klaytn Node\n\n\n  return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId, isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n      throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`);\n    }\n\n    return signed(_.extend(tx, {\n      chainId: args[0],\n      gasPrice: args[1],\n      nonce: args[2]\n    }));\n  });\n};\n/**\n * combineSignatures combines RLP encoded raw transaction strings.\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\n * The comparison allows that the address of the fee payer is '0x0000000000000000000000000000000000000000'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\n * In this case, feePayer field doesn't have to be compared with other transaction.\n *\n * @method combineSignatures\n * @param {Array} rawTransactions The array of raw transaction string to combine.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\n\n\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n  let decodedTx;\n  let senders = [];\n  let feePayers = [];\n  let feePayer;\n\n  callback = callback || function () {};\n\n  const handleError = e => {\n    e = e instanceof Error ? e : new Error(e);\n    if (callback) callback(e);\n    return Promise.reject(e);\n  };\n\n  if (!_.isArray(rawTransactions)) {\n    return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.');\n  }\n\n  for (const raw of rawTransactions) {\n    const {\n      senderSignatures,\n      feePayerSignatures,\n      decodedTransaction\n    } = extractSignatures(raw);\n    senders = senders.concat(senderSignatures);\n    feePayers = feePayers.concat(feePayerSignatures);\n\n    if (decodedTx) {\n      let isSame = true;\n      const keys = Object.keys(decodedTx);\n\n      for (const key of keys) {\n        if (key === 'v' || key === 'r' || key === 's' || key === 'signatures' || key === 'payerV' || key === 'payerR' || key === 'payerS' || key === 'feePayerSignatures') {\n          continue;\n        } // feePayer field can be '0x' or '0x0000000000000000000000000000000000000000' when after sender signs to trasnaction.\n        // For handling this, if feePayer is '0x' or '0x0000000000000000000000000000000000000000', don't compare with other transaction\n\n\n        if (key === 'feePayer') {\n          if (decodedTransaction[key] === '0x' || decodedTransaction[key] === '0x0000000000000000000000000000000000000000') {\n            continue;\n          } else {\n            // set feePayer letiable with valid feePayer address(not '0x' and '0x0000000000000000000000000000000000000000')\n            feePayer = decodedTransaction[key];\n\n            if (decodedTx[key] === '0x' || decodedTx[key] === '0x0000000000000000000000000000000000000000') {\n              // set feePayer field to decodedTx for comparing feePayer address with other transactions\n              decodedTx[key] = decodedTransaction[key];\n            }\n          }\n        }\n\n        if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n          isSame = false;\n          break;\n        }\n      }\n\n      if (!isSame) {\n        return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.');\n      }\n    } else {\n      decodedTx = decodedTransaction;\n    }\n  }\n\n  const parsedTxObject = decodeFromRawTransaction(rawTransactions[0]);\n  parsedTxObject.signatures = senders;\n\n  if (feePayer) {\n    parsedTxObject.feePayer = feePayer;\n\n    if (feePayers.length > 0) {\n      parsedTxObject.feePayerSignatures = feePayers;\n    }\n  }\n\n  return this.getRawTransactionWithSignatures(parsedTxObject, callback);\n};\n/**\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n    throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".');\n  }\n\n  const values = RLP.decode(rawTx); // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n\n  const arr = values.slice(7, 9).map(sig => {\n    sig = sig.replace('0x', '');\n\n    while (sig.length < 64) {\n      sig = `0${sig}`;\n    }\n\n    return `0x${sig}`;\n  });\n  arr.unshift(values[6]);\n  const signature = AccountLib.encodeSignature(arr);\n  const recovery = Bytes.toNumber(values[6]);\n  const extraData = recovery < 35 ? [] : [Bytes.fromNumber(recovery - 35 >> 1), '0x', '0x'];\n  const signingData = values.slice(0, 6).concat(extraData);\n  const signingDataHex = RLP.encode(signingData);\n  return AccountLib.recover(Hash.keccak256(signingDataHex), signature);\n};\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`;\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\n\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n\n  if (!utils.isValidPrivateKey(privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  const messageHash = this.hashMessage(data);\n  const signature = AccountLib.sign(messageHash, privateKey);\n  const [v, r, s] = AccountLib.decodeSignature(signature);\n  return {\n    message: data,\n    messageHash,\n    v,\n    r,\n    s,\n    signature\n  };\n};\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\n\n\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n  const args = [].slice.apply(arguments);\n\n  if (_.isObject(message)) {\n    return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true);\n  }\n\n  if (!preFixed) {\n    message = this.hashMessage(message);\n  }\n\n  if (args.length >= 4) {\n    preFixed = args.slice(-1)[0];\n    preFixed = _.isBoolean(preFixed) ? !!preFixed : false;\n    return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed); // v, r, s\n  }\n  /**\n   * recover in Account module\n   * const recover = (hash, signature) => {\n   *   const vals = decodeSignature(signature);\n   *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n   *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n   *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\n   *   const publicHash = keccak256(publicKey);\n   *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n   *   return address;\n   * };\n   */\n\n\n  return AccountLib.recover(message, signature);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  if (!_.isString(password)) {\n    throw new Error('No password given.');\n  } // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\n\n\n  const json = _.isObject(v3Keystore) ? _.cloneDeep(v3Keystore) : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n  if (json.version !== 3 && json.version !== 4) {\n    console.warn('This is not a V3 or V4 wallet.'); // throw new Error('Not a valid V3 wallet');\n  }\n\n  if (json.version === 3 && !json.crypto) {\n    // crypto field should be existed in keystore version 3\n    throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n  }\n\n  if (json.crypto) {\n    if (json.keyring) {\n      throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\");\n    }\n\n    json.keyring = [json.crypto];\n    delete json.crypto;\n  }\n\n  if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n    throw new Error('Invalid key store format');\n  }\n\n  let accountKey = {}; // AccountKeyRoleBased format\n\n  if (_.isArray(json.keyring[0])) {\n    const transactionKey = decryptKey(json.keyring[0]);\n    if (transactionKey) accountKey.transactionKey = transactionKey;\n    const updateKey = decryptKey(json.keyring[1]);\n    if (updateKey) accountKey.updateKey = updateKey;\n    const feePayerKey = decryptKey(json.keyring[2]);\n    if (feePayerKey) accountKey.feePayerKey = feePayerKey;\n  } else {\n    accountKey = decryptKey(json.keyring);\n  }\n\n  function decryptKey(encryptedArray) {\n    if (!encryptedArray || encryptedArray.length === 0) return undefined;\n    const decryptedArray = [];\n\n    for (const encrypted of encryptedArray) {\n      let derivedKey;\n      let kdfparams;\n      /**\n       * Supported kdf modules are the following:\n       * 1) pbkdf2\n       * 2) scrypt\n       */\n\n      if (encrypted.kdf === 'scrypt') {\n        kdfparams = encrypted.kdfparams; // FIXME: support progress reporting callback\n\n        derivedKey = scrypt.syncScrypt(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n      } else if (encrypted.kdf === 'pbkdf2') {\n        kdfparams = encrypted.kdfparams;\n\n        if (kdfparams.prf !== 'hmac-sha256') {\n          throw new Error('Unsupported parameters to PBKDF2');\n        }\n\n        derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n      } else {\n        throw new Error('Unsupported key derivation scheme');\n      }\n\n      const ciphertext = Buffer.from(encrypted.ciphertext, 'hex');\n      const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '');\n\n      if (mac !== encrypted.mac) {\n        throw new Error('Key derivation failed - possibly wrong password');\n      }\n\n      const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'));\n      decryptedArray.push(`0x${Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')}`);\n    }\n\n    return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray;\n  }\n\n  return this.createWithAccountKey(json.address, accountKey);\n};\n/*\n    The fields of kdfparams are described below.\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n */\n\n/**\n * encrypt encrypts an account and returns a key store v4 object.\n *\n * @method encrypt\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encrypt = function (key, password, options) {\n  /**\n   * options can include below\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   */\n  options = options || {};\n  let address;\n  let account;\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else {\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  let keyring;\n  let transactionKey;\n  let updateKey;\n  let feePayerKey;\n\n  switch (account.accountKeyType) {\n    case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n    case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n      keyring = encryptKey(account.keys, password, options);\n      break;\n\n    case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n      keyring = [];\n      transactionKey = encryptKey(account.transactionKey, password, options);\n      updateKey = encryptKey(account.updateKey, password, options);\n      feePayerKey = encryptKey(account.feePayerKey, password, options);\n      keyring.push(transactionKey);\n      keyring.push(updateKey);\n      keyring.push(feePayerKey);\n\n      for (let i = keyring.length - 1; i >= 0; i--) {\n        if (keyring[i].length !== 0) break;\n        keyring = keyring.slice(0, i);\n      }\n\n      break;\n\n    default:\n      throw new Error(`Unsupported account key type: ${account.accountKeyType}`);\n  }\n\n  return {\n    version: 4,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    keyring\n  };\n};\n/**\n * encryptV3 encrypts an account and returns a key store v3 object.\n *\n * @method encryptV3\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\n\n\nAccounts.prototype.encryptV3 = function (key, password, options) {\n  options = options || {};\n  let address;\n  let account;\n  const notSupportedType = 'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.';\n\n  if (key instanceof Account) {\n    if (options.address && options.address !== key.address) {\n      throw new Error('Address in account is not matched with address in options object');\n    }\n\n    if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n    address = key.address;\n    account = key;\n  } else if (_.isString(key)) {\n    account = this.privateKeyToAccount(key, options.address);\n    address = account.address;\n  } else if (Account.isAccountKey(key)) {\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType);\n\n    if (!options.address) {\n      throw new Error('The address must be defined inside the options object.');\n    }\n\n    address = options.address;\n  } else {\n    throw new Error(notSupportedType);\n  }\n\n  if (!account) account = this.createWithAccountKey(address, key);\n  const crypto = encryptKey(account.keys, password, options);\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase(),\n    crypto: crypto[0]\n  };\n};\n\nAccounts.prototype.privateKeyToPublicKey = function (privateKey, compressed = false) {\n  const parsed = utils.parsePrivateKey(privateKey);\n  privateKey = parsed.privateKey;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 64) {\n    throw new Error('Received a invalid privateKey. The length of privateKey should be 64.');\n  }\n\n  const buffer = Buffer.from(privateKey, 'hex');\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  let publicKey;\n\n  if (!compressed) {\n    publicKey = `0x${ecKey.getPublic(false, 'hex').slice(2)}`;\n  } else {\n    publicKey = `0x${ecKey.getPublic(true, 'hex')}`;\n  }\n\n  return publicKey;\n};\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType;\n\nAccounts.prototype.setAccounts = function (accounts) {\n  this.wallet.clear();\n\n  for (let i = 0; i < accounts.wallet.length; i++) {\n    this.wallet.add(accounts.wallet[i]);\n  }\n\n  return this;\n};\n/* eslint-enable complexity */\n// Note: this is trying to follow closely the specs on\n\n/**\n  > Wallet {\n      0: {...}, // account by index\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n      1: {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n      add: function(){},\n      remove: function(){},\n      save: function(){},\n      load: function(){},\n      clear: function(){},\n\n      length: 2,\n  }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n */\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = 'caverjs_wallet';\n}\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  if (_.has(this, pointer)) {\n    return this._findSafeIndex(pointer + 1);\n  }\n\n  return pointer;\n};\n\nWallet.prototype._currentIndexes = function () {\n  const keys = Object.keys(this);\n  const indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (let i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n */\n\n\nWallet.prototype.add = function (account, userInputAddress) {\n  let accountForWallet;\n  /**\n   * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n   *\n   * cav.klay.accounts.wallet.add({\n   *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n   *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n   * });\n   */\n\n  if (Account.isAccountKey(account)) {\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account);\n  } else if (account instanceof Account) {\n    accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey);\n    accountForWallet.address = userInputAddress || account.address;\n  } else if (_.isObject(account) && account.address && account.privateKey) {\n    accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address);\n  } else if (_.isString(account)) {\n    accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress);\n  } else {\n    const accountKey = this._accounts.createAccountKey(account);\n\n    if (!userInputAddress) {\n      throw new Error('Address is not defined. Address cannot be determined from AccountKey format');\n    }\n\n    accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey);\n  }\n\n  if (this[accountForWallet.address]) {\n    throw new Error(`Account exists with ${accountForWallet.address}`);\n  }\n\n  accountForWallet.index = this._findSafeIndex();\n  this[accountForWallet.index] = accountForWallet;\n  this[accountForWallet.address] = accountForWallet;\n  this[accountForWallet.address.toLowerCase()] = accountForWallet;\n  this[accountForWallet.address.toUpperCase()] = accountForWallet;\n\n  try {\n    this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet;\n  } catch (e) {}\n\n  this.length++;\n  return accountForWallet;\n};\n\nWallet.prototype.updatePrivateKey = function (privateKey, address) {\n  if (privateKey === undefined || address === undefined) {\n    throw new Error('To update the privatKey in wallet, need to set both privateKey and address.');\n  } // If privateKey parameter is not string type, return error\n\n\n  if (!_.isString(privateKey)) {\n    throw new Error('The private key used for the update is not a valid string.');\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(`Invalid address : ${address}`);\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(`Failed to find account with ${address}`);\n  const account = this[address];\n\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.');\n  }\n\n  const parsed = utils.parsePrivateKey(privateKey);\n\n  if (!utils.isValidPrivateKey(parsed.privateKey)) {\n    throw new Error('Invalid private key');\n  }\n\n  if (parsed.address && parsed.address !== account.address) {\n    throw new Error('The address extracted from the private key does not match the address received as the input value.');\n  }\n\n  const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey);\n  this[account.index].accountKey = newAccountKeyPublic;\n  this[account.address].accountKey = newAccountKeyPublic;\n  this[account.address.toLowerCase()].accountKey = newAccountKeyPublic;\n  this[account.address.toUpperCase()].accountKey = newAccountKeyPublic;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n  if (address === undefined || accountKey === undefined) {\n    throw new Error('To update the accountKey in wallet, need to set both address and accountKey.');\n  }\n\n  if (!Account.isAccountKey(accountKey)) {\n    accountKey = this._accounts.createAccountKey(accountKey);\n  }\n\n  if (!utils.isAddress(address)) {\n    throw new Error(`Invalid address : ${address}`);\n  } // If failed to find account through address, return error\n\n\n  const accountExists = !!this[address];\n  if (!accountExists) throw new Error(`Failed to find account with ${address}`);\n  const account = this[address];\n  this[account.index].accountKey = accountKey;\n  this[account.address].accountKey = accountKey;\n  this[account.address.toLowerCase()].accountKey = accountKey;\n  this[account.address.toUpperCase()].accountKey = accountKey;\n\n  try {\n    this[utils.toChecksumAddress(account.address)].accountKey = accountKey;\n  } catch (e) {}\n\n  return account;\n};\n\nWallet.prototype.remove = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n\n  if (account && account.address) {\n    // address\n    this[account.address].accountKey = null;\n    delete this[account.address];\n\n    if (this[account.address.toLowerCase()]) {\n      // address lowercase\n      this[account.address.toLowerCase()].accountKey = null;\n      delete this[account.address.toLowerCase()];\n    }\n\n    if (this[account.address.toUpperCase()]) {\n      // address uppercase\n      this[account.address.toUpperCase()].accountKey = null;\n      delete this[account.address.toUpperCase()];\n    }\n\n    try {\n      this[utils.toChecksumAddress(account.address)].accountKey = null;\n      delete this[utils.toChecksumAddress(account.address)];\n    } catch (e) {} // index\n\n\n    this[account.index].accountKey = null;\n    delete this[account.index];\n    this.length--;\n    return true;\n  }\n\n  return false;\n};\n\nWallet.prototype.clear = function () {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n/**\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\n\n\nWallet.prototype.encrypt = function (password, options) {\n  const _this = this;\n\n  const indexes = this._currentIndexes();\n\n  const accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n/**\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\n\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  const _this = this;\n\n  encryptedWallet.forEach(function (keystore) {\n    const account = _this._accounts.decrypt(keystore, password);\n\n    if (!account) {\n      throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\");\n    }\n\n    const exist = !!_this[account.address];\n\n    if (!exist) {\n      _this.add(account);\n    }\n  });\n  return this;\n};\n\nWallet.prototype.save = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n/**\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\n\n\nWallet.prototype.load = function (password, keyName) {\n  /* eslint-disable-next-line no-undef */\n  let keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n\nif (typeof localStorage === 'undefined') {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n\nWallet.prototype.getKlaytnWalletKey = function (addressOrIndex) {\n  const account = this[addressOrIndex];\n  if (!account) throw new Error('Failed to find account');\n  return genKlaytnWalletKeyStringFromAccount(account);\n};\n\nWallet.prototype.getAccount = function (input) {\n  if (_.isNumber(input)) {\n    if (this.length <= input) {\n      throw new Error(`The index(${input}) is out of range(Wallet length : ${this.length}).`);\n    }\n\n    return this[input];\n  }\n\n  if (!_.isString(input)) {\n    throw new Error(`Accounts in the Wallet can be searched by only index or address. :${input}`);\n  }\n\n  if (!utils.isAddress(input)) {\n    throw new Error(`Failed to getAccount from Wallet: invalid address(${input})`);\n  }\n\n  return this[input.toLowerCase()];\n};\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n  if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n    throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.');\n  }\n\n  let addressString = account.address;\n  let {\n    privateKey\n  } = account;\n  privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : `0x${privateKey}`;\n  addressString = addressString.slice(0, 2) === '0x' ? addressString : `0x${addressString}`;\n  return `${privateKey}0x00${addressString}`;\n}\n\nmodule.exports = Accounts;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-klay/caver-klay-accounts/src/index.js"],"names":["_","require","Promise","AccountLib","Hash","RLP","Nat","Bytes","cryp","global","uuid","elliptic","scrypt","utils","helpers","Method","core","encodeRLPByTxType","makeRawTransaction","getSenderTxHash","decodeFromRawTransaction","splitFeePayer","extractSignatures","secp256k1","ec","AccountKeyPublic","AccountKeyMultiSig","AccountKeyRoleBased","AccountKeyEnum","Account","AccountForUpdate","rpc","isNot","value","isUndefined","isNull","coverInitialTxValue","tx","Error","senderRawTransaction","type","includes","to","data","addHexPrefix","chainId","numberToHex","resolveArgsForSignTransaction","args","length","privateKey","callback","isObject","isString","isFunction","isArray","resolveArgsForFeePayerSignTransaction","feePayer","isAddress","resolveArgsForSignTransactionWithHash","hash","privateKeys","isValidHashStrict","Array","isNumber","encryptKey","password","options","encryptedArray","privateKeyArray","i","salt","randomBytes","iv","derivedKey","kdf","kdfparams","dklen","toString","c","prf","pbkdf2Sync","Buffer","from","n","r","p","syncScrypt","cipher","createCipheriv","slice","ciphertext","update","replace","final","mac","sha3","push","cipherparams","Accounts","_this","packageInit","BatchRequest","extend","_klaytnCall","getChainId","getGasPrice","getTransactionCount","each","method","attachToObject","setRequestManager","_requestManager","wallet","Wallet","prototype","_addAccountFunctions","account","signTransaction","roleKey","_getRoleKey","feePayerSignTransaction","address","feePayerKey","sign","encrypt","keys","getKlaytnWalletKey","genKlaytnWalletKeyStringFromAccount","_determineAddress","legacyAccount","addressFromKey","userInputAddress","key","updateKey","transactionKey","create","entropy","fromObject","randomHex","createAccountKey","accountKey","isAccountKey","createAccountKeyPublic","createAccountKeyMultiSig","createAccountKeyRoleBased","parsed","parsePrivateKey","isValidPrivateKey","keyObject","accountKeyToPublicKey","toPublicKey","privateKeyToPublicKey","createWithAccountKey","createWithAccountKeyPublic","ACCOUNT_KEY_PUBLIC","createWithAccountKeyMultiSig","ACCOUNT_KEY_MULTISIG","createWithAccountKeyRoleBased","ACCOUNT_KEY_ROLEBASED","privateKeyToAccount","klaytnWalletKeyAddress","getLegacyAccount","toLowerCase","createAccountForUpdate","legacyOrFail","Object","map","role","publicKey","undefined","assign","createAccountForUpdateWithPublicKey","keyForUpdate","createAccountForUpdateWithLegacyKey","createAccountForUpdateWithFailKey","isDecoupled","actualAddress","fromPrivate","isLegacy","isFeePayer","existedSenderSignatures","existedFeePayerSignatures","result","handleError","e","reject","resolved","arguments","error","validateFunction","validateParams","feePayerSignatures","concat","signatures","getAccount","signed","txObject","formatters","inputCallFormatter","transaction","rlpEncoded","messageHash","keccak256","sigs","signature","makeSigner","toNumber","v","s","decodeSignature","sig","makeEven","trimLeadingZero","rawTransaction","txHash","senderTxHash","nonce","gasPrice","resolve","all","then","JSON","stringify","signTransactionWithHash","signWithHash","transactionHash","prvKeys","chain","callbackFunc","transformSignaturesToObject","id","getRawTransactionWithSignatures","decoded","isEmptySig","combineSignatures","rawTransactions","decodedTx","senders","feePayers","raw","senderSignatures","decodedTransaction","isSame","parsedTxObject","recoverTransaction","rawTx","getTxTypeStringFromRawTransaction","values","decode","arr","unshift","encodeSignature","recovery","extraData","fromNumber","signingData","signingDataHex","encode","recover","hashMessage","message","isHexStrict","hexToBytes","messageBuffer","preamble","preambleBuffer","klayMessage","preFixed","apply","isBoolean","decrypt","v3Keystore","nonStrict","json","cloneDeep","parse","version","console","warn","crypto","keyring","decryptKey","decryptedArray","encrypted","decipher","createDecipheriv","accountKeyType","v4","random","encryptV3","notSupportedType","compressed","buffer","ecKey","keyFromPrivate","getPublic","setAccounts","accounts","clear","add","_accounts","defaultKeyName","_findSafeIndex","pointer","has","_currentIndexes","indexes","parseInt","filter","numberOfAccounts","accountForWallet","index","toUpperCase","toChecksumAddress","updatePrivateKey","accountExists","newAccountKeyPublic","updateAccountKey","remove","addressOrIndex","forEach","encryptedWallet","keystore","exist","save","keyName","localStorage","setItem","load","getItem","input","addressString","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-accounts/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file accounts.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst _ = require('lodash')\nconst Promise = require('any-promise')\n// account, hash, rlp, nat, bytes library will be used from 'eth-lib' temporarily.\nconst AccountLib = require('eth-lib/lib/account')\nconst Hash = require('eth-lib/lib/hash')\nconst RLP = require('eth-lib/lib/rlp')\nconst Nat = require('eth-lib/lib/nat')\nconst Bytes = require('eth-lib/lib/bytes')\nconst cryp = typeof global === 'undefined' ? require('crypto-browserify') : require('crypto')\nconst uuid = require('uuid')\nconst elliptic = require('elliptic')\nconst scrypt = require('scrypt-js')\nconst utils = require('../../../caver-utils')\nconst helpers = require('../../../caver-core-helpers')\n\nconst Method = require('../../../caver-core-method')\nconst core = require('../../../caver-core')\nconst {\n    encodeRLPByTxType,\n    makeRawTransaction,\n    getSenderTxHash,\n    decodeFromRawTransaction,\n    splitFeePayer,\n    extractSignatures,\n} = require('./makeRawTransaction')\n\nconst secp256k1 = new elliptic.ec('secp256k1')\n\nconst AccountKeyPublic = require('./accountKey/accountKeyPublic')\nconst AccountKeyMultiSig = require('./accountKey/accountKeyMultiSig')\nconst AccountKeyRoleBased = require('./accountKey/accountKeyRoleBased')\nconst { AccountKeyEnum } = require('./accountKey/accountKeyEnum')\n\nconst Account = require('./account/account')\nconst AccountForUpdate = require('./account/accountForUpdate')\n\nconst { rpc } = require('../../../caver-rtm')\n\nconst isNot = function(value) {\n    return _.isUndefined(value) || _.isNull(value)\n}\n\nfunction coverInitialTxValue(tx) {\n    if (typeof tx !== 'object') throw new Error('Invalid transaction')\n    if (!tx.senderRawTransaction && (!tx.type || tx.type === 'LEGACY' || tx.type.includes('SMART_CONTRACT_DEPLOY'))) {\n        tx.to = tx.to || '0x'\n        tx.data = utils.addHexPrefix(tx.data || '0x')\n    }\n    tx.chainId = utils.numberToHex(tx.chainId)\n    return tx\n}\n\n/**\n * resolveArgsForSignTransaction parse arguments for signTransaction.\n *\n * @method resolveArgsForSignTransaction\n * @param {Object} args Parameters of signTransaction.\n * @return {Object}\n */\nfunction resolveArgsForSignTransaction(args) {\n    if (args.length === 0 || args.length > 3) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    // privateKey and callback are optional parameter\n    // \"args.length === 2\" means that user sent parameter privateKey or callback\n    const tx = args[0]\n    let privateKey\n    let callback\n\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\n    }\n\n    if (args.length === 2) {\n        if (_.isFunction(args[1])) {\n            callback = args[1]\n        } else {\n            privateKey = args[1]\n        }\n    } else if (args.length === 3) {\n        if (args[1] && typeof args[1] !== 'string' && !_.isArray(args[1])) {\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\n        }\n        privateKey = args[1]\n        callback = args[2]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { tx, privateKey, callback }\n}\n\n/**\n * resolveArgsForFeePayerSignTransaction parse arguments for feePayerSignTransaction.\n *\n * @method resolveArgsForFeePayerSignTransaction\n * @param {Object} args Parameters of feePayerSignTransaction.\n * @return {Object}\n */\nfunction resolveArgsForFeePayerSignTransaction(args) {\n    if (args.length === 0 || args.length > 4) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    // privateKey and callback are optional parameter\n    // \"args.length === 3\" means that user sent parameter privateKey or callback\n    const tx = args[0]\n    const feePayer = args[1]\n    let privateKey\n    let callback\n\n    if (!tx || (!_.isObject(tx) && !_.isString(tx))) {\n        throw new Error('Invalid parameter: The transaction must be defined as an object or RLP encoded string')\n    }\n\n    if (!utils.isAddress(feePayer)) {\n        throw new Error(`Invalid fee payer address : ${feePayer}`)\n    }\n\n    if (args.length === 3) {\n        if (_.isFunction(args[2])) {\n            callback = args[2]\n        } else {\n            privateKey = args[2]\n        }\n    } else if (args.length === 4) {\n        if (args[2] && typeof args[2] !== 'string' && !_.isArray(args[2])) {\n            throw new Error('Invalid parameter: The parameter for the private key is invalid')\n        }\n        privateKey = args[2]\n        callback = args[3]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { tx, privateKey, feePayer, callback }\n}\n\n/**\n * resolveArgsForSignTransactionWithHash parse arguments for signTransactionWithHash.\n *\n * @method resolveArgsForSignTransactionWithHash\n * @param {Object} args Parameters of signTransactionWithHash.\n * @return {Object}\n */\nfunction resolveArgsForSignTransactionWithHash(args) {\n    if (args.length < 2 || args.length > 4) {\n        throw new Error('Invalid parameter: The number of parameters is invalid.')\n    }\n\n    const hash = args[0]\n    const privateKeys = args[1]\n    let chainId\n    let callback\n\n    if (!hash) {\n        throw new Error('Invalid parameter: The hash of transaction must be defined as a parameter.')\n    }\n\n    if (!utils.isValidHashStrict(hash)) {\n        throw new Error('Invalid parameter: The hash of transaction must be 0x-hex prefixed string format.')\n    }\n\n    if (!privateKeys || (!Array.isArray(privateKeys) && !_.isString(privateKeys))) {\n        throw new Error(`Invalid parameter: The private key should be a private key string or an array of private keys.`)\n    }\n\n    if (args.length === 3) {\n        if (_.isFunction(args[2])) {\n            callback = args[2]\n        } else {\n            chainId = args[2]\n        }\n    } else if (args.length === 4) {\n        if (args[2] && !_.isString(args[2]) && !_.isNumber(args[2])) {\n            throw new Error('Invalid parameter: The parameter for the chain id is invalid.')\n        }\n        chainId = args[2]\n        callback = args[3]\n    }\n\n    // For handling when callback is undefined.\n    callback = callback || function() {}\n\n    return { hash, privateKeys, chainId, callback }\n}\n\nfunction encryptKey(privateKey, password, options) {\n    const encryptedArray = []\n\n    if (!privateKey) return encryptedArray\n\n    const privateKeyArray = _.isArray(privateKey) ? privateKey : [privateKey]\n\n    for (let i = 0; i < privateKeyArray.length; i++) {\n        const salt = options.salt || cryp.randomBytes(32)\n        const iv = options.iv || cryp.randomBytes(16)\n\n        let derivedKey\n        const kdf = options.kdf || 'scrypt'\n        const kdfparams = {\n            dklen: options.dklen || 32,\n            salt: salt.toString('hex'),\n        }\n\n        /**\n         * Supported kdf modules are the following:\n         * 1) pbkdf2\n         * 2) scrypt - default\n         */\n        if (kdf === 'pbkdf2') {\n            kdfparams.c = options.c || 262144\n            kdfparams.prf = 'hmac-sha256'\n            derivedKey = cryp.pbkdf2Sync(Buffer.from(password), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256')\n        } else if (kdf === 'scrypt') {\n            // FIXME: support progress reporting callback\n            kdfparams.n = options.n || 4096 // 2048 4096 8192 16384\n            kdfparams.r = options.r || 8\n            kdfparams.p = options.p || 1\n            derivedKey = scrypt.syncScrypt(\n                Buffer.from(password),\n                Buffer.from(kdfparams.salt, 'hex'),\n                kdfparams.n,\n                kdfparams.r,\n                kdfparams.p,\n                kdfparams.dklen\n            )\n        } else {\n            throw new Error('Unsupported kdf')\n        }\n\n        const cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv)\n        if (!cipher) {\n            throw new Error('Unsupported cipher')\n        }\n\n        const ciphertext = Buffer.from([...cipher.update(Buffer.from(privateKeyArray[i].replace('0x', ''), 'hex')), ...cipher.final()])\n\n        const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '')\n\n        encryptedArray.push({\n            ciphertext: ciphertext.toString('hex'),\n            cipherparams: {\n                iv: iv.toString('hex'),\n            },\n            cipher: options.cipher || 'aes-128-ctr',\n            kdf,\n            kdfparams,\n            mac: mac.toString('hex'),\n        })\n    }\n\n    return encryptedArray\n}\n\nconst Accounts = function Accounts(...args) {\n    const _this = this\n\n    // sets _requestmanager\n    core.packageInit(this, args)\n\n    // remove unecessary core functions\n    delete this.BatchRequest\n    delete this.extend\n\n    const _klaytnCall = [rpc.getChainId, rpc.getGasPrice, rpc.getTransactionCount]\n    // attach methods to this._klaytnCall\n    this._klaytnCall = {}\n    _.each(_klaytnCall, function(method) {\n        method = new Method(method)\n        method.attachToObject(_this._klaytnCall)\n        method.setRequestManager(_this._requestManager)\n    })\n\n    this.wallet = new Wallet(this)\n}\n\nAccounts.prototype._addAccountFunctions = function(account) {\n    const _this = this\n\n    // add sign functions\n    account.signTransaction = function signTransaction(tx, callback) {\n        const roleKey = _this._getRoleKey(tx, account)\n        return _this.signTransaction(tx, roleKey, callback)\n    }\n\n    account.feePayerSignTransaction = function feePayerSignTransaction(tx, callback) {\n        return _this.feePayerSignTransaction(tx, account.address, account.feePayerKey, callback)\n    }\n\n    account.sign = function sign(data) {\n        return _this.sign(data, account.privateKey)\n    }\n\n    account.encrypt = function encrypt(password, options = {}) {\n        options.address = account.address\n        return _this.encrypt(account.keys, password, options)\n    }\n\n    account.getKlaytnWalletKey = function getKlaytnWalletKey() {\n        return genKlaytnWalletKeyStringFromAccount(account)\n    }\n\n    return account\n}\n\n/**\n * _determineAddress determines the priority of the parameters entered and returns the address that should be used for the account.\n *\n * @method _determineAddress\n * @param {Object} legacyAccount Account with a legacy account key extracted from private key to be used for address determination.\n * @param {String} addressFromKey Address extracted from key.\n * @param {String} userInputAddress Address passed as parameter by user.\n * @return {String}\n */\nAccounts.prototype._determineAddress = function _determineAddress(legacyAccount, addressFromKey, userInputAddress) {\n    if (userInputAddress) {\n        if (addressFromKey && addressFromKey !== userInputAddress) {\n            throw new Error('The address extracted from the private key does not match the address received as the input value.')\n        }\n\n        if (!utils.isAddress(userInputAddress)) {\n            throw new Error('The address received as the input value is invalid.')\n        }\n        return userInputAddress\n    }\n    if (addressFromKey) {\n        if (!utils.isAddress(addressFromKey)) {\n            throw new Error('The address extracted from the private key is invalid.')\n        }\n        // If userInputAddress is undefined and address which is came from private is existed, set address in account.\n        return addressFromKey\n    }\n    return legacyAccount.address\n}\n\n/**\n * _getRoleKey returns a key that matches the role that should be used according to the transaction.\n *\n * @method _getRoleKey\n * @param {Object} tx transaction object to be sign.\n * @param {Object} account Account to be used for signing.\n * @return {String|Array}\n */\nAccounts.prototype._getRoleKey = function _getRoleKey(tx, account) {\n    let key\n\n    if (!account) {\n        throw new Error('The account to be used for signing is not defined.')\n    }\n\n    if (tx.senderRawTransaction && tx.feePayer) {\n        key = account.feePayerKey\n    } else if (tx.type && tx.type.includes('ACCOUNT_UPDATE')) {\n        key = account.updateKey\n    } else {\n        key = account.transactionKey\n    }\n\n    if (!key) {\n        throw new Error('The key corresponding to the role used for signing is not defined.')\n    }\n\n    return key\n}\n\n/**\n * create function creates random account with entropy.\n *\n * @method create\n * @param {Object} entropy A random string to increase entropy.\n * @return {Object}\n */\nAccounts.prototype.create = function create(entropy) {\n    return this._addAccountFunctions(Account.fromObject(AccountLib.create(entropy || utils.randomHex(32))))\n}\n\n/**\n * createAccountKey creates AccountKeyPublic, AccountKeyMultiSig or AccountKeyRoleBased instance with parameter.\n *\n * @method createAccountKey\n * @param {String|Array|Object} accountKey Parameters to be used when creating the AccountKey.\n * @return {Object}\n */\nAccounts.prototype.createAccountKey = function createAccountKey(accountKey) {\n    if (Account.isAccountKey(accountKey)) accountKey = accountKey.keys\n\n    if (_.isString(accountKey)) {\n        accountKey = this.createAccountKeyPublic(accountKey)\n    } else if (_.isArray(accountKey)) {\n        accountKey = this.createAccountKeyMultiSig(accountKey)\n    } else if (_.isObject(accountKey)) {\n        accountKey = this.createAccountKeyRoleBased(accountKey)\n    } else {\n        throw new Error(`Invalid accountKey type: ${typeof accountKey}`)\n    }\n    return accountKey\n}\n\n/**\n * createAccountKeyPublic creates AccountKeyPublic with a string of private key.\n *\n * @method createAccountKeyPublic\n * @param {String} privateKey Private key string that will be used to create AccountKeyPublic.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyPublic = function createAccountKeyPublic(privateKey) {\n    if (privateKey instanceof AccountKeyPublic) return privateKey\n\n    if (!_.isString(privateKey)) {\n        throw new Error('Creating a AccountKeyPublic requires a private key string.')\n    }\n\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n\n    if (!utils.isValidPrivateKey(privateKey)) {\n        throw new Error(`Failed to create AccountKeyPublic. Invalid private key : ${privateKey}`)\n    }\n\n    return new AccountKeyPublic(privateKey)\n}\n\n/**\n * createAccountKeyMultiSig creates AccountKeyMultiSig with an array of private keys.\n *\n * @method createAccountKeyMultiSig\n * @param {Array} privateKeys An Array of private key strings that will be used to create AccountKeyMultiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyMultiSig = function createAccountKeyMultiSig(privateKeys) {\n    if (privateKeys instanceof AccountKeyMultiSig) return privateKeys\n\n    if (!_.isArray(privateKeys)) {\n        throw new Error('Creating a AccountKeyMultiSig requires an array of private key string.')\n    }\n\n    for (let i = 0; i < privateKeys.length; i++) {\n        const parsed = utils.parsePrivateKey(privateKeys[i])\n        const p = parsed.privateKey\n        if (!utils.isValidPrivateKey(p)) {\n            throw new Error(`Failed to create AccountKeyMultiSig. Invalid private key : ${p}`)\n        }\n    }\n\n    return new AccountKeyMultiSig(privateKeys)\n}\n\n/**\n * createAccountKeyRoleBased creates AccountKeyRoleBased with an object of key.\n *\n * @method createAccountKeyRoleBased\n * @param {Object} keyObject Object that defines key for each role to use when creating AccountKeyRoleBased.\n * @return {Object}\n */\nAccounts.prototype.createAccountKeyRoleBased = function createAccountKeyRoleBased(keyObject) {\n    if (keyObject instanceof AccountKeyRoleBased) return keyObject\n\n    if (!_.isObject(keyObject) || _.isArray(keyObject)) {\n        throw new Error('Creating a AccountKeyRoleBased requires an object.')\n    }\n\n    return new AccountKeyRoleBased(keyObject)\n}\n\n/**\n * accountKeyToPublicKey creates public key format with AccountKey.\n *\n * @method accountKeyToPublicKey\n * @param {Object} accountKey AccountKey instance for which you want to generate a public key format.\n * @return {String|Array|Object}\n */\nAccounts.prototype.accountKeyToPublicKey = function accountKeyToPublicKey(accountKey) {\n    accountKey = this.createAccountKey(accountKey)\n    return accountKey.toPublicKey(this.privateKeyToPublicKey)\n}\n\n/**\n * createWithAccountKey creates Account instance with AccountKey.\n *\n * @method createWithAccountKey\n * @param {String} address The address of account.\n * @param {String|Array|Object} accountKey The accountKey of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKey = function createWithAccountKey(address, accountKey) {\n    const account = new Account(address, this.createAccountKey(accountKey))\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyPublic create an account with AccountKeyPublic.\n *\n * @method createWithAccountKeyPublic\n * @param {String} address An address of account.\n * @param {String|Object} key Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyPublic = function createWithAccountKeyPublic(address, key) {\n    if (!Account.isAccountKey(key)) key = this.createAccountKeyPublic(key)\n\n    if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error(`Failed to create account with AccountKeyPublic. Invalid account key : ${key.type}`)\n    }\n\n    const account = new Account(address, key)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyMultiSig create an account with AccountKeyMultiSig.\n *\n * @method createWithAccountKeyMultiSig\n * @param {String} address An address of account.\n * @param {String|Object} keys Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyMultiSig = function createWithAccountKeyMultiSig(address, keys) {\n    if (!Account.isAccountKey(keys)) keys = this.createAccountKeyMultiSig(keys)\n\n    if (keys.type !== AccountKeyEnum.ACCOUNT_KEY_MULTISIG) {\n        throw new Error(`Failed to create account with AccountKeyMultiSig. Invalid account key : ${keys.type}`)\n    }\n\n    const account = new Account(address, keys)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * createWithAccountKeyRoleBased create an account with AccountKeyRoleBased.\n *\n * @method createWithAccountKeyRoleBased\n * @param {String} address An address of account.\n * @param {String|Object} keyObject Key of account.\n * @return {Object}\n */\nAccounts.prototype.createWithAccountKeyRoleBased = function createWithAccountKeyRoleBased(address, keyObject) {\n    if (!Account.isAccountKey(keyObject)) {\n        keyObject = this.createAccountKeyRoleBased(keyObject)\n    }\n\n    if (keyObject.type !== AccountKeyEnum.ACCOUNT_KEY_ROLEBASED) {\n        throw new Error(`Failed to create account with AccountKeyRoleBased. Invalid account key : ${keyObject.type}`)\n    }\n\n    const account = new Account(address, keyObject)\n    return this._addAccountFunctions(account)\n}\n\n/**\n * privateKeyToAccount creates and returns an Account through the input passed as parameters.\n *\n * @method privateKeyToAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address entered by the user for use in creating an account.\n * @return {Object}\n */\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(key, userInputAddress) {\n    const { legacyAccount: account, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\n\n    account.address = this._determineAddress(account, klaytnWalletKeyAddress, userInputAddress)\n    account.address = account.address.toLowerCase()\n    account.address = utils.addHexPrefix(account.address)\n\n    return account\n}\n\n/**\n * createAccountForUpdate creates an AccountForUpdate instance.\n * The AccountForUpdate returned as a result of this function contains only the address and public key used to update the account.\n *\n * @method createAccountForUpdate\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} accountKey Private key or AccountKey to update account.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdate = function createAccountForUpdate(address, accountKey, options) {\n    let legacyOrFail\n\n    // Logic for handling cases where legacyKey or failKey is set inside AccountKeyRoleBased object.\n    if (!_.isArray(accountKey) && _.isObject(accountKey)) {\n        legacyOrFail = {}\n        Object.keys(accountKey).map(role => {\n            if (accountKey[role] === 'legacyKey' || accountKey[role] === 'failKey') {\n                legacyOrFail[role] = accountKey[role]\n                delete accountKey[role]\n            }\n        })\n        if (Object.keys(accountKey).length === 0) {\n            return new AccountForUpdate(address, legacyOrFail, options)\n        }\n    }\n\n    const publicKey = this.accountKeyToPublicKey(accountKey)\n\n    if (legacyOrFail !== undefined) {\n        Object.assign(publicKey, legacyOrFail)\n    }\n\n    return new AccountForUpdate(address, publicKey, options)\n}\n\n/**\n * createAccountForUpdateWithPublicKey creates AccountForUpdate instance with public key format.\n *\n * @method createAccountForUpdateWithPublicKey\n * @param {String} address The address value of AccountForUpdate, a structure that contains data for updating an account.\n * @param {String|Array|Object} keyForUpdate Public key to update.\n * @param {Object} options Options to use for setting threshold and weight for multiSig.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithPublicKey = function createAccountForUpdateWithPublicKey(address, keyForUpdate, options) {\n    return new AccountForUpdate(address, keyForUpdate, options)\n}\n\n/**\n * createAccountForUpdateWithLegacyKey creates AccountForUpdate instance with legacyKey.\n *\n * @method createAccountForUpdateWithLegacyKey\n * @param {String} address The address of account to update with the legacy key.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithLegacyKey = function createAccountForUpdateWithLegacyKey(address) {\n    return new AccountForUpdate(address, 'legacyKey')\n}\n\n/**\n * createAccountForUpdateWithFailKey creates AccountForUpdate instance with failKey.\n *\n * @method createAccountForUpdateWithFailKey\n * @param {String} address The address of account to update with the fail key.\n * @return {Object}\n */\nAccounts.prototype.createAccountForUpdateWithFailKey = function createAccountForUpdateWithFailKey(address) {\n    return new AccountForUpdate(address, 'failKey')\n}\n\n/**\n * isDecoupled determines whether or not it is decoupled based on the input value.\n *\n * @method isDecoupled\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @param {String} userInputAddress The address to use when determining whether it is decoupled.\n * @return {Boolean}\n */\nAccounts.prototype.isDecoupled = function isDecoupled(key, userInputAddress) {\n    const { legacyAccount, klaytnWalletKeyAddress } = this.getLegacyAccount(key)\n    const actualAddress = this._determineAddress(legacyAccount, klaytnWalletKeyAddress, userInputAddress)\n\n    return legacyAccount.address.toLowerCase() !== actualAddress.toLowerCase()\n}\n\n/**\n * getLegacyAccount extracts the private key from the input key and returns an account with the corresponding legacy account key.\n * If the input key is KlaytnWalletKey format, it returns klaytnWalletKeyAddress, which is the address extracted from KlaytnWalletKey.\n *\n * @method getLegacyAccount\n * @param {String} key The key parameter can be either normal private key or KlaytnWalletKey format.\n * @return {Object}\n */\nAccounts.prototype.getLegacyAccount = function getLegacyAccount(key) {\n    const parsed = utils.parsePrivateKey(key)\n\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    const privateKey = utils.addHexPrefix(parsed.privateKey)\n\n    const account = this._addAccountFunctions(Account.fromObject(AccountLib.fromPrivate(privateKey)))\n\n    return { legacyAccount: account, klaytnWalletKeyAddress: parsed.address }\n}\n\n/**\n * signTransaction signs to transaction with private key.\n * If there are signatures(feePayerSignatures if the fee payer signs) in tx entered as a parameter,\n * the signatures(feePayerSignatures if the fee payer signs) are appended.\n *\n * @method signTransaction\n * @param {String|Object} tx The transaction to sign.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.signTransaction = function signTransaction() {\n    const _this = this\n    let isLegacy = false\n    let isFeePayer = false\n    let existedSenderSignatures = []\n    let existedFeePayerSignatures = []\n    let result\n    let tx\n    let privateKey\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForSignTransaction(arguments)\n        tx = resolved.tx\n        privateKey = resolved.privateKey\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    // If the user signs an RLP encoded transaction, tx is of type string.\n    if (_.isString(tx)) {\n        tx = decodeFromRawTransaction(tx)\n    }\n\n    // Validate tx object\n    const error = helpers.validateFunction.validateParams(tx)\n    if (error) return handleError(error)\n\n    if (tx.senderRawTransaction) {\n        if (tx.feePayerSignatures) {\n            existedFeePayerSignatures = existedFeePayerSignatures.concat(tx.feePayerSignatures)\n        }\n\n        try {\n            // Decode senderRawTransaction to get signatures of fee payer\n            const { senderRawTransaction, feePayer, feePayerSignatures } = splitFeePayer(tx.senderRawTransaction)\n\n            // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n            if (feePayer !== '0x' && feePayer !== '0x0000000000000000000000000000000000000000') {\n                // The feePayer inside the tx object does not match the feePayer information contained in the senderRawTransaction.\n                if (feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n                    return handleError(\n                        `Invalid feePayer: The fee payer(${feePayer}) included in the transaction does not match the fee payer(${tx.feePayer}) you want to sign.`\n                    )\n                }\n                existedFeePayerSignatures = existedFeePayerSignatures.concat(feePayerSignatures)\n            }\n\n            tx.senderRawTransaction = senderRawTransaction\n            isFeePayer = true\n        } catch (e) {\n            return handleError(e)\n        }\n    } else {\n        isLegacy = !!(tx.type === undefined || tx.type === 'LEGACY')\n\n        if (tx.signatures) {\n            // if there is existed signatures or feePayerSignatures, those should be preserved.\n            if (isLegacy) {\n                return handleError('Legacy transaction cannot be signed with multiple keys.')\n            }\n            existedSenderSignatures = existedSenderSignatures.concat(tx.signatures)\n        }\n    }\n\n    // When privateKey is undefined, find Account from Wallet.\n    if (privateKey === undefined) {\n        try {\n            const account = this.wallet.getAccount(isFeePayer ? tx.feePayer : tx.from)\n            if (!account) {\n                return handleError(\n                    'Failed to find get private key to sign. The account you want to use for signing must exist in caver.klay.accounts.wallet or you must pass the private key as a parameter.'\n                )\n            }\n            privateKey = this._getRoleKey(tx, account)\n        } catch (e) {\n            return handleError(e)\n        }\n    }\n\n    const privateKeys = _.isArray(privateKey) ? privateKey : [privateKey]\n\n    try {\n        for (let i = 0; i < privateKeys.length; i++) {\n            const parsed = utils.parsePrivateKey(privateKeys[i])\n            privateKeys[i] = parsed.privateKey\n            privateKeys[i] = utils.addHexPrefix(privateKeys[i])\n\n            if (!utils.isValidPrivateKey(privateKeys[i])) {\n                return handleError('Invalid private key')\n            }\n        }\n    } catch (e) {\n        return handleError(e)\n    }\n\n    // Attempting to sign with a decoupled account into a legacy type transaction should be rejected.\n    if (isLegacy) {\n        if (privateKeys.length > 1) {\n            return handleError('Legacy transaction cannot signed with multiple keys')\n        }\n        if (_this.isDecoupled(privateKeys[0], tx.from)) {\n            return handleError('A legacy transaction must be with a legacy account key')\n        }\n    }\n\n    function signed(txObject) {\n        try {\n            // Guarantee all property in transaction is hex.\n            txObject = helpers.formatters.inputCallFormatter(txObject)\n\n            const transaction = coverInitialTxValue(txObject)\n\n            const rlpEncoded = encodeRLPByTxType(transaction)\n\n            const messageHash = Hash.keccak256(rlpEncoded)\n\n            const sigs = isFeePayer ? existedFeePayerSignatures : existedSenderSignatures\n\n            for (const p of privateKeys) {\n                const signature = AccountLib.makeSigner(Nat.toNumber(transaction.chainId || '0x1') * 2 + 35)(messageHash, p)\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n                sigs.push([v, r, s])\n            }\n            // makeRawTransaction will return signatures and feePayerSignatures with duplicates removed.\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\n\n            result = {\n                messageHash,\n                v: sigs[0][0],\n                r: sigs[0][1],\n                s: sigs[0][2],\n                rawTransaction,\n                txHash: Hash.keccak256(rawTransaction),\n                senderTxHash: getSenderTxHash(rawTransaction),\n            }\n\n            if (isFeePayer) {\n                result.feePayerSignatures = feePayerSignatures\n            } else {\n                result.signatures = signatures\n            }\n        } catch (e) {\n            callback(e)\n            return Promise.reject(e)\n        }\n\n        callback(null, result)\n        return result\n    }\n\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n        return Promise.resolve(signed(tx))\n    }\n\n    // When the feePayer signs a transaction, required information is only chainId.\n    if (isFeePayer) {\n        return Promise.all([isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId]).then(function(args) {\n            if (isNot(args[0])) {\n                throw new Error(`\"chainId\" couldn't be fetched: ${JSON.stringify(args)}`)\n            }\n            return signed(_.extend(tx, { chainId: args[0] }))\n        })\n    }\n\n    // Otherwise, get the missing info from the Klaytn Node\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        return signed(\n            _.extend(tx, {\n                chainId: args[0],\n                gasPrice: args[1],\n                nonce: args[2],\n            })\n        )\n    })\n}\n\n/**\n * feePayerSignTransaction calls signTransaction, creating a format for feePayer to sign the transaction.\n * If there are feePayerSignatures in tx entered as a parameter, the signatures for fee payer are appended.\n *\n * @method feePayerSignTransaction\n * @param {Object|String} tx The transaction to sign.\n * @param {String} feePayer The address of fee payer.\n * @param {String|Array} privateKey The private key to use for signing.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.feePayerSignTransaction = function feePayerSignTransaction() {\n    const _this = this\n    let tx\n    let feePayer\n    let privateKey\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForFeePayerSignTransaction(arguments)\n        tx = resolved.tx\n        feePayer = resolved.feePayer\n        privateKey = resolved.privateKey\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    if (_.isString(tx)) {\n        return this.signTransaction({ senderRawTransaction: tx, feePayer }, privateKey, callback)\n    }\n\n    if (!tx.feePayer || tx.feePayer === '0x' || tx.feePayer === '0x0000000000000000000000000000000000000000') {\n        tx.feePayer = feePayer\n    }\n\n    if (!tx.senderRawTransaction) {\n        if (!tx.type || !tx.type.includes('FEE_DELEGATED')) {\n            return handleError(`Failed to sign transaction with fee payer: invalid transaction type(${tx.type ? tx.type : 'LEGACY'})`)\n        }\n    }\n\n    const e = helpers.validateFunction.validateParams(tx)\n    if (e) {\n        return handleError(e)\n    }\n\n    if (tx.feePayer.toLowerCase() !== feePayer.toLowerCase()) {\n        return handleError('Invalid parameter: The address of fee payer does not match.')\n    }\n\n    if (tx.senderRawTransaction) {\n        return this.signTransaction(tx, privateKey, callback)\n    }\n\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        const chainId = args[0]\n        const gasPrice = args[1]\n        const nonce = args[2]\n\n        if (isNot(chainId) || isNot(gasPrice) || isNot(nonce)) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        let transaction = _.extend(tx, { chainId, gasPrice, nonce })\n\n        transaction = helpers.formatters.inputCallFormatter(transaction)\n        transaction = coverInitialTxValue(transaction)\n\n        const rlpEncoded = encodeRLPByTxType(transaction)\n        const sig = transaction.signatures ? transaction.signatures : [['0x01', '0x', '0x']]\n        const { rawTransaction } = makeRawTransaction(rlpEncoded, sig, transaction)\n\n        return _this.signTransaction({ senderRawTransaction: rawTransaction, feePayer, chainId }, privateKey, callback)\n    })\n}\n\n/**\n * signTransactionWithHash signs to transaction hash with private key(s).\n *\n * @method signTransactionWithHash\n * @param {String} hash The hash of transaction to sign.\n * @param {String|Array} privateKeys The private key(s) to use for signing.\n * @param {String|Number} chainId The chain id of the network.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.signTransactionWithHash = function signTransactionWithHash() {\n    const _this = this\n    let hash\n    let privateKeys\n    let chainId\n    let callback\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    try {\n        const resolved = resolveArgsForSignTransactionWithHash(arguments)\n        hash = resolved.hash\n        chainId = resolved.chainId\n        privateKeys = resolved.privateKeys\n        callback = resolved.callback\n    } catch (e) {\n        return handleError(e)\n    }\n\n    privateKeys = Array.isArray(privateKeys) ? privateKeys : [privateKeys]\n\n    function signWithHash(transactionHash, prvKeys, chain, callbackFunc) {\n        const result = []\n        chain = utils.numberToHex(chain)\n\n        try {\n            for (const privateKey of prvKeys) {\n                const p = utils.addHexPrefix(utils.parsePrivateKey(privateKey).privateKey)\n                if (!utils.isValidPrivateKey(p)) {\n                    return handleError(`Failed to sign transaction with hash: Invalid private key ${privateKey}`)\n                }\n\n                const signature = AccountLib.makeSigner(Nat.toNumber(chain || '0x1') * 2 + 35)(transactionHash, p)\n                const [v, r, s] = AccountLib.decodeSignature(signature).map(sig => utils.makeEven(utils.trimLeadingZero(sig)))\n\n                result.push(utils.transformSignaturesToObject([v, r, s]))\n            }\n        } catch (e) {\n            callbackFunc(e)\n            return Promise.reject(e)\n        }\n\n        callbackFunc(null, result)\n        return result\n    }\n\n    return Promise.resolve(isNot(chainId) ? _this._klaytnCall.getChainId() : chainId).then(id => {\n        return signWithHash(hash, privateKeys, id, callback)\n    })\n}\n\n/**\n * getRawTransactionWithSignatures returns object which contains rawTransaction.\n *\n * @method getRawTransactionWithSignatures\n * @param {Object} tx The transaction object which contains signatures or feePayerSignatures.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.getRawTransactionWithSignatures = function getRawTransactionWithSignatures(tx, callback) {\n    const _this = this\n    let result\n\n    callback = callback || function() {}\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    if (!tx || !_.isObject(tx)) {\n        return handleError('Invalid parameter: The transaction must be defined as an object')\n    }\n    if (!tx.signatures && !tx.feePayerSignatures) {\n        return handleError('There are no signatures or feePayerSignatures defined in the transaction object.')\n    }\n\n    const error = helpers.validateFunction.validateParams(tx)\n    if (error) return handleError(error)\n\n    if (tx.senderRawTransaction) {\n        tx.feePayerSignatures = tx.feePayerSignatures || [['0x01', '0x', '0x']]\n\n        const decoded = decodeFromRawTransaction(tx.senderRawTransaction)\n        // feePayer !== '0x' means that in senderRawTransaction there are feePayerSignatures\n        if (\n            decoded.feePayer !== '0x' &&\n            decoded.feePayer !== '0x0000000000000000000000000000000000000000' &&\n            !utils.isEmptySig(decoded.feePayerSignatures)\n        ) {\n            if (decoded.feePayer.toLowerCase() !== tx.feePayer.toLowerCase()) {\n                return handleError('Invalid feePayer')\n            }\n            tx.feePayerSignatures = tx.feePayerSignatures.concat(decoded.feePayerSignatures)\n        }\n\n        decoded.feePayer = tx.feePayer\n        decoded.feePayerSignatures = tx.feePayerSignatures\n\n        if (tx.signatures) {\n            decoded.signatures = decoded.signatures.concat(tx.signatures)\n        }\n        tx = decoded\n    }\n\n    function signed(txObject) {\n        try {\n            // Guarantee all property in transaction is hex.\n            txObject = helpers.formatters.inputCallFormatter(txObject)\n\n            const transaction = coverInitialTxValue(txObject)\n\n            const rlpEncoded = encodeRLPByTxType(transaction)\n\n            let sigs = transaction.signatures ? transaction.signatures : ['0x01', '0x', '0x']\n\n            if (!_.isArray(sigs[0])) sigs = [sigs]\n\n            const { rawTransaction, signatures, feePayerSignatures } = makeRawTransaction(rlpEncoded, sigs, transaction)\n\n            result = {\n                rawTransaction,\n                txHash: Hash.keccak256(rawTransaction),\n                senderTxHash: getSenderTxHash(rawTransaction),\n            }\n\n            if (signatures && !utils.isEmptySig(signatures)) {\n                result.signatures = signatures\n            }\n\n            if (feePayerSignatures && !utils.isEmptySig(feePayerSignatures)) {\n                result.feePayerSignatures = feePayerSignatures\n            }\n        } catch (e) {\n            callback(e)\n            return Promise.reject(e)\n        }\n\n        callback(null, result)\n        return result\n    }\n\n    if (tx.nonce !== undefined && tx.chainId !== undefined && tx.gasPrice !== undefined) {\n        return Promise.resolve(signed(tx))\n    }\n\n    // Otherwise, get the missing info from the Klaytn Node\n    return Promise.all([\n        isNot(tx.chainId) ? _this._klaytnCall.getChainId() : tx.chainId,\n        isNot(tx.gasPrice) ? _this._klaytnCall.getGasPrice() : tx.gasPrice,\n        isNot(tx.nonce) ? _this._klaytnCall.getTransactionCount(tx.from, 'pending') : tx.nonce,\n    ]).then(function(args) {\n        if (isNot(args[0]) || isNot(args[1]) || isNot(args[2])) {\n            throw new Error(`One of the values \"chainId\", \"gasPrice\", or \"nonce\" couldn't be fetched: ${JSON.stringify(args)}`)\n        }\n        return signed(\n            _.extend(tx, {\n                chainId: args[0],\n                gasPrice: args[1],\n                nonce: args[2],\n            })\n        )\n    })\n}\n\n/**\n * combineSignatures combines RLP encoded raw transaction strings.\n * combineSignatures compares transaction before combining, and if values in field are not same, this throws error.\n * The comparison allows that the address of the fee payer is '0x0000000000000000000000000000000000000000'(default value) for some transactions while the other transactions have a specific fee payer. This is for the use case that some transactions do not have the fee payer's information.\n * In this case, feePayer field doesn't have to be compared with other transaction.\n *\n * @method combineSignatures\n * @param {Array} rawTransactions The array of raw transaction string to combine.\n * @param {Function} callback The callback function to call.\n * @return {Object}\n */\nAccounts.prototype.combineSignatures = function combineSignatures(rawTransactions, callback) {\n    let decodedTx\n    let senders = []\n    let feePayers = []\n    let feePayer\n\n    callback = callback || function() {}\n\n    const handleError = e => {\n        e = e instanceof Error ? e : new Error(e)\n        if (callback) callback(e)\n        return Promise.reject(e)\n    }\n\n    if (!_.isArray(rawTransactions)) {\n        return handleError('The parameter of the combineSignatures function must be an array of RLP encoded transaction strings.')\n    }\n\n    for (const raw of rawTransactions) {\n        const { senderSignatures, feePayerSignatures, decodedTransaction } = extractSignatures(raw)\n\n        senders = senders.concat(senderSignatures)\n        feePayers = feePayers.concat(feePayerSignatures)\n\n        if (decodedTx) {\n            let isSame = true\n            const keys = Object.keys(decodedTx)\n            for (const key of keys) {\n                if (\n                    key === 'v' ||\n                    key === 'r' ||\n                    key === 's' ||\n                    key === 'signatures' ||\n                    key === 'payerV' ||\n                    key === 'payerR' ||\n                    key === 'payerS' ||\n                    key === 'feePayerSignatures'\n                ) {\n                    continue\n                }\n\n                // feePayer field can be '0x' or '0x0000000000000000000000000000000000000000' when after sender signs to trasnaction.\n                // For handling this, if feePayer is '0x' or '0x0000000000000000000000000000000000000000', don't compare with other transaction\n                if (key === 'feePayer') {\n                    if (decodedTransaction[key] === '0x' || decodedTransaction[key] === '0x0000000000000000000000000000000000000000') {\n                        continue\n                    } else {\n                        // set feePayer letiable with valid feePayer address(not '0x' and '0x0000000000000000000000000000000000000000')\n                        feePayer = decodedTransaction[key]\n                        if (decodedTx[key] === '0x' || decodedTx[key] === '0x0000000000000000000000000000000000000000') {\n                            // set feePayer field to decodedTx for comparing feePayer address with other transactions\n                            decodedTx[key] = decodedTransaction[key]\n                        }\n                    }\n                }\n\n                if (decodedTransaction[key] === undefined || decodedTx[key] !== decodedTransaction[key]) {\n                    isSame = false\n                    break\n                }\n            }\n            if (!isSame) {\n                return handleError('Failed to combineSignatures: Signatures that sign to different transaction cannot be combined.')\n            }\n        } else {\n            decodedTx = decodedTransaction\n        }\n    }\n\n    const parsedTxObject = decodeFromRawTransaction(rawTransactions[0])\n    parsedTxObject.signatures = senders\n\n    if (feePayer) {\n        parsedTxObject.feePayer = feePayer\n        if (feePayers.length > 0) {\n            parsedTxObject.feePayerSignatures = feePayers\n        }\n    }\n    return this.getRawTransactionWithSignatures(parsedTxObject, callback)\n}\n\n/**\n * cav.klay.accounts.recoverTransaction('0xf86180808401ef364594f0109fc8df283027b6285cc889f5aa624eac1f5580801ca031573280d608f75137e33fc14655f097867d691d5c4c44ebe5ae186070ac3d5ea0524410802cdc025034daefcdfa08e7d2ee3f0b9d9ae184b2001fe0aff07603d9');\n * > \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\"\n */\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n    if (utils.getTxTypeStringFromRawTransaction(rawTx) !== undefined) {\n        throw new Error('recoverTransaction only supports transactions of type \"LEGACY\".')\n    }\n\n    const values = RLP.decode(rawTx)\n\n    // If the leading zero is trimmed, it will be filled with a valid length of '0'.\n    const arr = values.slice(7, 9).map(sig => {\n        sig = sig.replace('0x', '')\n        while (sig.length < 64) {\n            sig = `0${sig}`\n        }\n        return `0x${sig}`\n    })\n    arr.unshift(values[6])\n\n    const signature = AccountLib.encodeSignature(arr)\n    const recovery = Bytes.toNumber(values[6])\n    const extraData = recovery < 35 ? [] : [Bytes.fromNumber((recovery - 35) >> 1), '0x', '0x']\n    const signingData = values.slice(0, 6).concat(extraData)\n    const signingDataHex = RLP.encode(signingData)\n\n    return AccountLib.recover(Hash.keccak256(signingDataHex), signature)\n}\n\n/**\n * Hashes the given message to be passed cav.klay.accounts.recover() function.\n * The data will be UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message and hashed using keccak256.\n *\n * cav.klay.accounts.hashMessage(\"Hello World\")\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n * // the below results in the same hash\n * cav.klay.accounts.hashMessage(caver.utils.utf8ToHex(\"Hello World\"))\n * > \"0xa1de988600a42c4b4ab089b619297c17d53cffae5d5120d82d8a92d0bb3b78f2\"\n */\nAccounts.prototype.hashMessage = function hashMessage(data) {\n    const message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data\n    const messageBuffer = Buffer.from(message)\n    const preamble = `\\x19Klaytn Signed Message:\\n${message.length}`\n    const preambleBuffer = Buffer.from(preamble)\n    // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n    const klayMessage = Buffer.concat([preambleBuffer, messageBuffer])\n    // Finally, run keccak256 on klayMessage.\n    return Hash.keccak256(klayMessage)\n}\n\n/**\n * Signs arbitrary data.\n * This data is before UTF-8 HEX decoded and enveloped as follows:\n * \"\\x19Klaytn Signed Message:\\n\" + message.length + message.\n *\n * cav.klay.accounts.sign('Some data', '0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n * > {\n *     message: 'Some data',\n *     messageHash: '0x1da44b586eb0729ff70a73c326926f6ed5a25f5b056e7f47fbc6e58d86871655',\n *     v: '0x1c',\n *     r: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd',\n *     s: '0x6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a029',\n *     signature: '0xb91467e570a6466aa9e9876cbcd013baba02900b8979d43fe208a4a4f339f5fd6007e74cd82e037b800186422fc2da167c747ef045e5d18a5f5d4300f8e1a0291c'\n *   }\n */\nAccounts.prototype.sign = function sign(data, privateKey) {\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n    if (!utils.isValidPrivateKey(privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    const messageHash = this.hashMessage(data)\n    const signature = AccountLib.sign(messageHash, privateKey)\n    const [v, r, s] = AccountLib.decodeSignature(signature)\n    return {\n        message: data,\n        messageHash,\n        v,\n        r,\n        s,\n        signature,\n    }\n}\n\n/**\n * preFixed - Boolean (optional, default: false):\n * If the last parameter is true,\n * the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message,\n * and assumed to be already prefixed.\n */\nAccounts.prototype.recover = function recover(message, signature, preFixed) {\n    const args = [].slice.apply(arguments)\n\n    if (_.isObject(message)) {\n        return this.recover(message.messageHash, AccountLib.encodeSignature([message.v, message.r, message.s]), true)\n    }\n\n    if (!preFixed) {\n        message = this.hashMessage(message)\n    }\n\n    if (args.length >= 4) {\n        preFixed = args.slice(-1)[0]\n        preFixed = _.isBoolean(preFixed) ? !!preFixed : false\n\n        return this.recover(message, AccountLib.encodeSignature(args.slice(1, 4)), preFixed) // v, r, s\n    }\n    /**\n     * recover in Account module\n     * const recover = (hash, signature) => {\n     *   const vals = decodeSignature(signature);\n     *   const vrs = { v: Bytes.toNumber(vals[0]), r: vals[1].slice(2), s: vals[2].slice(2) };\n     *   const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n     *   const publicKey = \"0x\" + ecPublicKey.encode('hex', false).slice(2);\n     *   const publicHash = keccak256(publicKey);\n     *   const address = toChecksum(\"0x\" + publicHash.slice(-40));\n     *   return address;\n     * };\n     */\n    return AccountLib.recover(message, signature)\n}\n\n// Taken from https://github.com/ethereumjs/ethereumjs-wallet\nAccounts.prototype.decrypt = function(v3Keystore, password, nonStrict) {\n    if (!_.isString(password)) {\n        throw new Error('No password given.')\n    }\n\n    // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\n    const json = _.isObject(v3Keystore) ? _.cloneDeep(v3Keystore) : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore)\n\n    if (json.version !== 3 && json.version !== 4) {\n        console.warn('This is not a V3 or V4 wallet.')\n        // throw new Error('Not a valid V3 wallet');\n    }\n\n    if (json.version === 3 && !json.crypto) {\n        // crypto field should be existed in keystore version 3\n        throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\")\n    }\n\n    if (json.crypto) {\n        if (json.keyring) {\n            throw new Error(\"Invalid key store format: 'crypto' can not be with 'keyring'\")\n        }\n        json.keyring = [json.crypto]\n        delete json.crypto\n    }\n\n    if (_.isArray(json.keyring[0]) && json.keyring.length > 3) {\n        throw new Error('Invalid key store format')\n    }\n\n    let accountKey = {}\n\n    // AccountKeyRoleBased format\n    if (_.isArray(json.keyring[0])) {\n        const transactionKey = decryptKey(json.keyring[0])\n        if (transactionKey) accountKey.transactionKey = transactionKey\n\n        const updateKey = decryptKey(json.keyring[1])\n        if (updateKey) accountKey.updateKey = updateKey\n\n        const feePayerKey = decryptKey(json.keyring[2])\n        if (feePayerKey) accountKey.feePayerKey = feePayerKey\n    } else {\n        accountKey = decryptKey(json.keyring)\n    }\n\n    function decryptKey(encryptedArray) {\n        if (!encryptedArray || encryptedArray.length === 0) return undefined\n\n        const decryptedArray = []\n        for (const encrypted of encryptedArray) {\n            let derivedKey\n            let kdfparams\n            /**\n             * Supported kdf modules are the following:\n             * 1) pbkdf2\n             * 2) scrypt\n             */\n            if (encrypted.kdf === 'scrypt') {\n                kdfparams = encrypted.kdfparams\n\n                // FIXME: support progress reporting callback\n                derivedKey = scrypt.syncScrypt(\n                    Buffer.from(password),\n                    Buffer.from(kdfparams.salt, 'hex'),\n                    kdfparams.n,\n                    kdfparams.r,\n                    kdfparams.p,\n                    kdfparams.dklen\n                )\n            } else if (encrypted.kdf === 'pbkdf2') {\n                kdfparams = encrypted.kdfparams\n\n                if (kdfparams.prf !== 'hmac-sha256') {\n                    throw new Error('Unsupported parameters to PBKDF2')\n                }\n\n                derivedKey = cryp.pbkdf2Sync(\n                    Buffer.from(password),\n                    Buffer.from(kdfparams.salt, 'hex'),\n                    kdfparams.c,\n                    kdfparams.dklen,\n                    'sha256'\n                )\n            } else {\n                throw new Error('Unsupported key derivation scheme')\n            }\n\n            const ciphertext = Buffer.from(encrypted.ciphertext, 'hex')\n\n            const mac = utils.sha3(Buffer.from([...derivedKey.slice(16, 32), ...ciphertext])).replace('0x', '')\n            if (mac !== encrypted.mac) {\n                throw new Error('Key derivation failed - possibly wrong password')\n            }\n\n            const decipher = cryp.createDecipheriv(encrypted.cipher, derivedKey.slice(0, 16), Buffer.from(encrypted.cipherparams.iv, 'hex'))\n            decryptedArray.push(`0x${Buffer.from([...decipher.update(ciphertext), ...decipher.final()]).toString('hex')}`)\n        }\n        return decryptedArray.length === 1 ? decryptedArray[0] : decryptedArray\n    }\n\n    return this.createWithAccountKey(json.address, accountKey)\n}\n\n/*\n    The fields of kdfparams are described below.\n\n    `dklen` is the desired length of the derived key\n    `salt` - A string of characters that modifies the hash to protect against Rainbow table attacks\n    `n` - CPU/memory cost parameter\n    `r` - The blocksize parameter, which fine-tunes sequential memory read size and performance. 8 is commonly used.\n    `p` - Parallelization parameter\n    `c` - the number of iterations desired\n */\n/**\n * encrypt encrypts an account and returns a key store v4 object.\n *\n * @method encrypt\n * @param {String} key The key parameter can be a raw key format(private key string, KlaytnWalletKey, array of private keys or object with keys by roles) or an instance of Account or AccountKey.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\nAccounts.prototype.encrypt = function(key, password, options) {\n    /**\n     * options can include below\n     * {\n     *   salt: ...,\n     *   iv: ...,\n     *   kdf: ...,\n     *   dklen: ...,\n     *   c: ...,\n     *   n: ...,\n     *   r: ...,\n     *   p: ...,\n     *   cipher: ...,\n     *   uuid: ...,\n     *   cipher: ...,\n     * }\n     */\n    options = options || {}\n\n    let address\n    let account\n\n    if (key instanceof Account) {\n        if (options.address && options.address !== key.address) {\n            throw new Error('Address in account is not matched with address in options object')\n        }\n        address = key.address\n        account = key\n    } else if (_.isString(key)) {\n        account = this.privateKeyToAccount(key, options.address)\n        address = account.address\n    } else {\n        if (!options.address) {\n            throw new Error('The address must be defined inside the options object.')\n        }\n        address = options.address\n    }\n\n    if (!account) account = this.createWithAccountKey(address, key)\n\n    let keyring\n    let transactionKey\n    let updateKey\n    let feePayerKey\n\n    switch (account.accountKeyType) {\n        case AccountKeyEnum.ACCOUNT_KEY_PUBLIC:\n        case AccountKeyEnum.ACCOUNT_KEY_MULTISIG:\n            keyring = encryptKey(account.keys, password, options)\n            break\n        case AccountKeyEnum.ACCOUNT_KEY_ROLEBASED:\n            keyring = []\n            transactionKey = encryptKey(account.transactionKey, password, options)\n            updateKey = encryptKey(account.updateKey, password, options)\n            feePayerKey = encryptKey(account.feePayerKey, password, options)\n            keyring.push(transactionKey)\n            keyring.push(updateKey)\n            keyring.push(feePayerKey)\n            for (let i = keyring.length - 1; i >= 0; i--) {\n                if (keyring[i].length !== 0) break\n                keyring = keyring.slice(0, i)\n            }\n            break\n        default:\n            throw new Error(`Unsupported account key type: ${account.accountKeyType}`)\n    }\n\n    return {\n        version: 4,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase(),\n        keyring,\n    }\n}\n\n/**\n * encryptV3 encrypts an account and returns a key store v3 object.\n *\n * @method encryptV3\n * @param {String} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Account or AccountKeyPublic.\n * @param {String} password The password to be used for account encryption. The encrypted key store can be decrypted with this password.\n * @param {Object} options The options to use when encrypt an account.\n * @return {Object}\n */\nAccounts.prototype.encryptV3 = function(key, password, options) {\n    options = options || {}\n\n    let address\n    let account\n    const notSupportedType =\n        'Invalid parameter: encryptV3 only supports a single private key (also supports KlantnWalletKey format), or an instance of Account or AccountKeyPublic as a parameter. If you want to encrypt multiple keys, use caver.klay.accounts.encrypt which encrypts to keystore v4.'\n\n    if (key instanceof Account) {\n        if (options.address && options.address !== key.address) {\n            throw new Error('Address in account is not matched with address in options object')\n        }\n        if (key.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\n\n        address = key.address\n        account = key\n    } else if (_.isString(key)) {\n        account = this.privateKeyToAccount(key, options.address)\n        address = account.address\n    } else if (Account.isAccountKey(key)) {\n        if (key.type !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) throw new Error(notSupportedType)\n        if (!options.address) {\n            throw new Error('The address must be defined inside the options object.')\n        }\n\n        address = options.address\n    } else {\n        throw new Error(notSupportedType)\n    }\n\n    if (!account) account = this.createWithAccountKey(address, key)\n\n    const crypto = encryptKey(account.keys, password, options)\n\n    return {\n        version: 3,\n        id: uuid.v4({ random: options.uuid || cryp.randomBytes(16) }),\n        address: account.address.toLowerCase(),\n        crypto: crypto[0],\n    }\n}\n\nAccounts.prototype.privateKeyToPublicKey = function(privateKey, compressed = false) {\n    const parsed = utils.parsePrivateKey(privateKey)\n    privateKey = parsed.privateKey\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey.slice(2) : privateKey\n\n    if (privateKey.length !== 64) {\n        throw new Error('Received a invalid privateKey. The length of privateKey should be 64.')\n    }\n    const buffer = Buffer.from(privateKey, 'hex')\n    const ecKey = secp256k1.keyFromPrivate(buffer)\n\n    let publicKey\n\n    if (!compressed) {\n        publicKey = `0x${ecKey.getPublic(false, 'hex').slice(2)}`\n    } else {\n        publicKey = `0x${ecKey.getPublic(true, 'hex')}`\n    }\n\n    return publicKey\n}\n\nAccounts.prototype.encodeRLPByTxType = encodeRLPByTxType\n\nAccounts.prototype.setAccounts = function(accounts) {\n    this.wallet.clear()\n\n    for (let i = 0; i < accounts.wallet.length; i++) {\n        this.wallet.add(accounts.wallet[i])\n    }\n\n    return this\n}\n\n/* eslint-enable complexity */\n\n// Note: this is trying to follow closely the specs on\n\n/**\n  > Wallet {\n      0: {...}, // account by index\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},  // same account by address\n      \"0xf0109fc8df283027b6285cc889f5aa624eac1f55\": {...},  // same account by address lowercase\n      1: {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...},\n      \"0xd0122fc8df283027b6285cc889f5aa624eac1d23\": {...},\n\n      add: function(){},\n      remove: function(){},\n      save: function(){},\n      load: function(){},\n      clear: function(){},\n\n      length: 2,\n  }\n *\n * Contains an in memory wallet with multiple accounts.\n * These accounts can be used when using cav.klay.sendTransaction().\n */\nfunction Wallet(accounts) {\n    this._accounts = accounts\n    this.length = 0\n    this.defaultKeyName = 'caverjs_wallet'\n}\n\nWallet.prototype._findSafeIndex = function(pointer) {\n    pointer = pointer || 0\n    if (_.has(this, pointer)) {\n        return this._findSafeIndex(pointer + 1)\n    }\n    return pointer\n}\n\nWallet.prototype._currentIndexes = function() {\n    const keys = Object.keys(this)\n    const indexes = keys\n        .map(function(key) {\n            return parseInt(key)\n        })\n        .filter(function(n) {\n            return n < 9e20\n        })\n\n    return indexes\n}\n\nWallet.prototype.create = function(numberOfAccounts, entropy) {\n    for (let i = 0; i < numberOfAccounts; ++i) {\n        this.add(this._accounts.create(entropy).privateKey)\n    }\n    return this\n}\n\n/**\n * Adds an account using a private key or account object to the wallet.\n *\n * cav.klay.accounts.wallet.add({\n    privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n    address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n    });\n    > {\n        index: 0,\n        address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01',\n        privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n        signTransaction: function(tx){...},\n        sign: function(data){...},\n        encrypt: function(password){...}\n    }\n */\nWallet.prototype.add = function(account, userInputAddress) {\n    let accountForWallet\n    /**\n     * cav.klay.accounts.wallet.add('0x4c0883a69102937d6231471b5dbb6204fe5129617082792ae468d01a3f362318');\n     *\n     * cav.klay.accounts.wallet.add({\n     *   privateKey: '0x348ce564d427a3311b6536bbcff9390d69395b06ed6c486954e971d960fe8709',\n     *   address: '0xb8CE9ab6943e0eCED004cDe8e3bBed6568B2Fa01'\n     * });\n     */\n    if (Account.isAccountKey(account)) {\n        if (!userInputAddress) {\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey')\n        }\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, account)\n    } else if (account instanceof Account) {\n        accountForWallet = this._accounts.createWithAccountKey(account.address, account.accountKey)\n        accountForWallet.address = userInputAddress || account.address\n    } else if (_.isObject(account) && account.address && account.privateKey) {\n        accountForWallet = this._accounts.privateKeyToAccount(account.privateKey, userInputAddress || account.address)\n    } else if (_.isString(account)) {\n        accountForWallet = this._accounts.privateKeyToAccount(account, userInputAddress)\n    } else {\n        const accountKey = this._accounts.createAccountKey(account)\n        if (!userInputAddress) {\n            throw new Error('Address is not defined. Address cannot be determined from AccountKey format')\n        }\n        accountForWallet = this._accounts.createWithAccountKey(userInputAddress, accountKey)\n    }\n\n    if (this[accountForWallet.address]) {\n        throw new Error(`Account exists with ${accountForWallet.address}`)\n    }\n\n    accountForWallet.index = this._findSafeIndex()\n    this[accountForWallet.index] = accountForWallet\n\n    this[accountForWallet.address] = accountForWallet\n    this[accountForWallet.address.toLowerCase()] = accountForWallet\n    this[accountForWallet.address.toUpperCase()] = accountForWallet\n    try {\n        this[utils.toChecksumAddress(accountForWallet.address)] = accountForWallet\n    } catch (e) {}\n\n    this.length++\n\n    return accountForWallet\n}\n\nWallet.prototype.updatePrivateKey = function(privateKey, address) {\n    if (privateKey === undefined || address === undefined) {\n        throw new Error('To update the privatKey in wallet, need to set both privateKey and address.')\n    }\n\n    // If privateKey parameter is not string type, return error\n    if (!_.isString(privateKey)) {\n        throw new Error('The private key used for the update is not a valid string.')\n    }\n\n    if (!utils.isAddress(address)) {\n        throw new Error(`Invalid address : ${address}`)\n    }\n\n    // If failed to find account through address, return error\n    const accountExists = !!this[address]\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\n\n    const account = this[address]\n\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error(\n            'Account using AccountKeyMultiSig or AccountKeyRoleBased must be updated using the caver.klay.accounts.updateAccountKey function.'\n        )\n    }\n\n    const parsed = utils.parsePrivateKey(privateKey)\n    if (!utils.isValidPrivateKey(parsed.privateKey)) {\n        throw new Error('Invalid private key')\n    }\n\n    if (parsed.address && parsed.address !== account.address) {\n        throw new Error('The address extracted from the private key does not match the address received as the input value.')\n    }\n\n    const newAccountKeyPublic = new AccountKeyPublic(parsed.privateKey)\n    this[account.index].accountKey = newAccountKeyPublic\n    this[account.address].accountKey = newAccountKeyPublic\n    this[account.address.toLowerCase()].accountKey = newAccountKeyPublic\n    this[account.address.toUpperCase()].accountKey = newAccountKeyPublic\n\n    try {\n        this[utils.toChecksumAddress(account.address)].accountKey = newAccountKeyPublic\n    } catch (e) {}\n\n    return account\n}\n\nWallet.prototype.updateAccountKey = function updateAccountKey(address, accountKey) {\n    if (address === undefined || accountKey === undefined) {\n        throw new Error('To update the accountKey in wallet, need to set both address and accountKey.')\n    }\n\n    if (!Account.isAccountKey(accountKey)) {\n        accountKey = this._accounts.createAccountKey(accountKey)\n    }\n\n    if (!utils.isAddress(address)) {\n        throw new Error(`Invalid address : ${address}`)\n    }\n\n    // If failed to find account through address, return error\n    const accountExists = !!this[address]\n    if (!accountExists) throw new Error(`Failed to find account with ${address}`)\n\n    const account = this[address]\n\n    this[account.index].accountKey = accountKey\n    this[account.address].accountKey = accountKey\n    this[account.address.toLowerCase()].accountKey = accountKey\n    this[account.address.toUpperCase()].accountKey = accountKey\n\n    try {\n        this[utils.toChecksumAddress(account.address)].accountKey = accountKey\n    } catch (e) {}\n\n    return account\n}\n\nWallet.prototype.remove = function(addressOrIndex) {\n    const account = this[addressOrIndex]\n\n    if (account && account.address) {\n        // address\n        this[account.address].accountKey = null\n        delete this[account.address]\n\n        if (this[account.address.toLowerCase()]) {\n            // address lowercase\n            this[account.address.toLowerCase()].accountKey = null\n            delete this[account.address.toLowerCase()]\n        }\n\n        if (this[account.address.toUpperCase()]) {\n            // address uppercase\n            this[account.address.toUpperCase()].accountKey = null\n            delete this[account.address.toUpperCase()]\n        }\n\n        try {\n            this[utils.toChecksumAddress(account.address)].accountKey = null\n            delete this[utils.toChecksumAddress(account.address)]\n        } catch (e) {}\n\n        // index\n        this[account.index].accountKey = null\n        delete this[account.index]\n\n        this.length--\n\n        return true\n    }\n    return false\n}\n\nWallet.prototype.clear = function() {\n    const _this = this\n    const indexes = this._currentIndexes()\n\n    indexes.forEach(function(index) {\n        _this.remove(index)\n    })\n\n    return this\n}\n\n/**\n * cav.klay.accounts.wallet.encrypt('test');\n    > [ { version: 3,\n        id: 'dcf8ab05-a314-4e37-b972-bf9b86f91372',\n        address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n        crypto:\n         { ciphertext: '0de804dc63940820f6b3334e5a4bfc8214e27fb30bb7e9b7b74b25cd7eb5c604',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'b2aac1485bd6ee1928665642bf8eae9ddfbc039c3a673658933d320bac6952e3' } },\n      { version: 3,\n        id: '9e1c7d24-b919-4428-b10e-0f3ef79f7cf0',\n        address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n        crypto:\n         { ciphertext: 'd705ebed2a136d9e4db7e5ae70ed1f69d6a57370d5fbe06281eb07615f404410',\n           cipherparams: [Object],\n           cipher: 'aes-128-ctr',\n           kdf: 'scrypt',\n           kdfparams: [Object],\n           mac: 'af9eca5eb01b0f70e909f824f0e7cdb90c350a802f04a9f6afe056602b92272b' } }\n    ]\n */\nWallet.prototype.encrypt = function(password, options) {\n    const _this = this\n    const indexes = this._currentIndexes()\n\n    const accounts = indexes.map(function(index) {\n        return _this[index].encrypt(password, options)\n    })\n\n    return accounts\n}\n\n/**\n * cav.klay.accounts.wallet.decrypt([\n    { version: 3,\n    id: '83191a81-aaca-451f-b63d-0c5f3b849289',\n    address: '06f702337909c06c82b09b7a22f0a2f0855d1f68',\n    crypto:\n     { ciphertext: '7d34deae112841fba86e3e6cf08f5398dda323a8e4d29332621534e2c4069e8d',\n       cipherparams: { iv: '497f4d26997a84d570778eae874b2333' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '208dd732a27aa4803bb760228dff18515d5313fd085bbce60594a3919ae2d88d',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: '0062a853de302513c57bfe3108ab493733034bf3cb313326f42cf26ea2619cf9' } },\n     { version: 3,\n    id: '7d6b91fa-3611-407b-b16b-396efb28f97e',\n    address: 'b5d89661b59a9af0b34f58d19138baa2de48baaf',\n    crypto:\n     { ciphertext: 'cb9712d1982ff89f571fa5dbef447f14b7e5f142232bd2a913aac833730eeb43',\n       cipherparams: { iv: '8cccb91cb84e435437f7282ec2ffd2db' },\n       cipher: 'aes-128-ctr',\n       kdf: 'scrypt',\n       kdfparams:\n        { dklen: 32,\n          salt: '08ba6736363c5586434cd5b895e6fe41ea7db4785bd9b901dedce77a1514e8b8',\n          n: 262144,\n          r: 8,\n          p: 1 },\n       mac: 'd2eb068b37e2df55f56fa97a2bf4f55e072bef0dd703bfd917717d9dc54510f0' } }\n  ], 'test');\n  > Wallet {\n      0: {...},\n      1: {...},\n      \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n      \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n      ...\n  }\n */\nWallet.prototype.decrypt = function(encryptedWallet, password) {\n    const _this = this\n\n    encryptedWallet.forEach(function(keystore) {\n        const account = _this._accounts.decrypt(keystore, password)\n\n        if (!account) {\n            throw new Error(\"Couldn't decrypt the keystore. Maybe wrong password?\")\n        }\n\n        const exist = !!_this[account.address]\n        if (!exist) {\n            _this.add(account)\n        }\n    })\n\n    return this\n}\n\nWallet.prototype.save = function(password, keyName) {\n    /* eslint-disable-next-line no-undef */\n    localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)))\n\n    return true\n}\n\n/**\n * cav.klay.accounts.wallet.load('test#!$', 'myWalletKey' || 'web3js_wallet');\n    > Wallet {\n        0: {...},\n        1: {...},\n        \"0xF0109fC8DF283027b6285cc889F5aA624EaC1F55\": {...},\n        \"0xD0122fC8DF283027b6285cc889F5aA624EaC1d23\": {...}\n        ...\n    }\n */\nWallet.prototype.load = function(password, keyName) {\n    /* eslint-disable-next-line no-undef */\n    let keystore = localStorage.getItem(keyName || this.defaultKeyName)\n\n    if (keystore) {\n        try {\n            keystore = JSON.parse(keystore)\n        } catch (e) {}\n    }\n\n    return this.decrypt(keystore || [], password)\n}\n\nif (typeof localStorage === 'undefined') {\n    delete Wallet.prototype.save\n    delete Wallet.prototype.load\n}\n\nWallet.prototype.getKlaytnWalletKey = function(addressOrIndex) {\n    const account = this[addressOrIndex]\n    if (!account) throw new Error('Failed to find account')\n\n    return genKlaytnWalletKeyStringFromAccount(account)\n}\n\nWallet.prototype.getAccount = function(input) {\n    if (_.isNumber(input)) {\n        if (this.length <= input) {\n            throw new Error(`The index(${input}) is out of range(Wallet length : ${this.length}).`)\n        }\n        return this[input]\n    }\n\n    if (!_.isString(input)) {\n        throw new Error(`Accounts in the Wallet can be searched by only index or address. :${input}`)\n    }\n\n    if (!utils.isAddress(input)) {\n        throw new Error(`Failed to getAccount from Wallet: invalid address(${input})`)\n    }\n\n    return this[input.toLowerCase()]\n}\n\nfunction genKlaytnWalletKeyStringFromAccount(account) {\n    if (account.accountKeyType !== AccountKeyEnum.ACCOUNT_KEY_PUBLIC) {\n        throw new Error('The account cannot be exported in KlaytnWalletKey format. Use caver.klay.accounts.encrypt or account.encrypt.')\n    }\n    let addressString = account.address\n    let { privateKey } = account\n\n    privateKey = privateKey.slice(0, 2) === '0x' ? privateKey : `0x${privateKey}`\n    addressString = addressString.slice(0, 2) === '0x' ? addressString : `0x${addressString}`\n\n    return `${privateKey}0x00${addressString}`\n}\n\nmodule.exports = Accounts\n"]},"metadata":{},"sourceType":"script"}