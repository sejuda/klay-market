{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nconst ParamType = require('@ethersproject/abi').ParamType;\n\nconst utils = require('../../caver-utils');\n\nconst ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\n\n\nconst ABICoder = function () {};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\n\n\nABICoder.prototype.encodeEventSignature = function (functionName) {\n  if (_.isObject(functionName)) {\n    functionName = utils._jsonInterfaceMethodToString(functionName);\n  }\n\n  return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\n\n\nABICoder.prototype.encodeParameter = function (type, param) {\n  return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n * Tuple type can be used like below\n * `caver.abi.encodeParameters(['tuple(bytes32,bool)', 'tuple(bool,address)'], [['0xabd...', true], [true, '0x776...']])`\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\n\n\nABICoder.prototype.encodeParameters = function (types, params) {\n  const self = this;\n  types = self.mapTypes(types);\n  params = params.map(function (param, index) {\n    let type = types[index]; // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\n\n    if (typeof type === 'object' && type.type) {\n      // We may get a named type of shape {name, type}\n      type = type.type;\n    }\n\n    param = self.formatParam(type, param); // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\n    // To avoid invalid encoding value, adding error handling.\n\n    if (type === 'string' && typeof param !== 'string') throw new Error(`Invalid parameter: Parameter value and type do not match.`); // Format params for tuples\n\n    if (typeof type === 'string' && type.includes('tuple')) {\n      const coder = ethersAbiCoder._getCoder(ParamType.from(type)); // eslint-disable-next-line no-shadow\n\n\n      const modifyParams = (coder, param) => {\n        if (coder.name === 'array') {\n          return param.map(p => {\n            // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\n            // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\n            const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '');\n            const parameterType = ParamType.from(replacedType);\n\n            const gotCoder = ethersAbiCoder._getCoder(parameterType);\n\n            modifyParams(gotCoder, p);\n          });\n        }\n\n        coder.coders.forEach((c, i) => {\n          if (c.name === 'tuple') {\n            modifyParams(c, param[i]);\n          } else {\n            param[i] = self.formatParam(c.name, param[i]);\n          }\n        });\n      };\n\n      modifyParams(coder, param);\n    }\n\n    return param;\n  });\n  return ethersAbiCoder.encode(types, params);\n};\n/**\n * Should be used to encode smart contract deployment with constructor arguments\n *\n * @method encodeContractDeploy\n * @param {Array} types\n * @param {Array} params\n * @return {String} bytecode + args\n */\n\n\nABICoder.prototype.encodeContractDeploy = function (jsonInterface, bytecode, ...args) {\n  if (!jsonInterface) {\n    throw new Error('jsonInterface should be provided for encoding contract deployment.');\n  }\n\n  if (!bytecode) {\n    throw new Error('bytecode should be provided for encoding contract deployment.');\n  }\n\n  const constructorInterface = jsonInterface.filter(({\n    type\n  }) => type === 'constructor')[0];\n  const constructorInputs = constructorInterface && constructorInterface.inputs; // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\n\n  if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\n    return bytecode;\n  }\n\n  if (constructorInputs.length !== args.length) {\n    throw new Error(`invalid number of parameters for deploying. Got ${args.length} expected ${constructorInputs.length}!`);\n  }\n\n  const constructorTypes = constructorInputs.map(({\n    type\n  }) => type);\n  return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '');\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\n\n\nABICoder.prototype.mapTypes = function (types) {\n  const self = this;\n  const mappedTypes = [];\n  types.forEach(function (type) {\n    // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n    if (typeof type === 'object' && type.type === 'function') {\n      type = Object.assign({}, type, {\n        type: 'bytes24'\n      });\n    }\n\n    if (self.isSimplifiedStructFormat(type)) {\n      const structName = Object.keys(type)[0];\n      mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n        components: self.mapStructToCoderFormat(type[structName])\n      }));\n      return;\n    }\n\n    mappedTypes.push(type);\n  });\n  return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\n\n\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n  return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\n\n\nABICoder.prototype.mapStructNameAndType = function (structName) {\n  let type = 'tuple';\n\n  if (structName.indexOf('[]') > -1) {\n    type = 'tuple[]';\n    structName = structName.slice(0, -2);\n  }\n\n  return {\n    type: type,\n    name: structName\n  };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\n\n\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n  const self = this;\n  const components = [];\n  Object.keys(struct).forEach(function (key) {\n    if (typeof struct[key] === 'object') {\n      components.push(Object.assign(self.mapStructNameAndType(key), {\n        components: self.mapStructToCoderFormat(struct[key])\n      }));\n      return;\n    }\n\n    components.push({\n      name: key,\n      type: struct[key]\n    });\n  });\n  return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\n\n\nABICoder.prototype.formatParam = function (type, param) {\n  const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n  const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n  const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n  const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/); // Format BN to string\n\n  if (utils.isBN(param) || utils.isBigNumber(param)) {\n    return param.toString(10);\n  }\n\n  if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n    return param.map(p => this.formatParam(type.replace('[]', ''), p));\n  } // Format correct width for u?int[0-9]*\n\n\n  let match = type.match(paramTypeNumber);\n\n  if (match) {\n    const size = parseInt(match[2] || '256');\n\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      param = utils.leftPad(param, size);\n    }\n  } // Format correct length for bytes[0-9]+\n\n\n  match = type.match(paramTypeBytes);\n\n  if (match) {\n    if (Buffer.isBuffer(param)) {\n      param = utils.toHex(param);\n    } // format to correct length\n\n\n    const size = parseInt(match[1]);\n\n    if (size) {\n      let maxSize = size * 2;\n\n      if (param.substring(0, 2) === '0x') {\n        maxSize += 2;\n      }\n\n      if (param.length < maxSize) {\n        // pad to correct length\n        param = utils.rightPad(param, size * 2);\n      }\n    } // format odd-length bytes to even-length\n\n\n    if (param.length % 2 === 1) {\n      param = `0x0${param.substring(2)}`;\n    }\n  }\n\n  return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\n\n\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n  return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\n\n\nABICoder.prototype.decodeParameter = function (type, bytes) {\n  return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameters\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n  return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParametersWith\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\n *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n  if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n    throw new Error(\"Returned values aren't valid, did it run Out of Gas? \" + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n  }\n\n  const res = ethersAbiCoder.decode(this.mapTypes(outputs), `0x${bytes.replace(/0x/i, '')}`, loose);\n  const returnValue = new Result();\n  returnValue.__length__ = 0;\n  outputs.forEach(function (output, i) {\n    let decodedValue = res[returnValue.__length__];\n    decodedValue = decodedValue === '0x' ? null : decodedValue;\n    returnValue[i] = decodedValue;\n\n    if (_.isObject(output) && output.name) {\n      returnValue[output.name] = decodedValue;\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\n\n\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n  const _this = this;\n\n  topics = _.isArray(topics) ? topics : [topics];\n  data = data || '';\n  const notIndexedInputs = [];\n  const indexedParams = [];\n  let topicCount = 0; // TODO check for anonymous logs?\n\n  inputs.forEach(function (input, i) {\n    if (input.indexed) {\n      indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n        return input.type.indexOf(staticType) !== -1;\n      }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n      topicCount++;\n    } else {\n      notIndexedInputs[i] = input;\n    }\n  });\n  const nonIndexedData = data;\n  const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n  const returnValue = new Result();\n  returnValue.__length__ = 0;\n  inputs.forEach(function (res, i) {\n    returnValue[i] = res.type === 'string' ? '' : null;\n\n    if (typeof notIndexedParams[i] !== 'undefined') {\n      returnValue[i] = notIndexedParams[i];\n    }\n\n    if (typeof indexedParams[i] !== 'undefined') {\n      returnValue[i] = indexedParams[i];\n    }\n\n    if (res.name) {\n      returnValue[res.name] = returnValue[i];\n    }\n\n    returnValue.__length__++;\n  });\n  return returnValue;\n};\n\nconst coder = new ABICoder();\nmodule.exports = coder;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-abi/src/index.js"],"names":["_","require","EthersAbiCoder","AbiCoder","ParamType","utils","ethersAbiCoder","type","value","match","isArray","isObject","constructor","name","toString","Result","ABICoder","prototype","encodeFunctionSignature","functionName","_jsonInterfaceMethodToString","sha3","slice","encodeEventSignature","encodeParameter","param","encodeParameters","types","params","self","mapTypes","map","index","formatParam","Error","includes","coder","_getCoder","from","modifyParams","p","replacedType","replace","parameterType","gotCoder","coders","forEach","c","i","encode","encodeContractDeploy","jsonInterface","bytecode","args","constructorInterface","filter","constructorInputs","inputs","isEmpty","length","constructorTypes","mappedTypes","Object","assign","isSimplifiedStructFormat","structName","keys","push","mapStructNameAndType","components","mapStructToCoderFormat","indexOf","struct","key","paramTypeBytes","RegExp","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","isBN","isBigNumber","size","parseInt","leftPad","Buffer","isBuffer","toHex","maxSize","substring","rightPad","encodeFunctionCall","decodeParameter","bytes","decodeParameters","outputs","decodeParametersWith","loose","res","decode","returnValue","__length__","output","decodedValue","decodeLog","data","topics","_this","notIndexedInputs","indexedParams","topicCount","input","indexed","find","staticType","nonIndexedData","notIndexedParams","module","exports"],"mappings":"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","sourcesContent":["/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\n\nconst _ = require('lodash')\n\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder\nconst ParamType = require('@ethersproject/abi').ParamType\nconst utils = require('../../caver-utils')\n\nconst ethersAbiCoder = new EthersAbiCoder(function(type, value) {\n    if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n        return value.toString()\n    }\n    return value\n})\n\n// result method\nfunction Result() {}\n\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nconst ABICoder = function() {}\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function(functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName)\n    }\n\n    return utils.sha3(functionName).slice(0, 10)\n}\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function(functionName) {\n    if (_.isObject(functionName)) {\n        functionName = utils._jsonInterfaceMethodToString(functionName)\n    }\n\n    return utils.sha3(functionName)\n}\n\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n * @param {String} type\n * @param {Object} param\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function(type, param) {\n    return this.encodeParameters([type], [param])\n}\n\n/**\n * Should be used to encode list of params\n * Tuple type can be used like below\n * `caver.abi.encodeParameters(['tuple(bytes32,bool)', 'tuple(bool,address)'], [['0xabd...', true], [true, '0x776...']])`\n *\n * @method encodeParameters\n * @param {Array} types\n * @param {Array} params\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function(types, params) {\n    const self = this\n    types = self.mapTypes(types)\n\n    params = params.map(function(param, index) {\n        let type = types[index]\n\n        // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type\n        }\n\n        param = self.formatParam(type, param)\n\n        // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\n        // To avoid invalid encoding value, adding error handling.\n        if (type === 'string' && typeof param !== 'string') throw new Error(`Invalid parameter: Parameter value and type do not match.`)\n\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type))\n            // eslint-disable-next-line no-shadow\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    return param.map(p => {\n                        // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\n                        // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\n                        const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '')\n                        const parameterType = ParamType.from(replacedType)\n                        const gotCoder = ethersAbiCoder._getCoder(parameterType)\n                        modifyParams(gotCoder, p)\n                    })\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i])\n                    } else {\n                        param[i] = self.formatParam(c.name, param[i])\n                    }\n                })\n            }\n            modifyParams(coder, param)\n        }\n\n        return param\n    })\n\n    return ethersAbiCoder.encode(types, params)\n}\n\n/**\n * Should be used to encode smart contract deployment with constructor arguments\n *\n * @method encodeContractDeploy\n * @param {Array} types\n * @param {Array} params\n * @return {String} bytecode + args\n */\nABICoder.prototype.encodeContractDeploy = function(jsonInterface, bytecode, ...args) {\n    if (!jsonInterface) {\n        throw new Error('jsonInterface should be provided for encoding contract deployment.')\n    }\n\n    if (!bytecode) {\n        throw new Error('bytecode should be provided for encoding contract deployment.')\n    }\n\n    const constructorInterface = jsonInterface.filter(({ type }) => type === 'constructor')[0]\n    const constructorInputs = constructorInterface && constructorInterface.inputs\n\n    // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\n    if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\n        return bytecode\n    }\n\n    if (constructorInputs.length !== args.length) {\n        throw new Error(`invalid number of parameters for deploying. Got ${args.length} expected ${constructorInputs.length}!`)\n    }\n\n    const constructorTypes = constructorInputs.map(({ type }) => type)\n\n    return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '')\n}\n\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function(types) {\n    const self = this\n    const mappedTypes = []\n    types.forEach(function(type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: 'bytes24' })\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            const structName = Object.keys(type)[0]\n            mappedTypes.push(\n                Object.assign(self.mapStructNameAndType(structName), {\n                    components: self.mapStructToCoderFormat(type[structName]),\n                })\n            )\n\n            return\n        }\n\n        mappedTypes.push(type)\n    })\n    return mappedTypes\n}\n\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function(type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined'\n}\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function(structName) {\n    let type = 'tuple'\n\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]'\n        structName = structName.slice(0, -2)\n    }\n\n    return { type: type, name: structName }\n}\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function(struct) {\n    const self = this\n    const components = []\n    Object.keys(struct).forEach(function(key) {\n        if (typeof struct[key] === 'object') {\n            components.push(\n                Object.assign(self.mapStructNameAndType(key), {\n                    components: self.mapStructToCoderFormat(struct[key]),\n                })\n            )\n\n            return\n        }\n\n        components.push({\n            name: key,\n            type: struct[key],\n        })\n    })\n\n    return components\n}\n\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function(type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/)\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/)\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/)\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/)\n\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10)\n    }\n\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p))\n    }\n\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber)\n    if (match) {\n        const size = parseInt(match[2] || '256')\n        if (size / 8 < param.length) {\n            // pad to correct bit width\n            param = utils.leftPad(param, size)\n        }\n    }\n\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes)\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param)\n        }\n\n        // format to correct length\n        const size = parseInt(match[1])\n        if (size) {\n            let maxSize = size * 2\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2)\n            }\n        }\n\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = `0x0${param.substring(2)}`\n        }\n    }\n\n    return param\n}\n\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function(jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '')\n}\n\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function(type, bytes) {\n    return this.decodeParameters([type], bytes)[0]\n}\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameters\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function(outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false)\n}\n\n/**\n * Should be used to decode list of params\n *\n * @method decodeParametersWith\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\n *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function(outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error(\n            \"Returned values aren't valid, did it run Out of Gas? \" +\n                'You might also see this error if you are not using the ' +\n                'correct ABI for the contract you are retrieving data from, ' +\n                'requesting data from a block number that does not exist, ' +\n                'or querying a node which is not fully synced.'\n        )\n    }\n\n    const res = ethersAbiCoder.decode(this.mapTypes(outputs), `0x${bytes.replace(/0x/i, '')}`, loose)\n    const returnValue = new Result()\n    returnValue.__length__ = 0\n\n    outputs.forEach(function(output, i) {\n        let decodedValue = res[returnValue.__length__]\n        decodedValue = decodedValue === '0x' ? null : decodedValue\n\n        returnValue[i] = decodedValue\n\n        if (_.isObject(output) && output.name) {\n            returnValue[output.name] = decodedValue\n        }\n\n        returnValue.__length__++\n    })\n\n    return returnValue\n}\n\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function(inputs, data, topics) {\n    const _this = this\n    topics = _.isArray(topics) ? topics : [topics]\n\n    data = data || ''\n\n    const notIndexedInputs = []\n    const indexedParams = []\n    let topicCount = 0\n\n    // TODO check for anonymous logs?\n\n    inputs.forEach(function(input, i) {\n        if (input.indexed) {\n            indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function(staticType) {\n                return input.type.indexOf(staticType) !== -1\n            })\n                ? _this.decodeParameter(input.type, topics[topicCount])\n                : topics[topicCount]\n            topicCount++\n        } else {\n            notIndexedInputs[i] = input\n        }\n    })\n\n    const nonIndexedData = data\n    const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : []\n\n    const returnValue = new Result()\n    returnValue.__length__ = 0\n\n    inputs.forEach(function(res, i) {\n        returnValue[i] = res.type === 'string' ? '' : null\n\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i]\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i]\n        }\n\n        if (res.name) {\n            returnValue[res.name] = returnValue[i]\n        }\n\n        returnValue.__length__++\n    })\n\n    return returnValue\n}\n\nconst coder = new ABICoder()\n\nmodule.exports = coder\n"]},"metadata":{},"sourceType":"script"}