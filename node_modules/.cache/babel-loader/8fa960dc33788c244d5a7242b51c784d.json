{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst AccountLib = require('eth-lib/lib/account');\n\nconst utils = require('../../../caver-utils/src');\n\nconst PrivateKey = require('./privateKey');\n\nconst {\n  KEY_ROLE,\n  isMultipleKeysFormat,\n  isRoleBasedKeysFormat\n} = require('./keyringHelper');\n\nconst {\n  decryptKey\n} = require('./keyringHelper');\n\nconst SingleKeyring = require('./singleKeyring');\n\nconst MultipleKeyring = require('./multipleKeyring');\n\nconst RoleBasedKeyring = require('./roleBasedKeyring');\n\nconst SignatureData = require('./signatureData');\n/**\n * representing a KeyringFactory which supports create functions for Keyring(SingleKeyring/MultipleKeyring/RoleBasedKeyring)\n * @class\n */\n\n\nclass KeyringFactory {\n  /**\n   * generates a keyring instance\n   *\n   * `caver.wallet.keyring.generate()`\n   *\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {SingleKeyring}\n   */\n  static generate(entropy) {\n    const random = AccountLib.create(entropy || utils.randomHex(32));\n    return KeyringFactory.createWithSingleKey(random.address, random.privateKey);\n  }\n  /**\n   * generates a single private key string\n   *\n   * `caver.wallet.keyring.generateSingleKey()`\n   *\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {String}\n   */\n\n\n  static generateSingleKey(entropy) {\n    return AccountLib.create(entropy || utils.randomHex(32)).privateKey;\n  }\n  /**\n   * generates an array of private key strings\n   *\n   * `caver.wallet.keyring.generateMultipleKeys()`\n   *\n   * @param {number} num A length of keys.\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {Array.<String>}\n   */\n\n\n  static generateMultipleKeys(num, entropy) {\n    if (num === undefined || !_.isNumber(num) || _.isString(num)) {\n      throw new Error(`To generate random multiple private keys, the number of keys should be defined.`);\n    }\n\n    const randomKeys = [];\n\n    for (let i = 0; i < num; i++) {\n      randomKeys.push(AccountLib.create(entropy || utils.randomHex(32)).privateKey);\n    }\n\n    return randomKeys;\n  }\n  /**\n   * generates an array in which keys to be used for each role are defined as an array.\n   *\n   * `caver.wallet.keyring.generateRoleBasedKeys()`\n   *\n   * @param {Array.<number>} numArr An array containing the number of keys for each role.\n   * @param {string} [entropy] A random string to increase entropy.\n   * @return {Array.<Array.<String>>}\n   */\n\n\n  static generateRoleBasedKeys(numArr, entropy) {\n    if (numArr === undefined || !_.isArray(numArr) || _.isString(numArr)) {\n      throw new Error(`To generate random role-based private keys, an array containing the number of keys for each role should be defined.`);\n    }\n\n    if (numArr.length > KEY_ROLE.roleLast) {\n      throw new Error(`Unsupported role. The length of array should be less than ${KEY_ROLE.roleLast}.`);\n    }\n\n    const randomKeys = [[], [], []];\n\n    for (let i = 0; i < numArr.length; i++) {\n      for (let j = 0; j < numArr[i]; j++) {\n        randomKeys[i].push(AccountLib.create(entropy || utils.randomHex(32)).privateKey);\n      }\n    }\n\n    return randomKeys;\n  }\n  /**\n   * creates a keyring instance with parameters\n   *\n   * `caver.wallet.keyring.create('0x${address in hex}', '0x{private key}')`\n   * `caver.wallet.keyring.create('0x${address in hex}', ['0x{private key}', '0x{private key}'])`\n   * `caver.wallet.keyring.create('0x${address in hex}', [['0x{private key}', '0x{private key}'], ['0x{private key}'], ['0x{private key}', '0x{private key}']])`\n   *\n   * @param {string} address An address of keyring.\n   * @param {string|Array.<string>|Array.<Array.<string>>} key Private key(s) to use in keyring.\n   * @return {SingleKeyring|MultipleKeyring|RoleBasedKeyring}\n   */\n\n\n  static create(address, key) {\n    if (_.isString(key)) return KeyringFactory.createWithSingleKey(address, key);\n    if (isMultipleKeysFormat(key)) return KeyringFactory.createWithMultipleKey(address, key);\n    if (isRoleBasedKeysFormat(key)) return KeyringFactory.createWithRoleBasedKey(address, key);\n    throw new Error(`Unsupported key type: ${typeof key}`);\n  }\n  /**\n   * creates a keyring instance from a private key string. KlaytnWalletKey format also can be handled.\n   *\n   * @param {string} privateKey The key parameter can be either normal private key or KlaytnWalletKey format.\n   * @return {SingleKeyring}\n   */\n\n\n  static createFromPrivateKey(privateKey) {\n    if (!_.isString(privateKey)) throw new Error(`Invalid format of parameter. 'privateKey' should be in format of string`);\n    if (utils.isKlaytnWalletKey(privateKey)) return KeyringFactory.createFromKlaytnWalletKey(privateKey);\n    const acct = AccountLib.fromPrivate(utils.addHexPrefix(privateKey));\n    return KeyringFactory.createWithSingleKey(acct.address, acct.privateKey);\n  }\n  /**\n   * creates a keyring instance from a KlaytnWalletKey string.\n   *\n   * @param {string} klaytnWalletKey A key string in KlaytnWalletKey format.\n   * @return {SingleKeyring}\n   */\n\n\n  static createFromKlaytnWalletKey(klaytnWalletKey) {\n    if (!_.isString(klaytnWalletKey)) throw new Error(`Invalid format of parameter. 'klaytnWalletKey' should be in format of string`);\n\n    if (!utils.isKlaytnWalletKey(klaytnWalletKey)) {\n      throw new Error(`Invalid KlaytnWalletKey: ${klaytnWalletKey}`);\n    }\n\n    const parsed = utils.parsePrivateKey(klaytnWalletKey);\n    return KeyringFactory.createWithSingleKey(parsed.address, parsed.privateKey);\n  }\n  /**\n   * creates a keyring instance from an address and a private key string.\n   *\n   * @param {string} address An address of keyring.\n   * @param {string} key A private key string.\n   * @return {SingleKeyring}\n   */\n\n\n  static createWithSingleKey(address, key) {\n    if (!_.isString(key)) throw new Error(`Invalid format of parameter. Use 'fromMultipleKey' or 'fromRoleBasedKey' for two or more keys.`);\n    if (utils.isKlaytnWalletKey(key)) throw new Error(`Invalid format of parameter. Use 'fromKlaytnWalletKey' to create Keyring from KlaytnWalletKey.`);\n    return new SingleKeyring(address, key);\n  }\n  /**\n   * creates a keyring instance from an address and multiple private key strings.\n   *\n   * @param {string} address An address of keyring.\n   * @param {Array.<string>} keyArray An array of private key strings.\n   * @return {MultipleKeyring}\n   */\n\n\n  static createWithMultipleKey(address, keyArray) {\n    if (!isMultipleKeysFormat(keyArray)) throw new Error(`Invalid format of parameter. 'keyArray' should be an array of private key strings.`);\n    return new MultipleKeyring(address, keyArray);\n  }\n  /**\n   * creates a keyring instance from an address and an array in which keys to be used for each role are defined as an array.\n   *\n   * @param {string} address An address of keyring.\n   * @param {Array.<Array.<string>>} roledBasedKeyArray A two-dimensional array containing arrays of private key strings for each role.\n   * @return {RoleBasedKeyring}\n   */\n\n\n  static createWithRoleBasedKey(address, roledBasedKeyArray) {\n    if (!isRoleBasedKeysFormat(roledBasedKeyArray)) throw new Error(`Invalid format of parameter. 'roledBasedKeyArray' should be in the form of an array defined as an array for the keys to be used for each role.`);\n    return new RoleBasedKeyring(address, roledBasedKeyArray);\n  }\n  /**\n   * decrypts a keystore v3 or v4 JSON and returns keyring instance.\n   *\n   * @param {object} keystore The encrypted keystore to decrypt.\n   * @param {string} password The password to use for decryption.\n   * @return {SingleKeyring|MultipleKeyring|RoleBasedKeyring}\n   */\n\n\n  static decrypt(keystore, password) {\n    // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\n    const json = _.isObject(keystore) ? _.cloneDeep(keystore) : JSON.parse(keystore);\n    if (json.version !== 3 && json.version !== 4) console.warn('This is not a V3 or V4 wallet.');\n\n    if (json.version === 3 && !json.crypto) {\n      throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\");\n    } else if (json.version === 4 && !json.keyring) {\n      throw new Error(\"Invalid keystore V4 format: 'keyring' is not defined.\");\n    }\n\n    if (json.crypto) {\n      if (json.keyring) throw new Error(\"Invalid key store format: 'crypto' and 'keyring' cannot be defined together.\");\n      json.keyring = [json.crypto];\n      delete json.crypto;\n    } // AccountKeyRoleBased format\n\n\n    if (_.isArray(json.keyring[0])) {\n      const keys = [];\n      const transactionKey = decryptKey(json.keyring[KEY_ROLE.roleTransactionKey], password);\n      transactionKey ? keys.push(transactionKey) : keys.push([]);\n      const updateKey = decryptKey(json.keyring[KEY_ROLE.roleAccountUpdateKey], password);\n      updateKey ? keys.push(updateKey) : keys.push([]);\n      const feePayerKey = decryptKey(json.keyring[KEY_ROLE.roleFeePayerKey], password);\n      feePayerKey ? keys.push(feePayerKey) : keys.push([]);\n      return KeyringFactory.createWithRoleBasedKey(json.address, keys);\n    }\n\n    let decrypted = decryptKey(json.keyring, password);\n    decrypted = _.isArray(decrypted) ? decrypted : [decrypted];\n    if (decrypted.length === 1) return KeyringFactory.createWithSingleKey(json.address, decrypted[0]);\n    return KeyringFactory.createWithMultipleKey(json.address, decrypted);\n  } // /**\n  //  * encrypts a keyring and returns a keystore v4 object.\n  //  *\n  //  * @param {string|Array.<string>|Array.<string>|Keyring} key The key parameter can be an instance of Keyring, a normal private key(KlaytnWalletKey format also supported),\n  //  *                                                           an array of private key strings, or a two-dimensional array containing arrays of private key strings for each role,\n  //  * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n  //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n  //  * @return {object}\n  //  */\n  // static encrypt(key, password, options = {}) {\n  //     let keyring\n  //     if (_.isArray(key)) {\n  //         if (options.address === undefined)\n  //             throw new Error(`The address must be defined inside the options object to encrypt multiple keys.`)\n  //         if (isRoleBasedKeysFormat(key)) {\n  //             keyring = KeyringFactory.createWithRoleBasedKey(options.address, key)\n  //         } else if (isMultipleKeysFormat(key)) {\n  //             keyring = KeyringFactory.createWithMultipleKey(options.address, key)\n  //         } else {\n  //             throw new Error(`Invalid key format.`)\n  //         }\n  //     } else if (key instanceof AbstractKeyring) {\n  //         keyring = key\n  //     } else if (_.isString(key)) {\n  //         if (options.address) {\n  //             if (utils.isKlaytnWalletKey(key)) {\n  //                 keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n  //                 if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n  //                     throw new Error(\n  //                         `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n  //                     )\n  //                 }\n  //             } else {\n  //                 keyring = KeyringFactory.createWithSingleKey(options.address, key)\n  //             }\n  //         } else {\n  //             keyring = KeyringFactory.createFromPrivateKey(key)\n  //         }\n  //     } else {\n  //         throw new Error(`Invalid key format.`)\n  //     }\n  //     return keyring.encrypt(password, options)\n  // }\n  // /**\n  //  * encrypts a keyring and returns a keystore v3 object.\n  //  *\n  //  * @param {string|Keyring} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Keyring.\n  //  * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n  //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n  //  * @return {object}\n  //  */\n  // static encryptV3(key, password, options = {}) {\n  //     if (!_.isString(key) && !(key instanceof Keyring)) {\n  //         throw new Error(`Invalid parameter. key should be a private key string, KlaytnWalletKey or instance of Keyring`)\n  //     }\n  //     let keyring\n  //     if (key instanceof Keyring) {\n  //         keyring = key\n  //     } else if (options.address) {\n  //         if (utils.isKlaytnWalletKey(key)) {\n  //             keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n  //             if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n  //                 throw new Error(\n  //                     `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n  //                 )\n  //             }\n  //         } else {\n  //             keyring = KeyringFactory.createWithSingleKey(options.address, key)\n  //         }\n  //     } else {\n  //         keyring = KeyringFactory.createFromPrivateKey(key)\n  //     }\n  //     return keyring.encryptV3(password, options)\n  // }\n\n\n}\n\nKeyringFactory.privateKey = PrivateKey;\nKeyringFactory.singleKeyring = SingleKeyring;\nKeyringFactory.multipleKeyring = MultipleKeyring;\nKeyringFactory.roleBasedKeyring = RoleBasedKeyring;\nKeyringFactory.role = KEY_ROLE;\nKeyringFactory.signatureData = SignatureData;\nmodule.exports = KeyringFactory;","map":{"version":3,"sources":["/Users/mac/Desktop/klay-market/node_modules/caver-js/packages/caver-wallet/src/keyring/keyringFactory.js"],"names":["_","require","AccountLib","utils","PrivateKey","KEY_ROLE","isMultipleKeysFormat","isRoleBasedKeysFormat","decryptKey","SingleKeyring","MultipleKeyring","RoleBasedKeyring","SignatureData","KeyringFactory","generate","entropy","random","create","randomHex","createWithSingleKey","address","privateKey","generateSingleKey","generateMultipleKeys","num","undefined","isNumber","isString","Error","randomKeys","i","push","generateRoleBasedKeys","numArr","isArray","length","roleLast","j","key","createWithMultipleKey","createWithRoleBasedKey","createFromPrivateKey","isKlaytnWalletKey","createFromKlaytnWalletKey","acct","fromPrivate","addHexPrefix","klaytnWalletKey","parsed","parsePrivateKey","keyArray","roledBasedKeyArray","decrypt","keystore","password","json","isObject","cloneDeep","JSON","parse","version","console","warn","crypto","keyring","keys","transactionKey","roleTransactionKey","updateKey","roleAccountUpdateKey","feePayerKey","roleFeePayerKey","decrypted","singleKeyring","multipleKeyring","roleBasedKeyring","role","signatureData","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst AccountLib = require('eth-lib/lib/account')\n\nconst utils = require('../../../caver-utils/src')\nconst PrivateKey = require('./privateKey')\nconst { KEY_ROLE, isMultipleKeysFormat, isRoleBasedKeysFormat } = require('./keyringHelper')\nconst { decryptKey } = require('./keyringHelper')\nconst SingleKeyring = require('./singleKeyring')\nconst MultipleKeyring = require('./multipleKeyring')\nconst RoleBasedKeyring = require('./roleBasedKeyring')\nconst SignatureData = require('./signatureData')\n\n/**\n * representing a KeyringFactory which supports create functions for Keyring(SingleKeyring/MultipleKeyring/RoleBasedKeyring)\n * @class\n */\nclass KeyringFactory {\n    /**\n     * generates a keyring instance\n     *\n     * `caver.wallet.keyring.generate()`\n     *\n     * @param {string} [entropy] A random string to increase entropy.\n     * @return {SingleKeyring}\n     */\n    static generate(entropy) {\n        const random = AccountLib.create(entropy || utils.randomHex(32))\n        return KeyringFactory.createWithSingleKey(random.address, random.privateKey)\n    }\n\n    /**\n     * generates a single private key string\n     *\n     * `caver.wallet.keyring.generateSingleKey()`\n     *\n     * @param {string} [entropy] A random string to increase entropy.\n     * @return {String}\n     */\n    static generateSingleKey(entropy) {\n        return AccountLib.create(entropy || utils.randomHex(32)).privateKey\n    }\n\n    /**\n     * generates an array of private key strings\n     *\n     * `caver.wallet.keyring.generateMultipleKeys()`\n     *\n     * @param {number} num A length of keys.\n     * @param {string} [entropy] A random string to increase entropy.\n     * @return {Array.<String>}\n     */\n    static generateMultipleKeys(num, entropy) {\n        if (num === undefined || !_.isNumber(num) || _.isString(num)) {\n            throw new Error(`To generate random multiple private keys, the number of keys should be defined.`)\n        }\n\n        const randomKeys = []\n        for (let i = 0; i < num; i++) {\n            randomKeys.push(AccountLib.create(entropy || utils.randomHex(32)).privateKey)\n        }\n        return randomKeys\n    }\n\n    /**\n     * generates an array in which keys to be used for each role are defined as an array.\n     *\n     * `caver.wallet.keyring.generateRoleBasedKeys()`\n     *\n     * @param {Array.<number>} numArr An array containing the number of keys for each role.\n     * @param {string} [entropy] A random string to increase entropy.\n     * @return {Array.<Array.<String>>}\n     */\n    static generateRoleBasedKeys(numArr, entropy) {\n        if (numArr === undefined || !_.isArray(numArr) || _.isString(numArr)) {\n            throw new Error(\n                `To generate random role-based private keys, an array containing the number of keys for each role should be defined.`\n            )\n        }\n        if (numArr.length > KEY_ROLE.roleLast) {\n            throw new Error(`Unsupported role. The length of array should be less than ${KEY_ROLE.roleLast}.`)\n        }\n\n        const randomKeys = [[], [], []]\n        for (let i = 0; i < numArr.length; i++) {\n            for (let j = 0; j < numArr[i]; j++) {\n                randomKeys[i].push(AccountLib.create(entropy || utils.randomHex(32)).privateKey)\n            }\n        }\n        return randomKeys\n    }\n\n    /**\n     * creates a keyring instance with parameters\n     *\n     * `caver.wallet.keyring.create('0x${address in hex}', '0x{private key}')`\n     * `caver.wallet.keyring.create('0x${address in hex}', ['0x{private key}', '0x{private key}'])`\n     * `caver.wallet.keyring.create('0x${address in hex}', [['0x{private key}', '0x{private key}'], ['0x{private key}'], ['0x{private key}', '0x{private key}']])`\n     *\n     * @param {string} address An address of keyring.\n     * @param {string|Array.<string>|Array.<Array.<string>>} key Private key(s) to use in keyring.\n     * @return {SingleKeyring|MultipleKeyring|RoleBasedKeyring}\n     */\n    static create(address, key) {\n        if (_.isString(key)) return KeyringFactory.createWithSingleKey(address, key)\n        if (isMultipleKeysFormat(key)) return KeyringFactory.createWithMultipleKey(address, key)\n        if (isRoleBasedKeysFormat(key)) return KeyringFactory.createWithRoleBasedKey(address, key)\n\n        throw new Error(`Unsupported key type: ${typeof key}`)\n    }\n\n    /**\n     * creates a keyring instance from a private key string. KlaytnWalletKey format also can be handled.\n     *\n     * @param {string} privateKey The key parameter can be either normal private key or KlaytnWalletKey format.\n     * @return {SingleKeyring}\n     */\n    static createFromPrivateKey(privateKey) {\n        if (!_.isString(privateKey)) throw new Error(`Invalid format of parameter. 'privateKey' should be in format of string`)\n        if (utils.isKlaytnWalletKey(privateKey)) return KeyringFactory.createFromKlaytnWalletKey(privateKey)\n\n        const acct = AccountLib.fromPrivate(utils.addHexPrefix(privateKey))\n        return KeyringFactory.createWithSingleKey(acct.address, acct.privateKey)\n    }\n\n    /**\n     * creates a keyring instance from a KlaytnWalletKey string.\n     *\n     * @param {string} klaytnWalletKey A key string in KlaytnWalletKey format.\n     * @return {SingleKeyring}\n     */\n    static createFromKlaytnWalletKey(klaytnWalletKey) {\n        if (!_.isString(klaytnWalletKey)) throw new Error(`Invalid format of parameter. 'klaytnWalletKey' should be in format of string`)\n        if (!utils.isKlaytnWalletKey(klaytnWalletKey)) {\n            throw new Error(`Invalid KlaytnWalletKey: ${klaytnWalletKey}`)\n        }\n        const parsed = utils.parsePrivateKey(klaytnWalletKey)\n        return KeyringFactory.createWithSingleKey(parsed.address, parsed.privateKey)\n    }\n\n    /**\n     * creates a keyring instance from an address and a private key string.\n     *\n     * @param {string} address An address of keyring.\n     * @param {string} key A private key string.\n     * @return {SingleKeyring}\n     */\n    static createWithSingleKey(address, key) {\n        if (!_.isString(key))\n            throw new Error(`Invalid format of parameter. Use 'fromMultipleKey' or 'fromRoleBasedKey' for two or more keys.`)\n        if (utils.isKlaytnWalletKey(key))\n            throw new Error(`Invalid format of parameter. Use 'fromKlaytnWalletKey' to create Keyring from KlaytnWalletKey.`)\n\n        return new SingleKeyring(address, key)\n    }\n\n    /**\n     * creates a keyring instance from an address and multiple private key strings.\n     *\n     * @param {string} address An address of keyring.\n     * @param {Array.<string>} keyArray An array of private key strings.\n     * @return {MultipleKeyring}\n     */\n    static createWithMultipleKey(address, keyArray) {\n        if (!isMultipleKeysFormat(keyArray))\n            throw new Error(`Invalid format of parameter. 'keyArray' should be an array of private key strings.`)\n\n        return new MultipleKeyring(address, keyArray)\n    }\n\n    /**\n     * creates a keyring instance from an address and an array in which keys to be used for each role are defined as an array.\n     *\n     * @param {string} address An address of keyring.\n     * @param {Array.<Array.<string>>} roledBasedKeyArray A two-dimensional array containing arrays of private key strings for each role.\n     * @return {RoleBasedKeyring}\n     */\n    static createWithRoleBasedKey(address, roledBasedKeyArray) {\n        if (!isRoleBasedKeysFormat(roledBasedKeyArray))\n            throw new Error(\n                `Invalid format of parameter. 'roledBasedKeyArray' should be in the form of an array defined as an array for the keys to be used for each role.`\n            )\n\n        return new RoleBasedKeyring(address, roledBasedKeyArray)\n    }\n\n    /**\n     * decrypts a keystore v3 or v4 JSON and returns keyring instance.\n     *\n     * @param {object} keystore The encrypted keystore to decrypt.\n     * @param {string} password The password to use for decryption.\n     * @return {SingleKeyring|MultipleKeyring|RoleBasedKeyring}\n     */\n    static decrypt(keystore, password) {\n        // To deep copy an object, using JSON.parse and JSON.stringify (object -> string -> object)\n        const json = _.isObject(keystore) ? _.cloneDeep(keystore) : JSON.parse(keystore)\n\n        if (json.version !== 3 && json.version !== 4) console.warn('This is not a V3 or V4 wallet.')\n\n        if (json.version === 3 && !json.crypto) {\n            throw new Error(\"Invalid keystore V3 format: 'crypto' is not defined.\")\n        } else if (json.version === 4 && !json.keyring) {\n            throw new Error(\"Invalid keystore V4 format: 'keyring' is not defined.\")\n        }\n\n        if (json.crypto) {\n            if (json.keyring) throw new Error(\"Invalid key store format: 'crypto' and 'keyring' cannot be defined together.\")\n\n            json.keyring = [json.crypto]\n            delete json.crypto\n        }\n\n        // AccountKeyRoleBased format\n        if (_.isArray(json.keyring[0])) {\n            const keys = []\n            const transactionKey = decryptKey(json.keyring[KEY_ROLE.roleTransactionKey], password)\n            transactionKey ? keys.push(transactionKey) : keys.push([])\n\n            const updateKey = decryptKey(json.keyring[KEY_ROLE.roleAccountUpdateKey], password)\n            updateKey ? keys.push(updateKey) : keys.push([])\n\n            const feePayerKey = decryptKey(json.keyring[KEY_ROLE.roleFeePayerKey], password)\n            feePayerKey ? keys.push(feePayerKey) : keys.push([])\n\n            return KeyringFactory.createWithRoleBasedKey(json.address, keys)\n        }\n\n        let decrypted = decryptKey(json.keyring, password)\n        decrypted = _.isArray(decrypted) ? decrypted : [decrypted]\n        if (decrypted.length === 1) return KeyringFactory.createWithSingleKey(json.address, decrypted[0])\n\n        return KeyringFactory.createWithMultipleKey(json.address, decrypted)\n    }\n\n    // /**\n    //  * encrypts a keyring and returns a keystore v4 object.\n    //  *\n    //  * @param {string|Array.<string>|Array.<string>|Keyring} key The key parameter can be an instance of Keyring, a normal private key(KlaytnWalletKey format also supported),\n    //  *                                                           an array of private key strings, or a two-dimensional array containing arrays of private key strings for each role,\n    //  * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n    //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n    //  * @return {object}\n    //  */\n    // static encrypt(key, password, options = {}) {\n    //     let keyring\n    //     if (_.isArray(key)) {\n    //         if (options.address === undefined)\n    //             throw new Error(`The address must be defined inside the options object to encrypt multiple keys.`)\n\n    //         if (isRoleBasedKeysFormat(key)) {\n    //             keyring = KeyringFactory.createWithRoleBasedKey(options.address, key)\n    //         } else if (isMultipleKeysFormat(key)) {\n    //             keyring = KeyringFactory.createWithMultipleKey(options.address, key)\n    //         } else {\n    //             throw new Error(`Invalid key format.`)\n    //         }\n    //     } else if (key instanceof AbstractKeyring) {\n    //         keyring = key\n    //     } else if (_.isString(key)) {\n    //         if (options.address) {\n    //             if (utils.isKlaytnWalletKey(key)) {\n    //                 keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n    //                 if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n    //                     throw new Error(\n    //                         `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n    //                     )\n    //                 }\n    //             } else {\n    //                 keyring = KeyringFactory.createWithSingleKey(options.address, key)\n    //             }\n    //         } else {\n    //             keyring = KeyringFactory.createFromPrivateKey(key)\n    //         }\n    //     } else {\n    //         throw new Error(`Invalid key format.`)\n    //     }\n\n    //     return keyring.encrypt(password, options)\n    // }\n\n    // /**\n    //  * encrypts a keyring and returns a keystore v3 object.\n    //  *\n    //  * @param {string|Keyring} key The key parameter can be a normal private key(KlaytnWalletKey format also supported) or an instance of Keyring.\n    //  * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n    //  * @param {object} options The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n    //  * @return {object}\n    //  */\n    // static encryptV3(key, password, options = {}) {\n    //     if (!_.isString(key) && !(key instanceof Keyring)) {\n    //         throw new Error(`Invalid parameter. key should be a private key string, KlaytnWalletKey or instance of Keyring`)\n    //     }\n\n    //     let keyring\n    //     if (key instanceof Keyring) {\n    //         keyring = key\n    //     } else if (options.address) {\n    //         if (utils.isKlaytnWalletKey(key)) {\n    //             keyring = KeyringFactory.createFromKlaytnWalletKey(key)\n    //             if (keyring.address.toLowerCase() !== options.address.toLowerCase()) {\n    //                 throw new Error(\n    //                     `The address defined in options(${options.address}) does not match the address of KlaytnWalletKey(${keyring.address}) entered as a parameter.`\n    //                 )\n    //             }\n    //         } else {\n    //             keyring = KeyringFactory.createWithSingleKey(options.address, key)\n    //         }\n    //     } else {\n    //         keyring = KeyringFactory.createFromPrivateKey(key)\n    //     }\n\n    //     return keyring.encryptV3(password, options)\n    // }\n}\n\nKeyringFactory.privateKey = PrivateKey\nKeyringFactory.singleKeyring = SingleKeyring\nKeyringFactory.multipleKeyring = MultipleKeyring\nKeyringFactory.roleBasedKeyring = RoleBasedKeyring\nKeyringFactory.role = KEY_ROLE\nKeyringFactory.signatureData = SignatureData\n\nmodule.exports = KeyringFactory\n"]},"metadata":{},"sourceType":"script"}